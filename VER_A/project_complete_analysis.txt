================================================================================
PROJECT COMPLETE ANALYSIS REPORT
Total Files: 29
================================================================================

(1) PROJECT STRUCTURE TREE
========================================

[FILE] colors.py
  (No Classes or Functions detected - likely settings/constants only)

[FILE] convert_map.py
  [Function] convert_tile_value(value, unknown_tiles)
  [Function] convert_map_data(data, unknown_tiles, current_key)
  [Function] get_user_mapping(old_code)
  [Function] main()

[FILE] core\base_state.py
  [Class] BaseState
    └── [Method] __init__(self, game)
    └── [Method] enter(self, params)
    └── [Method] exit(self)
    └── [Method] update(self, dt)
    └── [Method] draw(self, screen)
    └── [Method] handle_event(self, event)

[FILE] core\engine.py
  [Class] GameEngine
    └── [Method] __init__(self)
    └── [Method] run(self)
    └── [Method] process_events(self)
    └── [Method] update(self, dt)
    └── [Method] draw(self)
    └── [Method] quit(self)

[FILE] core\state_machine.py
  [Class] StateMachine
    └── [Method] __init__(self, game)
    └── [Method] push(self, state)
    └── [Method] pop(self)
    └── [Method] change(self, state, params)
    └── [Method] update(self, dt)
    └── [Method] draw(self, screen)
    └── [Method] handle_event(self, event)

[FILE] entities\__init__.py
  (No Classes or Functions detected - likely settings/constants only)

[FILE] entities\entity.py
  [Class] Entity
    └── [Method] __init__(self, x, y, map_data, map_width, map_height, zone_map, name, role, map_manager)
    └── [Method] add_popup(self, text, color)
    └── [Method] is_visible_villain(self, phase)
    └── [Method] morning_process(self)
    └── [Method] is_stunned(self)
    └── [Method] take_stun(self, duration_ms)
    └── [Method] take_damage(self, amount)
    └── [Method] heal(self, amount)
    └── [Method] try_spend_ap(self, amount, allow_health_cost)
    └── [Method] use_item(self, item_key)
    └── [Method] move_single_axis(self, dx, dy, npcs)

[FILE] entities\npc.py
  [Class] BTState
  [Class] BTNode
    └── [Method] tick(self, entity, blackboard)
  [Class] Composite
    └── [Method] __init__(self, children)
  [Class] Selector
    └── [Method] tick(self, entity, blackboard)
  [Class] Sequence
    └── [Method] tick(self, entity, blackboard)
  [Class] Action
    └── [Method] __init__(self, action_func)
    └── [Method] tick(self, entity, blackboard)
  [Class] Condition
    └── [Method] __init__(self, condition_func)
    └── [Method] tick(self, entity, blackboard)
  [Class] Dummy
    └── [Method] __init__(self, x, y, map_data, map_width, map_height, name, role, tile_cache, zone_map, map_manager)
    └── [Method] add_popup(self, text, color)
    └── [Method] add_suspicion(self, target_name, amount)
    └── [Method] morning_process(self)
    └── [Method] _build_behavior_tree(self)
    └── [Method] police_scan_targets(self, entity, bb)
    └── [Method] mafia_scan_targets(self, entity, bb)
    └── [Method] has_last_seen_pos(self, entity, bb)
    └── [Method] has_investigate_pos(self, entity, bb)
    └── [Method] check_danger(self, entity, bb)
    └── [Method] check_needs_shopping(self, entity, bb)
    └── [Method] is_work_time(self, entity, bb)
    └── [Method] is_night_time(self, entity, bb)
    └── [Method] can_sabotage(self, entity, bb)
    └── [Method] police_chase_attack(self, entity, bb)
    └── [Method] police_investigate_last_pos(self, entity, bb)
    └── [Method] police_investigate_noise(self, entity, bb)
    └── [Method] do_patrol(self, entity, bb)
    └── [Method] do_flee_or_hide(self, entity, bb)
    └── [Method] do_shopping(self, entity, bb)
    └── [Method] do_work(self, entity, bb)
    └── [Method] do_work_fake(self, entity, bb)
    └── [Method] do_go_home(self, entity, bb)
    └── [Method] mafia_kill(self, entity, bb)
    └── [Method] mafia_sabotage(self, entity, bb)
    └── [Method] do_wander(self, entity, bb)
    └── [Method] _validate_environment(self)
    └── [Method] update(self, phase, player, npcs, is_mafia_frozen, noise_list, day_count, bloody_footsteps, siren_timer)
    └── [Method] set_destination(self, tx, ty, reason)
    └── [Method] _threaded_calculate_path(self, start_gx, start_gy, target_gx, target_gy, reason)
    └── [Method] process_movement(self, phase, npcs, slow_down)
    └── [Method] random_move(self)
    └── [Method] find_tile(self, target_ids, sort_by_distance, npcs)
    └── [Method] get_valid_neighbor(self, tx, ty)
    └── [Method] has_line_of_sight(self, target)
    └── [Method] check_stat_changes(self)
    └── [Method] find_house_door(self, npcs)
    └── [Method] find_hiding_spot(self, npcs)
    └── [Method] draw(self, screen, camera_x, camera_y, viewer_role, viewer_device_on)

[FILE] entities\player.py
  [Class] Bullet
    └── [Method] __init__(self, x, y, angle, is_enemy)
    └── [Method] update(self)
    └── [Method] draw(self, screen, camera_x, camera_y)
  [Class] Player
    └── [Method] __init__(self, x, y, width, height, map_data, zone_map, map_manager)
    └── [Method] is_dead(self)
    └── [Method] is_dead(self, value)
    └── [Method] reset(self)
    └── [Method] change_role(self, new_role, sub_role)
    └── [Method] morning_process(self, slept_at_home)
    └── [Method] toggle_flashlight(self)
    └── [Method] toggle_device(self)
    └── [Method] update(self, phase, npcs, is_blackout, weather_type)
    └── [Method] calculate_emotions(self, phase, npcs, is_blackout)
    └── [Method] get_current_speed(self, weather_type)
    └── [Method] _handle_movement_input(self)
    └── [Method] _update_devices_and_battery(self, now)
    └── [Method] _update_stamina(self, is_moving)
    └── [Method] _generate_status_noises(self, now, is_moving)
    └── [Method] _update_special_states(self, now)
    └── [Method] get_vision_radius(self, vision_factor, is_blackout, weather_type, remaining_time, total_duration)
    └── [Method] heal_full(self)
    └── [Method] buy_item(self, item_key)
    └── [Method] use_active_skill(self)
    └── [Method] do_attack(self, target)
    └── [Method] do_heal(self, target)
    └── [Method] interact_tile(self, gx, gy, npcs, mode)
    └── [Method] _open_chest_reward(self, gx, gy)
    └── [Method] work_complete(self, px, py, next_tile, reward)
    └── [Method] do_break(self, px, py)
    └── [Method] fail_penalty(self)
    └── [Method] update_bullets(self, npcs)
    └── [Method] draw(self, screen, camera_x, camera_y)

[FILE] main.py
  (No Classes or Functions detected - likely settings/constants only)

[FILE] managers\__init__.py
  (No Classes or Functions detected - likely settings/constants only)

[FILE] managers\resource_manager.py
  [Class] ResourceManager
    └── [Method] get_instance(cls)
    └── [Method] __init__(self)
    └── [Method] _load_system_fonts(self)
    └── [Method] get_font(self, name)
    └── [Method] get_image(self, path, use_alpha)
    └── [Method] clear_cache(self)

[FILE] map_editor.py
  [Class] MapEditor
    └── [Method] __init__(self)
    └── [Method] init_empty_map(self, w, h)
    └── [Method] update_filtered_tiles(self)
    └── [Method] get_selected_tile_id(self)
    └── [Method] grid_to_screen(self, gx, gy)
    └── [Method] screen_to_grid(self, sx, sy)
    └── [Method] get_selection_rect(self)
    └── [Method] apply_fill(self)
    └── [Method] rotate_clipboard(self)
    └── [Method] apply_paste(self, gx, gy)
    └── [Method] clamp_camera(self)
    └── [Method] save_map(self)
    └── [Method] load_map(self)
    └── [Method] handle_events(self)
    └── [Method] draw_button(self, text, rect, is_selected, hover_check)
    └── [Method] draw_menu(self)
    └── [Method] draw_input_size(self)
    └── [Method] draw_editor(self)
    └── [Method] draw_map_view(self)
    └── [Method] draw_grid_lines(self)
    └── [Method] draw_preview(self)
    └── [Method] draw_paste_preview(self, mx, my)
    └── [Method] draw_ui_panel(self)
    └── [Method] draw_minimap(self)
    └── [Method] handle_ui_click(self, mx, my)
    └── [Method] run(self)

[FILE] settings.py
  (No Classes or Functions detected - likely settings/constants only)

[FILE] states\__init__.py
  (No Classes or Functions detected - likely settings/constants only)

[FILE] states\lobby_state.py
  [Class] LobbyState
    └── [Method] __init__(self, game)
    └── [Method] enter(self, params)
    └── [Method] update(self, dt)
    └── [Method] draw(self, screen)
    └── [Method] handle_event(self, event)

[FILE] states\menu_state.py
  [Class] MenuState
    └── [Method] __init__(self, game)
    └── [Method] enter(self, params)
    └── [Method] update(self, dt)
    └── [Method] draw(self, screen)
    └── [Method] handle_event(self, event)

[FILE] states\play_state.py
  [Class] PlayState
    └── [Method] __init__(self, game)
    └── [Method] create_light_surface(self, radius)
    └── [Method] create_smooth_gradient(self, radius)
    └── [Method] enter(self, params)
    └── [Method] find_safe_spawn(self)
    └── [Method] init_game_objects(self)
    └── [Method] update(self, dt)
    └── [Method] _update_spectator_camera(self)
    └── [Method] _advance_phase(self)
    └── [Method] execute_siren(self)
    └── [Method] execute_sabotage(self)
    └── [Method] execute_gunshot(self, shooter, target_pos)
    └── [Method] trigger_sabotage(self)
    └── [Method] trigger_siren(self)
    └── [Method] _handle_npc_action(self, action, n, now)
    └── [Method] _process_sound_effect(self, f)
    └── [Method] _handle_v_action(self)
    └── [Method] _process_voting_results(self)
    └── [Method] draw(self, screen)
    └── [Method] handle_event(self, event)

[FILE] systems\__init__.py
  (No Classes or Functions detected - likely settings/constants only)

[FILE] systems\camera.py
  [Class] Camera
    └── [Method] __init__(self, screen_width, screen_height, map_width, map_height)
    └── [Method] x(self)
    └── [Method] x(self, value)
    └── [Method] y(self)
    └── [Method] y(self, value)
    └── [Method] resize(self, w, h)
    └── [Method] set_zoom(self, zoom)
    └── [Method] set_bounds(self, width_px, height_px)
    └── [Method] _update_viewport_size(self)
    └── [Method] move(self, dx, dy)
    └── [Method] update(self, target_x, target_y)

[FILE] systems\effects.py
  [Class] VisualSound
    └── [Method] __init__(self, x, y, text, color, size_scale, duration, shake, blink)
    └── [Method] render_text_with_outline(self, text, font, inner_color, outline_color, thickness)
    └── [Method] update(self)
    └── [Method] draw(self, screen, camera_x, camera_y)
  [Class] SoundDirectionIndicator
    └── [Method] __init__(self, source_x, source_y, duration)
    └── [Method] _create_glow_surface(self)
    └── [Method] update(self)
    └── [Method] draw(self, screen, player_rect, camera_x, camera_y)

[FILE] systems\fov.py
  [Class] FOV
    └── [Method] __init__(self, map_width, map_height, map_manager)
    └── [Method] cast_rays(self, px, py, radius, direction, angle_width)
    └── [Method] get_poly_points(self, px, py, radius, direction, angle_width)

[FILE] systems\logger.py
  [Class] GameLogger
    └── [Method] get_instance(cls)
    └── [Method] __init__(self)
    └── [Method] _process_logs(self)
    └── [Method] log(self, level, category, message)
    └── [Method] info(self, category, message)
    └── [Method] error(self, category, message)
    └── [Method] debug(self, category, message)
    └── [Method] shutdown(self)

[FILE] systems\minigame.py
  [Class] MiniGameManager
    └── [Method] __init__(self)
    └── [Method] start(self, game_type, difficulty, on_success, on_fail)
    └── [Method] init_specific_game(self)
    └── [Method] update(self)
    └── [Method] handle_event(self, event)
    └── [Method] success_game(self)
    └── [Method] fail_game(self)
    └── [Method] draw(self, screen, x, y)

[FILE] systems\renderer.py
  [Class] CharacterRenderer
    └── [Method] clear_cache(cls)
    └── [Method] _get_cache_key(cls, entity, is_highlighted)
    └── [Method] draw_entity(screen, entity, camera_x, camera_y, viewer_role, current_phase, viewer_device_on)
  [Class] MapRenderer
    └── [Method] __init__(self, map_manager)
    └── [Method] draw(self, screen, camera, dt)

[FILE] ui.py
  [Class] UI
    └── [Method] __init__(self, game)
    └── [Method] _create_panel_bg(self, w, h)
    └── [Method] generate_minimap_surface(self)
    └── [Method] show_alert(self, text, color)
    └── [Method] toggle_vending_machine(self)
    └── [Method] toggle_inventory(self)
    └── [Method] show_daily_news(self, news_log)
    └── [Method] calculate_game_time(self)
    └── [Method] draw_emotion_panel(self, screen, w, h)
    └── [Method] draw_minimap(self, screen, w, h, npcs, is_blackout)
    └── [Method] draw(self, screen)
    └── [Method] draw_top_hud(self, screen, w, h)
    └── [Method] _draw_player_status(self, screen)
    └── [Method] _draw_env_status(self, screen, screen_w)
    └── [Method] _draw_bar(self, screen, x, y, w, h, ratio, color, label)
    └── [Method] draw_controls(self, screen, w, h)
    └── [Method] draw_key_icon(self, screen, x, y, key, label)
    └── [Method] draw_motion_tracker(self, screen, w, h)
    └── [Method] draw_police_hud(self, screen, w, h)
    └── [Method] draw_interaction(self, screen)
    └── [Method] draw_stamina_bar(self, screen)
    └── [Method] draw_vote_ui(self, screen, w, h)
    └── [Method] draw_vote_popup(self, screen, sw, sh, npcs, player, current_target)
    └── [Method] draw_daily_news(self, screen, w, h)
    └── [Method] handle_keyboard(self, key, npcs)
    └── [Method] draw_item_icon(self, screen, key, rect, is_sel)
    └── [Method] draw_vending_machine(self, screen, w, h)
    └── [Method] draw_inventory(self, screen, w, h)
    └── [Method] _draw_spectator_ui(self, screen, w, h)

[FILE] world\__init__.py
  (No Classes or Functions detected - likely settings/constants only)

[FILE] world\map_manager.py
  [Class] MapManager
    └── [Method] __init__(self)
    └── [Method] get_tile(self, gx, gy, layer)
    └── [Method] get_tile_full(self, gx, gy, layer)
    └── [Method] set_tile(self, gx, gy, tid, rotation, layer)
    └── [Method] _update_collision_at(self, x, y)
    └── [Method] build_collision_cache(self)
    └── [Method] get_spawn_points(self, zone_id)
    └── [Method] check_any_collision(self, gx, gy)
    └── [Method] update_doors(self, dt, entities)
    └── [Method] _find_state_tile(self, current_tid, find_str, replace_str)
    └── [Method] open_door(self, gx, gy, layer)
    └── [Method] close_door(self, gx, gy, layer)
    └── [Method] lock_door(self, gx, gy, layer)
    └── [Method] unlock_door(self, gx, gy, layer)
    └── [Method] load_map(self, filename)
    └── [Method] build_tile_cache(self)
    └── [Method] create_default_map(self)
    └── [Method] is_tile_on_cooldown(self, gx, gy)
    └── [Method] set_tile_cooldown(self, gx, gy, duration_ms)

[FILE] world\tiles.py
  [Function] cleanup_disk_cache()
  [Function] clear_memory_cache()
  [Function] get_texture(tid, rotation)
  [Function] get_tile_category(tid)
  [Function] get_tile_type(tid)
  [Function] check_collision(tid)
  [Function] get_tile_interaction(tid)
  [Function] get_tile_hiding(tid)
  [Function] get_tile_name(tid)
  [Function] get_tile_function(tid)
  [Function] fill(s, c)
  [Function] rect(s, c, r, w)
  [Function] line(s, c, p1, p2, w)
  [Function] circle(s, c, p, r, w)
  [Function] pixel(s, c, p)
  [Function] poly(s, c, pts, w)
  [Function] blend(c1, c2, r)
  [Function] noise_color(color, intensity)
  [Function] draw_pro_noise(surf, color, intensity)
  [Function] draw_pixel_bevel(surf, rect_obj, base_col, light_col, dark_col, thickness)
  [Function] draw_wood_base(surf, color, vertical)
  [Function] draw_brick_base(surf, color)
  [Function] draw_grass_detailed(surf, base_col)
  [Function] draw_10001(s)
  [Function] draw_10002(s)
  [Function] draw_10003(s)
  [Function] draw_10004(s)
  [Function] draw_10005(s)
  [Function] draw_10006(s)
  [Function] draw_10007(s)
  [Function] draw_10008(s)
  [Function] draw_10009(s)
  [Function] draw_10010(s)
  [Function] draw_10011(s)
  [Function] draw_10012(s)
  [Function] draw_10013(s)
  [Function] draw_10014(s)
  [Function] draw_10015(s)
  [Function] draw_10016(s)
  [Function] draw_10017(s)
  [Function] draw_10018(s)
  [Function] draw_10019(s)
  [Function] draw_10020(s)
  [Function] draw_11001(s)
  [Function] draw_11002(s)
  [Function] draw_11003(s)
  [Function] draw_21001(s)
  [Function] draw_21002(s)
  [Function] draw_21003(s)
  [Function] draw_21004(s)
  [Function] draw_21005(s)
  [Function] draw_21006(s)
  [Function] draw_21007(s)
  [Function] draw_21008(s)
  [Function] draw_21009(s)
  [Function] draw_21010(s)
  [Function] draw_21011(s)
  [Function] draw_21012(s)
  [Function] draw_21013(s)
  [Function] draw_21014(s)
  [Function] draw_21015(s)
  [Function] draw_21016(s)
  [Function] draw_21017(s)
  [Function] draw_door(s, tid, name, col)
  [Function] draw_chest(s, tid, name)
  [Function] draw_40101(s)
  [Function] draw_40102(s)
  [Function] draw_40103(s)
  [Function] draw_40104(s)
  [Function] draw_40105(s)
  [Function] draw_flower(s, col)
  [Function] draw_40001(s)
  [Function] draw_40002(s)
  [Function] draw_40003(s)
  [Function] draw_40004(s)
  [Function] draw_40005(s)
  [Function] draw_41001(s)
  [Function] draw_41002(s)
  [Function] draw_41003(s)
  [Function] draw_41004(s)
  [Function] draw_41005(s)
  [Function] draw_41006(s)
  [Function] draw_51201(s)
  [Function] draw_51202(s)
  [Function] draw_51203(s)
  [Function] draw_51204(s)
  [Function] draw_51205(s)
  [Function] draw_51206(s)
  [Function] draw_51207(s)
  [Function] draw_51208(s)
  [Function] draw_51001(s)
  [Function] draw_51002(s)
  [Function] draw_51003(s)
  [Function] draw_51004(s)
  [Function] draw_51005(s)
  [Function] draw_51006(s)
  [Function] draw_51007(s)
  [Function] draw_51008(s)
  [Function] draw_51301(s)
  [Function] draw_51302(s)
  [Function] draw_51303(s)
  [Function] draw_51305(s)
  [Function] draw_51309(s)
  [Function] draw_51310(s)
  [Function] draw_51311(s)
  [Function] draw_51312(s)
  [Function] draw_farm(s, tid, name)
  [Function] draw_61001(s)
  [Function] draw_61002(s)
  [Function] draw_61003(s)
  [Function] draw_61004(s)
  [Function] draw_61005(s)
  [Function] draw_60001(s)
  [Function] draw_60002(s)
  [Function] draw_60003(s)
  [Function] create_texture(tid)


================================================================================
(2) DETAILED CODE & EXPLANATION
================================================================================


################################################################################
 FILE: colors.py
################################################################################

--- [Code Analysis & Settings] ---
  [Global Variable] COLORS = {Dict with 71 keys}
  [Global Variable] CUSTOM_COLORS = {Dict with 3 keys}

--- [Full Source Code] ---


COLORS = {

    'BG': (10, 10, 12),
    'GRID': (25, 25, 30),
    'GRID_10': (35, 35, 40),
    'GRID_50': (50, 50, 60),
    'GRID_CENTER': (80, 80, 90),
    'TEXT': (180, 180, 190),
    'MAP_BORDER': (80, 20, 20),
    'BLACK': (5, 5, 8),
    'WHITE': (200, 200, 210),
    'DARKNESS': (0, 0, 0),


    'FOG_DAY': (100, 100, 110, 50),
    'FOG_NIGHT': (5, 5, 8, 245),
    'FOG_DAWN': (20, 20, 40, 230),


    'HP_BAR': (139, 0, 0),
    'AP_BAR': (25, 25, 112),
    'STAMINA_BAR': (184, 134, 11),


    'UI_BG': (15, 15, 20, 230),
    'UI_BORDER': (80, 80, 90),
    'SELECTION': (60, 100, 60),
    'COPY_SELECT': (60, 80, 100),
    'ERROR': (150, 50, 50),

    'BUTTON': (40, 40, 50),
    'BUTTON_HOVER': (60, 60, 70),
    'BUTTON_DISABLED': (20, 20, 25),
    'BUTTON_SELECTED': (50, 80, 50),

    'BULLET': (200, 180, 100),
    'BLOOD': (100, 10, 10),


    'GAUGE_BG': (30, 30, 35),
    'GAUGE_BAR': (180, 160, 60),
    'GAUGE_EXHAUST': (150, 40, 40),
    'GAUGE_TARGET': (150, 40, 40),
    'BREATH_BAR': (50, 80, 120),


    'VOTE_BG': (10, 10, 15, 240),
    'VOTE_BTN': (40, 40, 60),
    'VOTE_BTN_HOVER': (60, 60, 80),
    'VOTE_BTN_SELECTED': (80, 80, 100),

    'MSG_INFO': (100, 150, 100),
    'MSG_WARN': (150, 80, 50),
    'MSG_BIG_DEATH': (180, 20, 20),
    'MSG_BIG_SKILL': (180, 160, 50),
    'MSG_DAWN': (80, 90, 120),
    'CHAT_TEXT': (160, 160, 170),

    'MENU_BG': (10, 10, 12),
    'SLOT_BG': (25, 25, 35),
    'ROLE_BTN': (50, 50, 60),


    'SKIN': (180, 140, 110),
    'CLOTHES': (100, 80, 60),
    'SPECTATOR': (80, 80, 120),
    'PATH_LINE': (100, 100, 100),

    'MM_BG': (10, 10, 15, 230),
    'MM_BORDER': (100, 100, 110),
    'MM_PLAYER': (50, 150, 50),
    'MM_MAFIA_PING': (150, 30, 30),
    'MM_POLICE_PING': (50, 50, 150),


    'ROLE_CITIZEN': (60, 120, 60),
    'ROLE_MAFIA': (140, 30, 30),
    'ROLE_POLICE': (40, 60, 120),
    'ROLE_DOCTOR': (160, 140, 60),
    'ROLE_SPECTATOR': (100, 100, 120),


    'MG_ARROW': (80, 120, 140),
    'MG_CIRCLE': (120, 80, 120),
    'MG_SUCCESS': (60, 120, 60),
    'MG_FAIL': (140, 40, 40),
    'MG_PIN': (160, 140, 60),
    'MG_WIRE_RED': (140, 40, 40),
    'MG_WIRE_BLUE': (40, 60, 120),
    'MG_WIRE_YELLOW': (160, 140, 60),

    'FX_SIREN_RED': (180, 20, 20, 60),
    'FX_SIREN_BLUE': (20, 20, 180, 60),
    'FX_BLOOD_BREATH': (100, 0, 0, 80),
    'FX_SWEAT': (100, 150, 180),
}

CUSTOM_COLORS = {
    'SKIN': [
        (200, 160, 130),
        (160, 120, 90),
        (120, 90, 70),
        (100, 80, 75),
        (180, 150, 120)
    ],
    'CLOTHES': [
        (80, 30, 30),
        (30, 50, 30),
        (30, 40, 60),
        (80, 60, 30),
        (40, 40, 45),
        (100, 90, 80),
        (60, 30, 60),
        (20, 20, 20),
    ],
    'HAT': [
        None,
        (30, 30, 35),
        (100, 30, 30),
        (30, 40, 70),
        (120, 110, 100),
        (70, 50, 30),
    ]
}



################################################################################
 FILE: convert_map.py
################################################################################

--- [Code Analysis & Settings] ---
  [Global Variable] TILE_MAPPING = {Dict with 40 keys}
  [Global Variable] TILE_NAMES = {Dict with 40 keys}

  [Function] convert_tile_value(value, unknown_tiles)
    - Doc: 타일 값을 변환하고 알 수 없는 타일을 추적

  [Function] convert_map_data(data, unknown_tiles, current_key)
    - Doc: 맵 데이터를 재귀적으로 변환

  [Function] get_user_mapping(old_code)
    - Doc: 사용자로부터 새 타일 코드 입력받기

  [Function] main()

--- [Full Source Code] ---
import json
import sys
from pathlib import Path

TILE_MAPPING = {

    101: 10001,
    102: 10003,
    103: 10002,
    104: 11001,
    106: 10008,
    107: 10010,
    108: 10006,
    109: 10004,


    201: 21001,
    202: 21005,
    203: 21014,
    204: 21006,
    205: 21002,
    502: 21011,


    301: 31301,
    302: 31302,
    303: 31303,
    304: 30001,
    305: 30002,
    306: 30003,
    307: 30099,
    901: 30099,


    401: 51201,
    402: 40101,
    403: 51202,
    404: 51203,
    405: 41003,
    406: 41001,
    501: 51204,


    105: 51306,
    115: 50307,
    125: 50308,
    503: 51301,
    513: 51302,
    505: 51303,
    504: 50304,
    506: 51305,
    520: 51309,
    521: 51310,


    601: 61001,
}

TILE_NAMES = {
    101: "흙 바닥", 102: "자갈길", 103: "잔디", 104: "깊은 물",
    106: "나무 마루", 107: "대리석 바닥", 108: "동굴 바닥", 109: "모래사장",
    201: "붉은 벽돌 벽", 202: "통나무 벽", 203: "동굴 암벽", 204: "하얀 회반죽 벽",
    205: "회색 벽돌 벽", 502: "유리 벽",
    301: "나무 문[닫힘]", 302: "철제 문[닫힘]", 303: "유리 문[닫힘]",
    304: "나무 문[열림]", 305: "철제 문[열림]", 306: "유리 문[열림]",
    307: "부서진 문", 901: "부서진 문",
    401: "나무 상자", 402: "높은 수풀", 403: "캐비닛", 404: "책상",
    405: "거대한 바위", 406: "나무 기둥", 501: "침대",
    105: "빈 밭", 115: "새싹 밭", 125: "다 자란 밭",
    503: "광맥", 513: "채광 잔해", 505: "용광로", 504: "낚시 포인트",
    506: "도마", 520: "현미경", 521: "수술대",
    601: "가로등",
}

def convert_tile_value(value, unknown_tiles):
    """타일 값을 변환하고 알 수 없는 타일을 추적"""
    if isinstance(value, int):
        if value in TILE_MAPPING:
            return TILE_MAPPING[value]
        elif value != 0:
            unknown_tiles.add(value)
        return value
    return value

def convert_map_data(data, unknown_tiles, current_key=None):
    """맵 데이터를 재귀적으로 변환"""
    if isinstance(data, dict):
        return {key: convert_map_data(value, unknown_tiles, key) for key, value in data.items()}
    elif isinstance(data, list):

        if current_key == "zones":
            return data
        return [convert_map_data(item, unknown_tiles, current_key) for item in data]
    else:

        if current_key == "zones":
            return data
        return convert_tile_value(data, unknown_tiles)

def get_user_mapping(old_code):
    """사용자로부터 새 타일 코드 입력받기"""
    print(f"\n알 수 없는 타일 코드 발견: {old_code}")
    while True:
        new_code = input(f"새 타일 코드를 입력하세요 (건너뛰려면 Enter): ").strip()
        if new_code == "":
            return None
        try:
            return int(new_code)
        except ValueError:
            print("올바른 숫자를 입력해주세요.")

def main():
    if len(sys.argv) < 2:
        print("사용법: python tile_converter.py <맵파일.json>")
        print("예시: python tile_converter.py map_data.json")
        sys.exit(1)

    input_file = Path(sys.argv[1])

    if not input_file.exists():
        print(f"오류: 파일을 찾을 수 없습니다 - {input_file}")
        sys.exit(1)


    print(f"맵 파일 로딩 중: {input_file}")
    try:
        with open(input_file, 'r', encoding='utf-8') as f:
            map_data = json.load(f)
    except json.JSONDecodeError as e:
        print(f"오류: JSON 파일 파싱 실패 - {e}")
        sys.exit(1)


    unknown_tiles = set()
    print("타일 코드 변환 중...")
    print("(구역 설정 데이터는 변환하지 않습니다)")
    converted_data = convert_map_data(map_data, unknown_tiles)


    if unknown_tiles:
        print(f"\n{'='*60}")
        print(f"총 {len(unknown_tiles)}개의 알 수 없는 타일 코드가 발견되었습니다.")
        print(f"{'='*60}")

        user_mappings = {}
        for old_code in sorted(unknown_tiles):
            new_code = get_user_mapping(old_code)
            if new_code is not None:
                user_mappings[old_code] = new_code


        if user_mappings:
            print("\n사용자 정의 매핑 적용 중...")
            TILE_MAPPING.update(user_mappings)
            unknown_tiles.clear()
            converted_data = convert_map_data(map_data, unknown_tiles)


    output_file = input_file.parent / f"{input_file.stem}_converted{input_file.suffix}"


    print(f"\n변환된 맵 저장 중: {output_file}")
    with open(output_file, 'w', encoding='utf-8') as f:
        json.dump(converted_data, f, ensure_ascii=False, indent=2)

    print(f"\n{'='*60}")
    print(f"✓ 변환 완료!")
    print(f"  원본 파일: {input_file}")
    print(f"  변환 파일: {output_file}")
    if unknown_tiles:
        print(f"\n⚠ 주의: {len(unknown_tiles)}개의 타일이 변환되지 않았습니다:")
        for tile in sorted(unknown_tiles):
            print(f"  - 타일 코드: {tile}")
    print(f"{'='*60}")

if __name__ == "__main__":
    main()


################################################################################
 FILE: core\base_state.py
################################################################################

--- [Code Analysis & Settings] ---

  [Class] BaseState
    [Method] __init__(self, game)
    [Method] enter(self, params)
    [Method] exit(self)
    [Method] update(self, dt)
    [Method] draw(self, screen)
    [Method] handle_event(self, event)

--- [Full Source Code] ---
class BaseState:
    def __init__(self, game):
        self.game = game

    def enter(self, params=None):
        pass

    def exit(self):
        pass

    def update(self, dt):
        pass

    def draw(self, screen):
        pass

    def handle_event(self, event):
        pass



################################################################################
 FILE: core\engine.py
################################################################################

--- [Code Analysis & Settings] ---

  [Class] GameEngine
    [Method] __init__(self)
    [Method] run(self)
    [Method] process_events(self)
    [Method] update(self, dt)
    [Method] draw(self)
    [Method] quit(self)

--- [Full Source Code] ---
import pygame
import sys
from settings import SCREEN_WIDTH, SCREEN_HEIGHT, FPS
from core.state_machine import StateMachine
from systems.logger import GameLogger

class GameEngine:
    def __init__(self):
        pygame.init()
        self.logger = GameLogger.get_instance()
        self.logger.info("SYSTEM", "Game Engine Initializing...")

        self.screen_width = SCREEN_WIDTH
        self.screen_height = SCREEN_HEIGHT
        self.screen = pygame.display.set_mode((self.screen_width, self.screen_height), pygame.RESIZABLE)
        pygame.display.set_caption("PIXEL NIGHT - Refactored")

        self.clock = pygame.time.Clock()
        self.running = True


        self.state_machine = StateMachine(self)


        self.shared_data = {}


        from states.menu_state import MenuState
        self.state_machine.push(MenuState(self))

    def run(self):
        self.logger.info("SYSTEM", "Engine Loop Started")
        while self.running:
            dt = self.clock.tick(FPS) / 1000.0
            self.process_events()
            self.update(dt)
            self.draw()

        self.quit()

    def process_events(self):
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                self.running = False


            if event.type == pygame.VIDEORESIZE:
                self.screen_width, self.screen_height = event.w, event.h
                self.screen = pygame.display.set_mode((self.screen_width, self.screen_height), pygame.RESIZABLE)



            self.state_machine.handle_event(event)

    def update(self, dt):
        self.state_machine.update(dt)

    def draw(self):
        self.state_machine.draw(self.screen)
        pygame.display.flip()

    def quit(self):
        self.logger.info("SYSTEM", "Engine Shutting Down")
        pygame.quit()
        sys.exit()



################################################################################
 FILE: core\state_machine.py
################################################################################

--- [Code Analysis & Settings] ---

  [Class] StateMachine
    [Method] __init__(self, game)
    [Method] push(self, state)
    [Method] pop(self)
    [Method] change(self, state, params)
    [Method] update(self, dt)
    [Method] draw(self, screen)
    [Method] handle_event(self, event)

--- [Full Source Code] ---
class StateMachine:
    def __init__(self, game):
        self.game = game
        self.stack = []

    def push(self, state):
        if self.stack:
            self.stack[-1].exit()
        self.stack.append(state)
        state.enter()

    def pop(self):
        if self.stack:
            state = self.stack.pop()
            state.exit()
            if self.stack:
                self.stack[-1].enter()
            return state
        return None

    def change(self, state, params=None):
        while self.stack:
            self.stack.pop().exit()
        self.stack.append(state)
        state.enter(params)

    def update(self, dt):
        if self.stack:
            self.stack[-1].update(dt)

    def draw(self, screen):
        if self.stack:
            self.stack[-1].draw(screen)

    def handle_event(self, event):
        if self.stack:
            self.stack[-1].handle_event(event)



################################################################################
 FILE: entities\__init__.py
################################################################################

--- [Code Analysis & Settings] ---
  (No specific structural elements found)

--- [Full Source Code] ---

from .entity import Entity




################################################################################
 FILE: entities\entity.py
################################################################################

--- [Code Analysis & Settings] ---

  [Class] Entity
    [Method] __init__(self, x, y, map_data, map_width, map_height, zone_map, name, role, map_manager)
    [Method] add_popup(self, text, color)
      - Doc: 엔티티 머리 위에 1.5초간 지속되는 팝업 메시지 추가
    [Method] is_visible_villain(self, phase)
      - Doc: 현재 페이즈에 이 엔티티가 '빌런의 모습'을 하고 있는지 반환합니다.
마피아는 밤/새벽에 '작업복(빌런 룩)'으로 자동 환복한다고 가정합니다.
    [Method] morning_process(self)
      - Doc: 아침마다 상태 리셋 (하위 클래스에서 호출 필요)
    [Method] is_stunned(self)
    [Method] take_stun(self, duration_ms)
    [Method] take_damage(self, amount)
    [Method] heal(self, amount)
    [Method] try_spend_ap(self, amount, allow_health_cost)
    [Method] use_item(self, item_key)
      - Doc: [Ver 10.0] 공통 아이템 사용 로직
    [Method] move_single_axis(self, dx, dy, npcs)

--- [Full Source Code] ---
import pygame
import random
from settings import TILE_SIZE, ITEMS
from colors import CUSTOM_COLORS
from world.tiles import check_collision, get_tile_function, get_tile_category, BED_TILES, HIDEABLE_TILES

class Entity:
    def __init__(self, x, y, map_data, map_width, map_height, zone_map, name="Entity", role="CITIZEN", map_manager=None):

        # [Optimization] Hitbox reduction: 32x32 -> 20x20 for smoother passage through doors
        self.rect = pygame.Rect(x + 6, y + 6, TILE_SIZE - 12, TILE_SIZE - 12)
        self.pos_x = float(self.rect.x)
        self.pos_y = float(self.rect.y)
        self.color = (255, 255, 255)

        self.map_data = map_data
        self.map_width = map_width
        self.map_height = map_height
        self.zone_map = zone_map
        self.map_manager = map_manager

        self.name = name
        self.role = role
        self.sub_role = None

        # [수정] 기본 스탯 100으로 확장
        self.max_hp = 100
        self.hp = 100
        self.max_ap = 100
        self.ap = 100

        self.coins = 0
        self.alive = True

        # [New] Status Effects & Emotions
        self.status_effects = {
            'ANXIETY': 0,    # 0~10: Anxiety Level (Heartbeat)
            'PAIN': False,   # Low HP
            'FATIGUE': False,# Low AP
            'FEAR': False,   # Encounter Mafia
            'RAGE': False,   # Police/Mafia Buff
            'DOPAMINE': False# Mafia Chase Buff
        }

        self.is_hiding = False
        self.hiding_type = 0
        self.hidden_in_solid = False
        self.inventory = {k: 0 for k in ITEMS.keys()}
        self.inventory['BATTERY'] = 1
        self.emotions = {}

        self.buffs = {
            'INFINITE_STAMINA': False,
            'SILENT': False,
            'FAST_WORK': False,
            'NO_PAIN': False
        }

        self.is_moving = False
        self.custom = {
            'skin': random.randint(0, len(CUSTOM_COLORS['SKIN'])-1),
            'clothes': random.randint(0, len(CUSTOM_COLORS['CLOTHES'])-1),
            'hat': random.randint(0, len(CUSTOM_COLORS['HAT'])-1)
        }
        self.facing_right = True
        self.facing_dir = (0, 1)
        self.stun_timer = 0
        self.device_on = False
        self.device_battery = 100.0
        self.powerbank_uses = 0


        self.popups = []

    def add_popup(self, text, color=(255, 255, 255)):
        """엔티티 머리 위에 1.5초간 지속되는 팝업 메시지 추가"""
        self.popups.append({
            'text': text,
            'color': color,
            'timer': pygame.time.get_ticks() + 1500
        })

    # [추가] 경찰이 확인하는 공개 외형 정보
    def is_visible_villain(self, phase):
        """
        현재 페이즈에 이 엔티티가 '빌런의 모습'을 하고 있는지 반환합니다.
        마피아는 밤/새벽에 '작업복(빌런 룩)'으로 자동 환복한다고 가정합니다.
        """
        if self.role == "MAFIA" and phase in ['NIGHT', 'DAWN']:
            return True
        return False

    def morning_process(self):
        """아침마다 상태 리셋 (하위 클래스에서 호출 필요)"""

        for k in self.buffs: self.buffs[k] = False
        self.hp = min(self.max_hp, self.hp + 1)

    def is_stunned(self):
        return pygame.time.get_ticks() < self.stun_timer

    def take_stun(self, duration_ms=2000):
        self.stun_timer = pygame.time.get_ticks() + duration_ms
        self.is_moving = False
        if hasattr(self, 'path'): self.path = []

    def take_damage(self, amount):
        if not self.alive: return "ALREADY_DEAD"
        if self.role == "POLICE": return "IMMUNE"


        if self.inventory.get('ARMOR', 0) > 0:
            self.inventory['ARMOR'] -= 1
            return "BLOCKED"

        if self.inventory.get('POTION', 0) > 0 and self.hp - amount <= 0:
            self.inventory['POTION'] -= 1
            self.hp = 5
            self.alive = False
            return "DIED_BUT_REVIVABLE"

        self.hp -= amount
        if self.hp <= 0:
            self.hp = 0
            self.alive = False
            return "DIED"
        return "HIT"

    def heal(self, amount):
        if self.alive and self.hp < self.max_hp:
            self.hp = min(self.max_hp, self.hp + amount)
            return True
        return False

    def try_spend_ap(self, amount, allow_health_cost=True):
        if self.ap >= amount:
            self.ap -= amount
            return True
        else:
            if self.role == "POLICE": self.ap = 0; return True
            if not allow_health_cost: return False
            
            if self.buffs['NO_PAIN']: hp_cost = 0
            else: hp_cost = amount * 2

            if hp_cost > 0: self.take_damage(hp_cost)
            return True

    def use_item(self, item_key):
        """[Ver 10.0] 공통 아이템 사용 로직"""
        if not self.alive: return False
        if self.inventory.get(item_key, 0) <= 0: return False

        used = False
        s_type = "CRUNCH"

        if item_key == 'TANGERINE':
            if self.hp < self.max_hp: self.hp = min(self.max_hp, self.hp + 2); used = True
        elif item_key == 'CHOCOBAR':
            if self.ap < self.max_ap: self.ap = min(self.max_ap, self.ap + 2); used = True
        elif item_key == 'TORTILLA':
            if self.hp < self.max_hp or self.ap < self.max_ap:
                self.hp = min(self.max_hp, self.hp + 3)
                self.ap = min(self.max_ap, self.ap + 3)
                used = True
        elif item_key == 'MEDKIT':
            if self.hp < self.max_hp: self.hp = self.max_hp; used = True
            s_type = "CLICK"

        elif item_key == 'ENERGY_DRINK':
            if not self.buffs['INFINITE_STAMINA']:
                self.hp = max(1, self.hp - 3)
                self.buffs['INFINITE_STAMINA'] = True
                used = True; s_type = "GULP"
        elif item_key == 'PEANUT_BUTTER':
            if not self.buffs['SILENT']: self.buffs['SILENT'] = True; used = True
        elif item_key == 'COFFEE':
            if not self.buffs['FAST_WORK']: self.buffs['FAST_WORK'] = True; used = True; s_type = "GULP"
        elif item_key == 'PAINKILLER':
            if not self.buffs['NO_PAIN']: self.buffs['NO_PAIN'] = True; used = True; s_type = "GULP"

        elif item_key == 'BATTERY':
            if self.device_battery < 100: self.device_battery = min(100, self.device_battery + 50); used = True; s_type = "CLICK"
        elif item_key == 'POWERBANK':
            if self.device_battery < 100:
                self.device_battery = 100
                self.powerbank_uses += 1
                if self.powerbank_uses >= 2:
                    self.powerbank_uses = 0
                    used = True
                else:
                    self.add_popup("Used once (1 left)", (100, 255, 100))
                    return ("Used once (1 left)", ("CLICK", self.rect.centerx, self.rect.centery, 3 * TILE_SIZE, self.role))
                s_type = "CLICK"

        if used:
            self.inventory[item_key] -= 1
            return ("Used " + ITEMS[item_key]['name'], (s_type, self.rect.centerx, self.rect.centery, 4 * TILE_SIZE, self.role))
        return False

    def move_single_axis(self, dx, dy, npcs=None):
        if dx > 0: self.facing_right = True; self.facing_dir = (1, 0)
        elif dx < 0: self.facing_right = False; self.facing_dir = (-1, 0)
        if dy > 0: self.facing_dir = (0, 1)
        elif dy < 0: self.facing_dir = (0, -1)

        self.pos_x += dx; self.pos_y += dy
        self.rect.x, self.rect.y = round(self.pos_x), round(self.pos_y)

        if self.hidden_in_solid: return

        # 충돌 검사 범위 계산
        start_gx = max(0, self.rect.left // TILE_SIZE)
        end_gx = min(self.map_width, (self.rect.right // TILE_SIZE) + 1)
        start_gy = max(0, self.rect.top // TILE_SIZE)
        end_gy = min(self.map_height, (self.rect.bottom // TILE_SIZE) + 1)

        # [최적화] 캐시 조회용 변수 미리 할당
        collision_cache = getattr(self.map_manager, 'collision_cache', None)

        for y in range(start_gy, end_gy):
            for x in range(start_gx, end_gx):
                is_blocking = False
                
                # [핵심 최적화] 복잡한 타일 조회 대신 캐시된 불리언 값(True/False)만 확인
                if collision_cache:
                    if collision_cache[y][x]:
                        is_blocking = True
                else:
                    # 백업 로직
                    tids_to_check = []
                    if self.map_manager:
                        for layer in ['wall', 'object']:
                            val = self.map_manager.get_tile_full(x, y, layer)
                            if val[0] != 0: tids_to_check.append(val[0])
                    else: tids_to_check.append(self.map_data[y][x])

                    for tid in tids_to_check:
                        if check_collision(tid):
                            if tid not in BED_TILES and tid not in HIDEABLE_TILES and tid != 5310005:
                                is_blocking = True; break

                if is_blocking:
                    # [최적화] Rect 객체 생성 없이 좌표 비교로 충돌 해결
                    tile_left = x * TILE_SIZE
                    tile_top = y * TILE_SIZE
                    tile_right = tile_left + TILE_SIZE
                    tile_bottom = tile_top + TILE_SIZE
                    
                    if (self.rect.right > tile_left and self.rect.left < tile_right and
                        self.rect.bottom > tile_top and self.rect.top < tile_bottom):
                        
                        if dx > 0: self.rect.right = tile_left
                        elif dx < 0: self.rect.left = tile_right
                        if dy > 0: self.rect.bottom = tile_top
                        elif dy < 0: self.rect.top = tile_bottom
                        
                        self.pos_x, self.pos_y = float(self.rect.x), float(self.rect.y)

        map_w_px, map_h_px = self.map_width * TILE_SIZE, self.map_height * TILE_SIZE
        if self.rect.left < 0: self.rect.left = 0
        elif self.rect.right > map_w_px: self.rect.right = map_w_px
        if self.rect.top < 0: self.rect.top = 0
        elif self.rect.bottom > map_h_px: self.rect.bottom = map_h_px
        self.pos_x, self.pos_y = self.rect.x, self.rect.y



################################################################################
 FILE: entities\npc.py
################################################################################

--- [Code Analysis & Settings] ---
  [Global Variable] FONT_POPUP = None

  [Class] BTState

  [Class] BTNode
    [Method] tick(self, entity, blackboard)

  [Class] Composite
    [Method] __init__(self, children)

  [Class] Selector
    [Method] tick(self, entity, blackboard)

  [Class] Sequence
    [Method] tick(self, entity, blackboard)

  [Class] Action
    [Method] __init__(self, action_func)
    [Method] tick(self, entity, blackboard)

  [Class] Condition
    [Method] __init__(self, condition_func)
    [Method] tick(self, entity, blackboard)

  [Class] Dummy
    [Method] __init__(self, x, y, map_data, map_width, map_height, name, role, tile_cache, zone_map, map_manager)
    [Method] add_popup(self, text, color)
    [Method] add_suspicion(self, target_name, amount)
    [Method] morning_process(self)
    [Method] _build_behavior_tree(self)
    [Method] police_scan_targets(self, entity, bb)
    [Method] mafia_scan_targets(self, entity, bb)
    [Method] has_last_seen_pos(self, entity, bb)
    [Method] has_investigate_pos(self, entity, bb)
    [Method] check_danger(self, entity, bb)
    [Method] check_needs_shopping(self, entity, bb)
    [Method] is_work_time(self, entity, bb)
    [Method] is_night_time(self, entity, bb)
    [Method] can_sabotage(self, entity, bb)
    [Method] police_chase_attack(self, entity, bb)
    [Method] police_investigate_last_pos(self, entity, bb)
    [Method] police_investigate_noise(self, entity, bb)
    [Method] do_patrol(self, entity, bb)
    [Method] do_flee_or_hide(self, entity, bb)
    [Method] do_shopping(self, entity, bb)
    [Method] do_work(self, entity, bb)
    [Method] do_work_fake(self, entity, bb)
    [Method] do_go_home(self, entity, bb)
    [Method] mafia_kill(self, entity, bb)
    [Method] mafia_sabotage(self, entity, bb)
    [Method] do_wander(self, entity, bb)
    [Method] _validate_environment(self)
    [Method] update(self, phase, player, npcs, is_mafia_frozen, noise_list, day_count, bloody_footsteps, siren_timer)
    [Method] set_destination(self, tx, ty, reason)
    [Method] _threaded_calculate_path(self, start_gx, start_gy, target_gx, target_gy, reason)
    [Method] process_movement(self, phase, npcs, slow_down)
    [Method] random_move(self)
    [Method] find_tile(self, target_ids, sort_by_distance, npcs)
    [Method] get_valid_neighbor(self, tx, ty)
    [Method] has_line_of_sight(self, target)
    [Method] check_stat_changes(self)
    [Method] find_house_door(self, npcs)
    [Method] find_hiding_spot(self, npcs)
    [Method] draw(self, screen, camera_x, camera_y, viewer_role, viewer_device_on)

--- [Full Source Code] ---
import pygame
import random
import math
import heapq
import threading
from enum import Enum, auto
from settings import *
from world.tiles import check_collision, get_tile_function, BED_TILES, HIDEABLE_TILES, get_tile_interaction, get_tile_category, get_tile_name
from systems.logger import GameLogger
from colors import *
from .entity import Entity
from systems.renderer import CharacterRenderer

FONT_POPUP = None

class BTState(Enum):
    SUCCESS = auto()
    FAILURE = auto()
    RUNNING = auto()

class BTNode:
    def tick(self, entity, blackboard): return BTState.FAILURE

class Composite(BTNode):
    def __init__(self, children=None): self.children = children or []

class Selector(Composite):
    def tick(self, entity, blackboard):
        for child in self.children:
            status = child.tick(entity, blackboard)
            if status != BTState.FAILURE: return status
        return BTState.FAILURE

class Sequence(Composite):
    def tick(self, entity, blackboard):
        for child in self.children:
            status = child.tick(entity, blackboard)
            if status == BTState.FAILURE: return BTState.FAILURE
            if status == BTState.RUNNING: return BTState.RUNNING
        return BTState.SUCCESS

class Action(BTNode):
    def __init__(self, action_func): self.action_func = action_func
    def tick(self, entity, blackboard): return self.action_func(entity, blackboard)

class Condition(BTNode):
    def __init__(self, condition_func): self.condition_func = condition_func
    def tick(self, entity, blackboard): return BTState.SUCCESS if self.condition_func(entity, blackboard) else BTState.FAILURE

class Dummy(Entity):
    def __init__(self, x, y, map_data, map_width, map_height, name="Dummy", role="CITIZEN", tile_cache=None, zone_map=None, map_manager=None):
        super().__init__(x, y, map_data, map_width=map_width, map_height=map_height, zone_map=zone_map, name=name, role=role, map_manager=map_manager)

        self.tile_cache = tile_cache if tile_cache else {}
        self.logger = GameLogger.get_instance()

        global FONT_POPUP
        if FONT_POPUP is None:
            try: FONT_POPUP = pygame.font.SysFont("arial", 14, bold=True)
            except: FONT_POPUP = pygame.font.Font(None, 20)

        self.coins = 0
        self.sub_role = random.choice(["FARMER", "MINER", "FISHER"]) if role in ["CITIZEN", "MAFIA"] else None

        self.morph_active = False; self.vote_count = 0
        self.move_state = "WALK"; self.speed = SPEED_WALK; self.is_moving = False

        self.path = []
        self.current_path_target = None
        self.last_pos = (self.pos_x, self.pos_y)
        self.stuck_timer = pygame.time.get_ticks() + 2000
        self.failed_targets = {}

        self.is_pathfinding = False
        self.pending_path = None
        self.path_cooldown = 0

        self.action_cooldown = 0
        self.ability_used = False
        self.last_attack_time = 0

        self.is_working = False
        self.work_finish_timer = 0
        self.is_unlocking = False
        self.unlock_finish_timer = 0

        self.daily_work_count = 0
        self.work_tile_pos = None
        self.target_house_pos = None

        self.footstep_timer = 0
        self.popups = []
        self.last_stats = {'hp': self.hp, 'coins': self.coins}

        self.suspicion_meter = {}
        self.chase_target = None
        self.last_seen_pos = None
        self.investigate_pos = None

        self.device_on = False
        self.device_battery = 100.0

        self.tree = self._build_behavior_tree()

    def add_popup(self, text, color=(255, 255, 255)):
        self.popups.append({'text': text, 'color': color, 'timer': pygame.time.get_ticks() + 1500})

    def add_suspicion(self, target_name, amount):
        self.suspicion_meter[target_name] = self.suspicion_meter.get(target_name, 0) + amount

    def morning_process(self):
        if not self.alive: return
        self.morph_active = False
        gx, gy = int(self.rect.centerx // TILE_SIZE), int(self.rect.centery // TILE_SIZE)
        is_indoors = self.zone_map[gy][gx] in INDOOR_ZONES if 0 <= gy < self.map_height and 0 <= gx < self.map_width else False
        if self.is_hiding and is_indoors:
            self.hp, self.ap = self.max_hp, self.max_ap
            self.add_popup("Rested", (100, 255, 255))

        if self.role == "DOCTOR" and random.random() < 0.33: self.inventory['POTION'] += 1
        self.daily_work_count = 0; self.ability_used = False; self.is_hiding = False; self.hiding_type = 0; self.target_house_pos = None
        self.is_working = False; self.work_finish_timer = 0; self.is_unlocking = False
        self.path, self.current_path_target, self.work_tile_pos = [], None, None
        self.failed_targets = {}; self.investigate_pos, self.chase_target = None, None
        self.suspicion_meter = {k: max(0, v - 30) for k, v in self.suspicion_meter.items()}
        self.device_battery = min(100, self.device_battery + 20)


    def _build_behavior_tree(self):
        survival_seq = Sequence([Condition(self.check_danger), Action(self.do_flee_or_hide)])
        shopping_seq = Sequence([Condition(self.check_needs_shopping), Action(self.do_shopping)])

        if self.role == "POLICE":
            return Selector([
                shopping_seq,
                Sequence([Condition(self.police_scan_targets), Action(self.police_chase_attack)]),
                Sequence([Condition(self.has_last_seen_pos), Action(self.police_investigate_last_pos)]),
                Sequence([Condition(self.has_investigate_pos), Action(self.police_investigate_noise)]),
                Action(self.do_patrol)
            ])
        elif self.role == "MAFIA":
            return Selector([
                Sequence([Condition(self.mafia_scan_targets), Action(self.mafia_kill)]),
                Sequence([Condition(self.can_sabotage), Action(self.mafia_sabotage)]),
                shopping_seq,
                Action(self.do_work_fake)
            ])
        else:
            return Selector([
                survival_seq,
                shopping_seq,
                Sequence([Condition(self.is_work_time), Action(self.do_work)]),
                Sequence([Condition(self.is_night_time), Action(self.do_go_home)]),
                Action(self.do_wander)
            ])


    def police_scan_targets(self, entity, bb):
        # [수정] 낮 시간 추격 금지
        current_phase = bb.get('phase')
        if current_phase not in ['NIGHT', 'DAWN']:
            self.chase_target = None
            return False

        if self.chase_target and self.chase_target.alive and not self.chase_target.is_hiding:
            if self.has_line_of_sight(self.chase_target): return True
        
        # [핵심 수정] "마피아인가?"(신상조회) -> "빌런의 모습인가?"(외형관찰) 로 변경
        for t in bb.get('targets', []):
            if t != self and t.alive:
                is_villain_look = t.is_visible_villain(current_phase)
                
                if (is_villain_look and self.has_line_of_sight(t)) or (self.suspicion_meter.get(t.name, 0) >= 100):
                    if self.has_line_of_sight(t) and not t.is_hiding:
                        self.chase_target = t; self.last_seen_pos = (t.rect.centerx, t.rect.centery)
                        return True
        return False

    def mafia_scan_targets(self, entity, bb):
        if bb.get('phase') != 'NIGHT': return False
        if self.chase_target and self.chase_target.alive and self.has_line_of_sight(self.chase_target): return True
        visible_victims = []
        for t in bb.get('targets', []):
            if t != self and t.alive and t.role not in ["MAFIA", "SPECTATOR"]:
                if self.has_line_of_sight(t) and not t.is_hiding:
                    dist = math.sqrt((self.rect.centerx - t.rect.centerx)**2 + (self.rect.centery - t.rect.centery)**2)
                    visible_victims.append((dist, t))
        if visible_victims:
            visible_victims.sort(key=lambda x: x[0]); self.chase_target = visible_victims[0][1]
            return True
        return False

    def has_last_seen_pos(self, entity, bb): return self.last_seen_pos is not None
    def has_investigate_pos(self, entity, bb):
        if self.investigate_pos: return True
        noise = bb.get('noise_list', [])
        if noise:
            noise.sort(key=lambda n: (self.rect.centerx-n[0])**2 + (self.rect.centery-n[1])**2)
            self.investigate_pos = (noise[0][0], noise[0][1]); return True
        return False

    def check_danger(self, entity, bb):
        if self.role in ["CITIZEN", "DOCTOR"] and bb.get('phase') == 'NIGHT':
            for n in bb.get('npcs', []):
                if n != self and n.alive and self.has_line_of_sight(n):
                    dist = math.sqrt((self.rect.centerx-n.rect.centerx)**2+(self.rect.centery-n.rect.centery)**2)
                    if dist < TILE_SIZE * 2: return True
        return False

    def check_needs_shopping(self, entity, bb):
        return (self.hp < 5 or self.ap < 4) and self.coins >= 3 and not self.is_hiding

    def is_work_time(self, entity, bb): return bb.get('phase') in ['MORNING', 'DAY'] and self.daily_work_count < DAILY_QUOTA
    def is_night_time(self, entity, bb): return bb.get('phase') in ['EVENING', 'NIGHT']
    def can_sabotage(self, entity, bb): return self.role == "MAFIA" and bb.get('phase') == 'NIGHT' and not self.ability_used and self.ap >= 5


    def police_chase_attack(self, entity, bb):
        if not self.chase_target: return BTState.FAILURE
        dist = math.sqrt((self.rect.centerx - self.chase_target.rect.centerx)**2 + (self.rect.centery - self.chase_target.rect.centery)**2)
        if dist > 200 and not self.ability_used and self.ap >= 5:
            self.ability_used = True; self.ap -= 5; return "USE_SIREN"
        now = pygame.time.get_ticks()
        if dist < 400 and now > self.last_attack_time + 1000:
            if self.try_spend_ap(1): self.last_attack_time = now; return "SHOOT_TARGET"
        self.set_destination(self.chase_target.rect.centerx, self.chase_target.rect.centery, "Chasing")
        return BTState.RUNNING

    def police_investigate_last_pos(self, entity, bb):
        if not self.last_seen_pos: return BTState.FAILURE
        dist = math.sqrt((self.rect.centerx - self.last_seen_pos[0])**2 + (self.rect.centery - self.last_seen_pos[1])**2)
        if dist < TILE_SIZE: self.last_seen_pos = None; self.chase_target = None; return BTState.SUCCESS
        self.set_destination(self.last_seen_pos[0], self.last_seen_pos[1], "Investigating")
        return BTState.RUNNING

    def police_investigate_noise(self, entity, bb):
        if not self.investigate_pos: return BTState.FAILURE
        dist = math.sqrt((self.rect.centerx - self.investigate_pos[0])**2 + (self.rect.centery - self.investigate_pos[1])**2)
        if dist < TILE_SIZE: self.investigate_pos = None; return BTState.SUCCESS
        self.set_destination(self.investigate_pos[0], self.investigate_pos[1], "Checking Noise")
        return BTState.RUNNING

    def do_patrol(self, entity, bb):
        if not self.path and not self.is_pathfinding: self.random_move()
        return BTState.RUNNING

    def do_flee_or_hide(self, entity, bb):
        if not self.path:
            if not self.find_hiding_spot(bb.get('npcs', [])): self.random_move()
        return BTState.RUNNING

    def do_shopping(self, entity, bb):
        if not self.path:
            vending_pos = self.find_tile([VENDING_MACHINE_TID], npcs=bb.get('npcs', []))
            if vending_pos:
                dist = math.sqrt((self.rect.centerx - vending_pos[0])**2 + (self.rect.centery - vending_pos[1])**2)
                if dist < TILE_SIZE * 1.5:
                    if self.hp < 5: self.coins -= 3; self.hp += 2
                    return BTState.SUCCESS
                self.set_destination(vending_pos[0], vending_pos[1], "Shopping")
        return BTState.RUNNING

    def do_work(self, entity, bb):
        now = pygame.time.get_ticks()
        if self.is_working:
            if now >= self.work_finish_timer:
                self.ap -= 1; self.coins += 1; self.daily_work_count += 1
                self.is_working = False; self.work_tile_pos = None; return BTState.SUCCESS
            return BTState.RUNNING
        if not self.work_tile_pos:
            job_key = "DOCTOR" if self.role == "DOCTOR" else self.sub_role
            target_tid = WORK_SEQ[job_key][(bb.get('day_count', 1) - 1) % 3]
            candidates = self.map_manager.tile_cache.get(target_tid, []) if self.map_manager else []
            if candidates:
                raw_px, raw_py = random.choice(candidates); valid_pos = self.get_valid_neighbor(raw_px // TILE_SIZE, raw_py // TILE_SIZE)
                if valid_pos: self.work_tile_pos = valid_pos; self.set_destination(valid_pos[0], valid_pos[1], "Work Start")
                else: return BTState.FAILURE
            else: return BTState.FAILURE
        dist = math.sqrt((self.rect.centerx - self.work_tile_pos[0])**2 + (self.rect.centery - self.work_tile_pos[1])**2)
        if dist < TILE_SIZE * 0.8:
            if self.ap > 0:
                self.is_working = True; self.work_finish_timer = now + 3000; self.path = []; self.is_moving = False; self.add_popup("Working...")
            else: self.work_tile_pos = None
        elif not self.path and not self.is_pathfinding: self.work_tile_pos = None; return BTState.FAILURE
        return BTState.RUNNING

    def do_work_fake(self, entity, bb):
        if not self.path and not self.is_pathfinding: self.random_move()
        return BTState.RUNNING

    def do_go_home(self, entity, bb):
        if self.is_hiding: return BTState.SUCCESS
        if not self.target_house_pos: self.target_house_pos = self.find_house_door(bb.get('npcs', []))
        if self.target_house_pos:
            dist = math.sqrt((self.rect.centerx - self.target_house_pos[0])**2 + (self.rect.centery - self.target_house_pos[1])**2)
            if dist < TILE_SIZE:
                self.is_hiding = True; self.hiding_type = 2; self.is_moving = False; self.path = []; return BTState.SUCCESS
            self.set_destination(self.target_house_pos[0], self.target_house_pos[1], "Go Home")
        return BTState.RUNNING

    def mafia_kill(self, entity, bb):
        if self.ap >= 1 and self.chase_target:
            dist = math.sqrt((self.rect.centerx - self.chase_target.rect.centerx)**2 + (self.rect.centery - self.chase_target.rect.centery)**2)
            if dist < TILE_SIZE * 1.5:
                self.ap -= 1; self.chase_target.take_damage(10); self.action_cooldown = pygame.time.get_ticks() + 1000
                return "MURDER_OCCURRED"
            self.set_destination(self.chase_target.rect.centerx, self.chase_target.rect.centery, "Killing")
        return BTState.RUNNING

    def mafia_sabotage(self, entity, bb):
        self.ability_used = True; self.ap -= 5; return "USE_SABOTAGE"

    def do_wander(self, entity, bb):
        if not self.path and not self.is_pathfinding: self.random_move()
        return BTState.RUNNING


    def _validate_environment(self):
        gx = int(self.rect.centerx // TILE_SIZE); gy = int(self.rect.centery // TILE_SIZE)
        if not (0 <= gx < self.map_width and 0 <= gy < self.map_height): return
        tid_obj = self.map_manager.get_tile(gx, gy, 'object') if self.map_manager else 0
        tid_floor = self.map_manager.get_tile(gx, gy, 'floor') if self.map_manager else 0
        zone_id = self.zone_map[gy][gx]; is_hiding_tile = (tid_obj in HIDEABLE_TILES) or (tid_floor in HIDEABLE_TILES)
        is_resting_tile = (tid_obj in BED_TILES); is_indoors = (zone_id in INDOOR_ZONES)
        if self.is_moving:
            if self.is_hiding: self.is_hiding = False; self.hiding_type = 0
            return
        if is_hiding_tile and not self.is_hiding: self.is_hiding = True; self.hiding_type = 1
        if self.is_hiding:
            if self.hiding_type == 1 and not is_hiding_tile: self.is_hiding = False; self.hiding_type = 0
            elif self.hiding_type == 2 and not (is_indoors or is_resting_tile): self.is_hiding = False; self.hiding_type = 0

    def update(self, phase, player, npcs, is_mafia_frozen, noise_list, day_count, bloody_footsteps, siren_timer=0):
        if not self.alive: return None
        self._validate_environment()
        now = pygame.time.get_ticks(); self.check_stat_changes()
        if self.role == "MAFIA" and is_mafia_frozen:
            self.is_moving = False
            return None
        if self.is_unlocking:
            if now >= self.unlock_finish_timer:
                self.is_unlocking = False
                if self.path:
                    nx, ny = self.path[0]
                    if self.map_manager: self.map_manager.unlock_door(nx, ny); self.add_popup("Unlocked!")
                return None
            return BTState.RUNNING
        if self.pending_path is not None:
            if not self.is_hiding: self.path = self.pending_path
            self.pending_path = None; self.is_pathfinding = False
        blackboard = {'phase': phase, 'player': player, 'npcs': npcs, 'targets': npcs + [player], 'noise_list': noise_list, 'bloody_footsteps': bloody_footsteps, 'day_count': day_count, 'is_mafia_frozen': is_mafia_frozen}
        result = self.tree.tick(self, blackboard)
        if isinstance(result, str): return result
        return self.process_movement(phase, npcs, slow_down=is_mafia_frozen if self.role == "MAFIA" else False)

    def set_destination(self, tx, ty, reason="Unknown"):
        if self.is_hiding: self.is_hiding = False; self.hiding_type = 0
        tgx, tgy = int(tx // TILE_SIZE), int(ty // TILE_SIZE)
        if self.path and self.current_path_target == (tgx, tgy): return True
        if self.is_pathfinding: return False
        
        # [수정] 현재 경로가 없고 멈춰있는 상태라면 쿨타임 무시 (즉시 반응)
        now = pygame.time.get_ticks()
        if self.path or self.is_moving:
            if now < self.path_cooldown: return False
            
        self.path_cooldown = now + 500
        self.is_pathfinding = True
        
        # [수정] 스레드 안전성 확보: 현재 위치를 미리 계산하여 전달
        start_gx = int(self.rect.centerx // TILE_SIZE)
        start_gy = int(self.rect.centery // TILE_SIZE)
        
        thread = threading.Thread(target=self._threaded_calculate_path, args=(start_gx, start_gy, tgx, tgy, reason))
        thread.daemon = True; thread.start(); return True

    def _threaded_calculate_path(self, start_gx, start_gy, target_gx, target_gy, reason):
        try:
            # start_gx, start_gy는 인자로 받음 (self.rect 접근 제거)
            if (start_gx, start_gy) == (target_gx, target_gy): self.pending_path = []; return
            open_set = []; heapq.heappush(open_set, (0, start_gx, start_gy)); came_from = {}; g_score = {(start_gx, start_gy): 0}
            while open_set and len(came_from) < 5000:
                _, cx, cy = heapq.heappop(open_set)
                if (cx, cy) == (target_gx, target_gy): break
                for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                    nx, ny = cx + dx, cy + dy
                    if 0 <= nx < self.map_width and 0 <= ny < self.map_height:
                        tid_obj = self.map_manager.get_tile(nx, ny, 'object') if self.map_manager else 0
                        tid_wall = self.map_manager.get_tile(nx, ny, 'wall') if self.map_manager else self.map_data[ny][nx]
                        blocked = check_collision(tid_wall) or (tid_obj != 0 and check_collision(tid_obj))
                        if get_tile_category(tid_obj) == 5: blocked = False
                        if (nx, ny) == (target_gx, target_gy): blocked = False
                        if not blocked:
                            new_g = g_score[(cx, cy)] + 1
                            if (nx, ny) not in g_score or new_g < g_score[(nx, ny)]:
                                g_score[(nx, ny)] = new_g; priority = new_g + abs(target_gx - nx) + abs(target_gy - ny)
                                heapq.heappush(open_set, (priority, nx, ny)); came_from[(nx, ny)] = (cx, cy)
            if (target_gx, target_gy) in came_from:
                path = []; curr = (target_gx, target_gy)
                while curr in came_from: path.append(curr); curr = came_from[curr]
                self.pending_path = path[::-1]; self.current_path_target = (target_gx, target_gy)
            else: self.pending_path = None; self.is_pathfinding = False
        except: self.is_pathfinding = False

    def process_movement(self, phase, npcs=None, slow_down=False):
        if self.is_hiding: return None
        if slow_down:
            self.is_moving = False
            return None
        
        # [New] Update Emotion State (AI)
        if self.role == "MAFIA" and self.chase_target:
            self.status_effects['DOPAMINE'] = True
        else:
            self.status_effects['DOPAMINE'] = False

        now = pygame.time.get_ticks(); self.move_state, self.speed = "WALK", SPEED_WALK
        if self.chase_target: 
            self.move_state, self.speed = "RUN", SPEED_RUN
            # [New] Dopamine Effect: Faster Chase
            if self.status_effects.get('DOPAMINE'):
                self.speed *= 1.2

        if not self.path: self.is_moving = False; return None
        ngx, ngy = self.path[0]; tid = self.map_manager.get_tile(ngx, ngy, 'object') if self.map_manager else 0
        cat = get_tile_category(tid); d_val = get_tile_interaction(tid)
        if cat == 5:
            dist = math.sqrt((self.rect.centerx - (ngx*TILE_SIZE+16))**2 + (self.rect.centery - (ngy*TILE_SIZE+16))**2)
            if dist < TILE_SIZE * 1.2:
                # [New] Mafia Rage: Destroy Doors at Night
                if self.role == "MAFIA" and phase == "NIGHT":
                    if self.map_manager:
                        self.map_manager.set_tile(ngx, ngy, 0, layer='object')
                        # self.logger.info("MAFIA", "Smashed a door!")
                    return None

                if d_val == 1: self.map_manager.open_door(ngx, ngy); return None
                elif d_val == 3:
                    if self.inventory.get('KEY', 0) > 0: self.inventory['KEY'] -= 1; self.map_manager.unlock_door(ngx, ngy); return None
                    elif self.role == "MAFIA": self.map_manager.set_tile(ngx, ngy, 5310005); return "MURDER_OCCURRED"
                    elif not self.is_unlocking: self.is_unlocking = True; self.unlock_finish_timer = now + 5000; self.add_popup("Lockpicking..."); return None
                    return None
        target_px, target_py = ngx * TILE_SIZE + 16, ngy * TILE_SIZE + 16
        dx, dy = target_px - self.rect.centerx, target_py - self.rect.centery; dist = math.sqrt(dx**2 + dy**2)
        if dist < 5:
            self.path.pop(0);
            if not self.path: self.is_moving = False
        else:
            self.is_moving = True; mx, my = (dx/dist)*self.speed, (dy/dist)*self.speed
            self.move_single_axis(mx, 0, npcs); self.move_single_axis(0, my, npcs)
        return True


    def random_move(self):
        # [수정] 무작위 좌표 대신 '갈 수 있는 바닥' 중에서 랜덤 선택
        target_pos = None
        
        if self.map_manager:
            # 1. 캐시된 바닥 타일 중 하나를 랜덤 선택 (카테고리 1: 외부바닥, 2: 내부바닥)
            valid_keys = [k for k in self.map_manager.tile_cache.keys() if get_tile_category(k) in [1, 2]]
            if valid_keys:
                rand_tid = random.choice(valid_keys)
                if self.map_manager.tile_cache[rand_tid]:
                    rx, ry = random.choice(self.map_manager.tile_cache[rand_tid])
                    target_pos = (rx + 16, ry + 16)

        # 2. 캐시가 없거나 실패하면 기존 방식대로 하되, 충돌 체크 반복
        if not target_pos:
            for _ in range(10): # 최대 10번 시도
                tx = random.randint(0, self.map_width - 1)
                ty = random.randint(0, self.map_height - 1)
                if self.map_manager and not self.map_manager.check_any_collision(tx, ty):
                    target_pos = (tx * TILE_SIZE + 16, ty * TILE_SIZE + 16)
                    break
        
        if target_pos:
            self.set_destination(target_pos[0], target_pos[1], "Random Move")
    def find_tile(self, target_ids, sort_by_distance=True, npcs=None):
        candidates = []; tile_cache = self.map_manager.tile_cache if self.map_manager else {}
        for tid in target_ids:
            if tid in tile_cache:
                for px, py in tile_cache[tid]:
                    dist_sq = (self.rect.centerx - px)**2 + (self.rect.centery - py)**2
                    if dist_sq > (60 * TILE_SIZE)**2: continue
                    neighbor = self.get_valid_neighbor(px//TILE_SIZE, py//TILE_SIZE)
                    if neighbor: candidates.append((neighbor, dist_sq))
        if candidates:
            if sort_by_distance: candidates.sort(key=lambda c: c[1])
            return candidates[0][0]
        return None
    def get_valid_neighbor(self, tx, ty):
        offsets = [(0, 1), (0, -1), (1, 0), (-1, 0)]; random.shuffle(offsets)
        for dx, dy in offsets:
            nx, ny = tx + dx, ty + dy
            if 0 <= nx < self.map_width and 0 <= ny < self.map_height:
                if self.map_manager and not self.map_manager.check_any_collision(nx, ny): return (nx * TILE_SIZE + 16, ny * TILE_SIZE + 16)
        return None
    def has_line_of_sight(self, target): return math.sqrt((self.rect.centerx - target.rect.centerx)**2 + (self.rect.centery - target.rect.centery)**2) < VISION_RADIUS['DAY'] * TILE_SIZE
    def check_stat_changes(self):
        if self.hp != self.last_stats['hp']: diff = self.hp-self.last_stats['hp']; self.add_popup(f"{diff} HP", (255, 50, 50) if diff < 0 else (50, 255, 50)); self.last_stats['hp'] = self.hp
        if self.coins != self.last_stats['coins']: diff = self.coins-self.last_stats['coins']; self.add_popup(f"+{diff} G", (255, 215, 0)); self.last_stats['coins'] = self.coins
    def find_house_door(self, npcs=None):
        candidates = []
        for y in range(self.map_height):
            for x in range(self.map_width):
                if self.zone_map[y][x] in INDOOR_ZONES:
                    tid = self.map_manager.get_tile(x, y, 'object') if self.map_manager else 0
                    if get_tile_function(tid) in [2, 3]: candidates.append((x*TILE_SIZE+16, y*TILE_SIZE+16))
        return random.choice(candidates) if candidates else None
    def find_hiding_spot(self, npcs):
        found = self.find_tile(HIDEABLE_TILES, npcs=npcs)
        if found:
            if math.sqrt((self.rect.centerx - found[0])**2 + (self.rect.centery - found[1])**2) < TILE_SIZE: self.is_hiding, self.hiding_type, self.path = True, 2, []; self.is_moving = False; return True
            return self.set_destination(found[0], found[1], "Moving to Hide")
        return False
    def draw(self, screen, camera_x, camera_y, viewer_role="PLAYER", viewer_device_on=False):
        if self.alive: CharacterRenderer.draw_entity(screen, self, camera_x, camera_y, viewer_role, viewer_device_on=viewer_device_on)
        rx, ry = self.rect.x - camera_x, self.rect.y - camera_y
        if not self.is_hiding or self.hiding_type == 2:
            y_off = 0
            for p in reversed(self.popups):
                if pygame.time.get_ticks() < p['timer']:
                    txt = FONT_POPUP.render(p['text'], True, p['color']); screen.blit(txt, (rx + TILE_SIZE//2 - txt.get_width()//2, ry - 20 - y_off)); y_off += 15



################################################################################
 FILE: entities\player.py
################################################################################

--- [Code Analysis & Settings] ---

  [Class] Bullet
    [Method] __init__(self, x, y, angle, is_enemy)
    [Method] update(self)
    [Method] draw(self, screen, camera_x, camera_y)

  [Class] Player
    [Method] __init__(self, x, y, width, height, map_data, zone_map, map_manager)
    [Method] is_dead(self)
    [Method] is_dead(self, value)
    [Method] reset(self)
    [Method] change_role(self, new_role, sub_role)
    [Method] morning_process(self, slept_at_home)
    [Method] toggle_flashlight(self)
    [Method] toggle_device(self)
    [Method] update(self, phase, npcs, is_blackout, weather_type)
    [Method] calculate_emotions(self, phase, npcs, is_blackout)
    [Method] get_current_speed(self, weather_type)
    [Method] _handle_movement_input(self)
    [Method] _update_devices_and_battery(self, now)
    [Method] _update_stamina(self, is_moving)
    [Method] _generate_status_noises(self, now, is_moving)
    [Method] _update_special_states(self, now)
    [Method] get_vision_radius(self, vision_factor, is_blackout, weather_type, remaining_time, total_duration)
    [Method] heal_full(self)
    [Method] buy_item(self, item_key)
    [Method] use_active_skill(self)
    [Method] do_attack(self, target)
    [Method] do_heal(self, target)
    [Method] interact_tile(self, gx, gy, npcs, mode)
    [Method] _open_chest_reward(self, gx, gy)
    [Method] work_complete(self, px, py, next_tile, reward)
    [Method] do_break(self, px, py)
    [Method] fail_penalty(self)
    [Method] update_bullets(self, npcs)
    [Method] draw(self, screen, camera_x, camera_y)

--- [Full Source Code] ---
import pygame
import math
import random
from settings import *
from colors import *
from world.tiles import *
from systems.minigame import MiniGameManager
from systems.renderer import CharacterRenderer
from .entity import Entity
from systems.logger import GameLogger

class Bullet:
    def __init__(self, x, y, angle, is_enemy=False):
        self.x = x; self.y = y; self.angle = angle
        self.speed = 12; self.radius = 4; self.alive = True; self.is_enemy = is_enemy
    def update(self): self.x += math.cos(self.angle) * self.speed; self.y += math.sin(self.angle) * self.speed
    def draw(self, screen, camera_x, camera_y):
        color = (255, 100, 100) if self.is_enemy else COLORS['BULLET']
        pygame.draw.circle(screen, color, (int(self.x - camera_x), int(self.y - camera_y)), self.radius)

class Player(Entity):
    def __init__(self, x, y, width, height, map_data, zone_map, map_manager=None):
        super().__init__(x, y, map_data, map_width=width, map_height=height, zone_map=zone_map, name="Player", role="CITIZEN", map_manager=map_manager)
        self.logger = GameLogger.get_instance()
        self.start_x = float(self.rect.x); self.start_y = float(self.rect.y)
        
        self.color = COLORS['CLOTHES']
        self.emotions = {}
        self.pre_hide_pos = None; self.flashlight_on = False; self.breath_gauge = 100
        self.infinite_stamina_buff = False; self.ability_used = False
        self.sound_timers = {'HEARTBEAT': 0, 'COUGH': 0, 'SCREAM': 0, 'FOOTSTEP': 0}
        self.shiver_timer = 0; self.blink_timer = 0
        self.is_eyes_closed = False; self.vibration_offset = (0, 0)
        self.bullets = []; self.last_attack_time = 0; self.attack_cooldown = 500
        self.minigame = MiniGameManager()
        self.vote_count = 0; self.daily_work_count = 0; self.work_step = 0
        self.bullets_fired_today = 0; self.day_count = 0; self.exhausted = False; self.exhaust_timer = 0
        self.doors_to_close = []; self.current_phase_ref = "MORNING"
        self.custom = {'skin': 0, 'clothes': 0, 'hat': 0}
        self.move_state = "WALK"; self.facing_dir = (0, 1); self.interaction_hold_timer = 0; self.e_key_pressed = False
        self.logger.info("PLAYER", f"Initialized at ({x}, {y}) Role: {self.role}")

    @property
    def is_dead(self): return not self.alive
    @is_dead.setter
    def is_dead(self, value): self.alive = not value

    def reset(self):
        self.pos_x = self.start_x; self.pos_y = self.start_y
        self.rect.x = int(self.pos_x); self.rect.y = int(self.pos_y)
        self.hp, self.ap, self.coins = self.max_hp, self.max_ap, 0
        self.alive = True; self.is_hiding = False; self.hiding_type = 0
        self.bullets.clear(); self.inventory = {k: 0 for k in ITEMS.keys()}; self.inventory['BATTERY'] = 1
        for k in self.buffs: self.buffs[k] = False
        self.flashlight_on, self.device_on, self.minigame.active = False, False, False
        self.breath_gauge = 100; self.ability_used = False
        self.daily_work_count = 0; self.work_step = 0; self.bullets_fired_today = 0
        self.day_count = 0; self.exhausted = False; self.hidden_in_solid = False
        self.emotions = {}; self.move_state = "WALK"; self.device_battery = 100.0; self.infinite_stamina_buff = False; self.powerbank_uses = 0

    def change_role(self, new_role, sub_role=None):
        self.role = new_role
        if self.role == "CITIZEN": self.sub_role = sub_role if sub_role else random.choice(["FARMER", "MINER", "FISHER"])
        else: self.sub_role = None
        if self.role == "DOCTOR": self.custom['clothes'] = 6
        elif self.role == "POLICE": self.custom['clothes'] = 2
        self.logger.info("PLAYER", f"Role changed to {self.role} ({self.sub_role})")

    def morning_process(self, slept_at_home):
        if self.role == "SPECTATOR": return False
        super().morning_process()
        self.day_count += 1
        
        # [개편] 수면 효과 (집 안 +10, 집 밖 -30)
        if slept_at_home:
            self.hp = min(self.max_hp, self.hp + 10)
            self.ap = min(self.max_ap, self.ap + 10)
        else:
            self.hp = max(0, self.hp - 30)
            self.ap = max(0, self.ap - 30)
        
        # [개편] 업무 페널티
        if self.role in ["CITIZEN", "DOCTOR"]:
            if self.daily_work_count < 5: self.hp -= 10 
            self.daily_work_count = 0; self.work_step = (self.day_count - 1) % 3
            
        self.is_hiding = False; self.hiding_type = 0; self.hidden_in_solid = False; self.exhausted = False
        self.ability_used = False; self.bullets_fired_today = 0
        
        if self.role != "POLICE" and self.hp <= 0: self.alive = False
        self.logger.info("PLAYER", "Morning Process Complete")
        return slept_at_home

    # [복구] 누락되었던 메서드 복구
    def toggle_flashlight(self): 
        self.flashlight_on = not self.flashlight_on

    def toggle_device(self):
        if self.role in ["CITIZEN", "DOCTOR", "POLICE", "MAFIA"]:
            if self.device_battery > 0:
                self.device_on = not self.device_on
                self.logger.debug("PLAYER", f"Device toggled: {self.device_on}")
                return "Device ON" if self.device_on else "Device OFF"
            else:
                self.device_on = False
                return "Battery Empty!"
        return "Device unavailable for this role."

    def update(self, phase, npcs, is_blackout, weather_type='CLEAR'):
        self.current_phase_ref = phase
        self.weather = weather_type 
        if not self.alive: return []
        if self.minigame.active: self.minigame.update(); return []
        
        now = pygame.time.get_ticks()
        
        # 1. 감정 계산 (5단계 시스템)
        self.calculate_emotions(phase, npcs, is_blackout)
        
        # 2. 이동 처리 (단계별 속도 적용)
        is_moving = self._handle_movement_input()
        
        # 3. 장비 및 배터리
        sound_events = self._update_devices_and_battery(now)
        
        # 4. 스태미나 및 호흡
        self._update_stamina(is_moving)
        
        # 5. 상태 소음 생성 (기침, 심장박동, 발소리)
        sound_events.extend(self._generate_status_noises(now, is_moving))
        
        # 6. 특수 상태 업데이트 (기면증, 떨림, 은신해제)
        self._update_special_states(now)

        # 7. 상호작용 키 입력 (E)
        keys = pygame.key.get_pressed()
        if keys[pygame.K_e]:
            if not self.e_key_pressed: 
                self.e_key_pressed = True
                self.interaction_hold_timer = now
                self.logger.debug("INPUT", "E Key Pressed")
        else:
            if self.e_key_pressed:
                hold_time = now - self.interaction_hold_timer
                tx = int((self.rect.centerx + self.facing_dir[0]*TILE_SIZE)//TILE_SIZE)
                ty = int((self.rect.centery + self.facing_dir[1]*TILE_SIZE)//TILE_SIZE)
                self.logger.debug("INPUT", f"E Key Released (Hold: {hold_time}ms) Target: ({tx}, {ty})")
                
                if hold_time < 500:
                    res = self.interact_tile(tx, ty, npcs, mode='short')
                    if isinstance(res, tuple):
                        msg, sound = res
                        if msg: self.add_popup(msg)
                        if sound: sound_events.append(sound)
                    elif res: self.add_popup(res)
                else:
                    res = self.interact_tile(tx, ty, npcs, mode='long')
                    if isinstance(res, tuple):
                        msg, sound = res
                        if msg: self.add_popup(msg, (255, 100, 100))
                        if sound: sound_events.append(sound)
                    elif res: self.add_popup(res, (255, 100, 100))
                self.e_key_pressed = False
                
        return sound_events

    def calculate_emotions(self, phase, npcs, is_blackout):
        self.emotions = {}
        if not self.alive or self.role == "SPECTATOR": return

        # 1. 행복 (HAPPINESS): HP, AP 모두 80 이상
        if self.hp >= 80 and self.ap >= 80:
            self.emotions['HAPPINESS'] = 1

        # 2. 고통 (PAIN): HP 50 이하부터 5단계
        if self.hp <= 50:
            if self.hp <= 10: level = 5
            elif self.hp <= 20: level = 4
            elif self.hp <= 30: level = 3
            elif self.hp <= 40: level = 2
            else: level = 1
            self.emotions['PAIN'] = level

        # 3. 피로 (FATIGUE): AP 50 이하부터 5단계
        if self.ap <= 50:
            if self.ap <= 10: level = 5
            elif self.ap <= 20: level = 4
            elif self.ap <= 30: level = 3
            elif self.ap <= 40: level = 2
            else: level = 1
            self.emotions['FATIGUE'] = level

        # 4. 공포 (FEAR): 사보타주(정전) 시
        if is_blackout:
            self.emotions['FEAR'] = 1

        # 5. 거리 기반 감정 (불안, 도파민, 분노)
        dist_thresholds = [30, 25, 20, 10, 5] 
        
        target_role = None
        my_emotion = None
        
        # [수정] 마피아와 경찰의 특수 감정은 'NIGHT' 또는 'DAWN'에만 작동하도록 조건 추가
        if self.role == "MAFIA" and phase in ["NIGHT", "DAWN"]: # 도파민 (밤 한정)
            target_role = ["CITIZEN", "DOCTOR", "FARMER", "MINER", "FISHER", "POLICE"] 
            my_emotion = 'DOPAMINE'
        elif self.role == "POLICE" and phase in ["NIGHT", "DAWN"]: # 분노 (밤 한정)
            target_role = ["MAFIA"]
            my_emotion = 'RAGE'
        elif phase in ["EVENING", "NIGHT", "DAWN"]: # 불안 (저녁/밤/새벽)
            target_role = ["MAFIA"]
            my_emotion = 'ANXIETY'

        if my_emotion and target_role:
            min_dist_tile = 999
            for n in npcs:
                if n.role in target_role and n.alive:
                    d_px = math.hypot(self.rect.centerx - n.rect.centerx, self.rect.centery - n.rect.centery)
                    d_tile = d_px / TILE_SIZE
                    if d_tile < min_dist_tile: min_dist_tile = d_tile
            
            level = 0
            if min_dist_tile <= 5: level = 5
            elif min_dist_tile <= 10: level = 4
            elif min_dist_tile <= 20: level = 3
            elif min_dist_tile <= 25: level = 2
            elif min_dist_tile <= 30: level = 1
            
            if level > 0:
                self.emotions[my_emotion] = level

        if not self.emotions: self.emotions['CALM'] = 1

    def get_current_speed(self, weather_type='CLEAR'):
        if self.move_state == "RUN": base = SPEED_RUN
        elif self.move_state == "CROUCH": base = SPEED_CROUCH
        else: base = SPEED_WALK
        
        multiplier = 1.0
        
        # 1. 긍정적 효과
        if 'HAPPINESS' in self.emotions: multiplier += 0.10
        if 'DOPAMINE' in self.emotions:
            level = self.emotions['DOPAMINE']
            bonus = [0, 0.05, 0.10, 0.15, 0.20, 0.30]
            multiplier += bonus[level]
        if 'RAGE' in self.emotions:
            level = self.emotions['RAGE']
            bonus = [0, 0.05, 0.10, 0.15, 0.20, 0.30]
            multiplier += bonus[level]

        # 2. 부정적 효과
        if 'FEAR' in self.emotions: multiplier -= 0.30
        
        if 'FATIGUE' in self.emotions:
            level = self.emotions['FATIGUE']
            penalty = [0, 0.05, 0.10, 0.15, 0.20, 0.30]
            multiplier -= penalty[level]
            
        if 'PAIN' in self.emotions and not self.buffs['NO_PAIN']:
            level = self.emotions['PAIN']
            penalty = [0, 0.05, 0.10, 0.15, 0.20, 0.30]
            multiplier -= penalty[level]

        if self.role == "POLICE": multiplier *= POLICE_SPEED_MULTI
        if self.buffs.get('FAST_WORK'): multiplier *= 1.2
        if weather_type == 'SNOW': multiplier *= 0.8
        
        return base * max(0.2, multiplier)

    def _handle_movement_input(self):
        keys = pygame.key.get_pressed(); dx, dy = 0, 0
        if keys[pygame.K_LEFT]: dx = -1
        if keys[pygame.K_RIGHT]: dx = 1
        if keys[pygame.K_UP]: dy = -1
        if keys[pygame.K_DOWN]: dy = 1
        
        infinite_stamina = ('RAGE' in self.emotions and self.role == "POLICE") or self.buffs['INFINITE_STAMINA']
        
        if keys[pygame.K_LSHIFT] and (self.breath_gauge > 0 or infinite_stamina): 
            self.move_state = "RUN"
        elif keys[pygame.K_LCTRL]: 
            self.move_state = "CROUCH"
        else: 
            self.move_state = "WALK"
            
        is_moving = False
        if dx != 0 or dy != 0:
            speed = self.get_current_speed(getattr(self, 'weather', 'CLEAR'))
            if dx != 0 and dy != 0: speed *= 0.7071
            self.move_single_axis(dx * speed, 0); self.move_single_axis(0, dy * speed)
            is_moving = True
            if dx != 0: self.facing_dir = (dx, 0)
            elif dy != 0: self.facing_dir = (0, dy)

        self.is_moving = is_moving
        return is_moving

    def _update_devices_and_battery(self, now):
        sound_events = []
        if self.device_on:
            self.device_battery -= 0.05
            if self.device_battery <= 0: self.device_battery, self.device_on = 0, False; self.add_popup("Battery Depleted!", (255, 50, 50))
            if self.role in ["CITIZEN", "DOCTOR"] and now % 2000 < 50: sound_events.append(("BEEP", self.rect.centerx, self.rect.centery, 4 * TILE_SIZE))
        return sound_events

    def _update_stamina(self, is_moving):
        infinite = ('RAGE' in self.emotions and self.role == "POLICE") or self.buffs['INFINITE_STAMINA']
        if self.move_state == "RUN" and is_moving and not infinite: self.breath_gauge -= 0.5
        elif self.move_state != "RUN": self.breath_gauge = min(100, self.breath_gauge + 0.5)

    def _generate_status_noises(self, now, is_moving):
        sound_events = []
        if is_moving:
            step_interval = 600 if self.move_state == "WALK" else (300 if self.move_state == "RUN" else 800)
            if now > self.sound_timers['FOOTSTEP']:
                self.sound_timers['FOOTSTEP'] = now + step_interval
                s_type = "THUD" if self.move_state == "RUN" else ("RUSTLE" if self.move_state == "CROUCH" else "FOOTSTEP")
                radius = NOISE_RADIUS.get(self.move_state, 0)
                if self.buffs['SILENT']: radius *= 0.7
                if getattr(self, 'weather', 'CLEAR') == 'RAIN': radius *= 0.8
                if radius > 0: sound_events.append((s_type, self.rect.centerx, self.rect.centery, radius, self.role))
        
        if 'FEAR' in self.emotions:
            if now > self.sound_timers['SCREAM']:
                self.sound_timers['SCREAM'] = now + random.randint(3000, 6000)
                sound_events.append(("SCREAM", self.rect.centerx, self.rect.centery, 15 * TILE_SIZE, self.role))

        if self.emotions.get('PAIN', 0) >= 5 and not self.buffs['NO_PAIN']:
            if now > self.sound_timers['COUGH']:
                self.sound_timers['COUGH'] = now + 4000
                sound_events.append(("COUGH", self.rect.centerx, self.rect.centery, 8 * TILE_SIZE, self.role))
        
        heartbeat_level = 0
        for emo in ['ANXIETY', 'DOPAMINE', 'RAGE']:
            if emo in self.emotions:
                heartbeat_level = max(heartbeat_level, self.emotions[emo])
        
        if heartbeat_level > 0:
            interval = 1500 - (heartbeat_level * 200)
            if now > self.sound_timers['HEARTBEAT']:
                self.sound_timers['HEARTBEAT'] = now + interval
                if heartbeat_level >= 3: radius = 5 * TILE_SIZE 
                else: radius = 0 
                sound_events.append(("HEARTBEAT", self.rect.centerx, self.rect.centery, radius, self.role))
            
        return sound_events

    def _update_special_states(self, now):
        if 'FEAR' in self.emotions or self.emotions.get('PAIN', 0) >= 3:
            if now > self.shiver_timer: 
                self.shiver_timer = now + 50
                intensity = 2 if 'FEAR' in self.emotions else 1
                self.vibration_offset = (random.randint(-intensity, intensity), random.randint(-intensity, intensity))
        else: self.vibration_offset = (0, 0)
        
        if self.emotions.get('FATIGUE', 0) >= 5:
            if not hasattr(self, 'narcolepsy_timer'): self.narcolepsy_timer = now
            if (now - self.narcolepsy_timer) % 5000 > 4000:
                if not self.is_eyes_closed: self.is_eyes_closed = True; self.add_popup("Sleepy...", (100, 100, 200))
            else: self.is_eyes_closed = False
        else: self.is_eyes_closed = False

        if 'FEAR' in self.emotions:
            if self.is_hiding:
                self.is_hiding = False; self.hiding_type = 0; self.add_popup("PANIC! Cannot Hide!", (255, 50, 50))
            return

        gx, gy = int(self.rect.centerx // TILE_SIZE), int(self.rect.centery // TILE_SIZE)
        current_tid = 0; hiding_val = 0
        if 0 <= gx < self.map_width and 0 <= gy < self.map_height:
            if self.map_manager:
                val = self.map_manager.get_tile_full(gx, gy, 'object')
                current_tid = val[0]
                hiding_val = get_tile_hiding(current_tid)
                if hiding_val == 0:
                    val = self.map_manager.get_tile_full(gx, gy, 'floor')
                    current_tid = val[0]
                    hiding_val = get_tile_hiding(current_tid)
            else:
                current_tid = self.map_data[gy][gx]
                hiding_val = get_tile_hiding(current_tid)

        is_passive_tile = (hiding_val == 1)
        is_active_tile = (hiding_val == 2)
        
        if is_passive_tile:
            if not self.is_hiding: self.is_hiding, self.hiding_type = True, 1
        elif is_active_tile:
            if self.move_state == "CROUCH":
                if not self.is_hiding: self.is_hiding, self.hiding_type = True, 2; self.rect.center = (gx*TILE_SIZE + 16, gy*TILE_SIZE + 16); self.pos_x, self.pos_y = self.rect.x, self.rect.y
            else:
                if self.is_hiding and self.hiding_type == 2: self.is_hiding, self.hiding_type = False, 0
        else:
            if self.is_hiding: self.is_hiding, self.hiding_type = False, 0

    def get_vision_radius(self, vision_factor, is_blackout, weather_type='CLEAR', remaining_time=60, total_duration=60):
        if self.role == "SPECTATOR": return 40
        if self.is_eyes_closed: return 0
        
        day_vision = VISION_RADIUS['DAY']
        if self.role == "MAFIA": night_vision = VISION_RADIUS['NIGHT_MAFIA']
        elif self.role == "POLICE": night_vision = VISION_RADIUS['NIGHT_POLICE_FLASH'] if self.flashlight_on else 2.0
        else: night_vision = VISION_RADIUS['NIGHT_CITIZEN'] 

        if self.current_phase_ref == 'DAWN' and self.role != "MAFIA": night_vision = 0.0

        current_rad = night_vision + (day_vision - night_vision) * vision_factor
        
        if weather_type == 'FOG': current_rad *= 0.7
        if 'FATIGUE' in self.emotions: 
            current_rad = max(1.0, current_rad - self.emotions['FATIGUE'] * 0.5)

        if is_blackout and self.role != "MAFIA": return 1.5
        return max(0, current_rad)

    def heal_full(self): self.hp, self.ap, self.ability_used = self.max_hp, self.max_ap, False

    def buy_item(self, item_key):
        if self.role == "SPECTATOR": return
        if item_key in ITEMS:
            p = ITEMS[item_key]['price']
            if self.coins >= p: 
                self.coins -= p; self.inventory[item_key] = self.inventory.get(item_key, 0) + 1; 
                self.logger.info("PLAYER", f"Bought {item_key}")
                return ("Bought " + ITEMS[item_key]['name'], ("KA-CHING", self.rect.centerx, self.rect.centery, 5 * TILE_SIZE, self.role))
            else: print("Not enough coins!")

    def use_active_skill(self):
        if not self.alive: return None
        if self.role == "SPECTATOR": return None
        if self.ability_used: return "Skill already used today!"
        
        cost = 50
        if self.role == "MAFIA":
            if self.current_phase_ref != "NIGHT": return "Can only use at Night!"
            if not self.try_spend_ap(cost, allow_health_cost=False): return f"Not enough AP (Need {cost})!"
            self.ability_used = True; return "USE_SABOTAGE"
        elif self.role == "POLICE":
            if not self.try_spend_ap(cost, allow_health_cost=False): return f"Not enough AP (Need {cost})!"
            self.ability_used = True; return "USE_SIREN"
        return "No Active Skill for this role."

    def do_attack(self, target):
        if not self.alive or self.role == "SPECTATOR": return None
        if not target or not target.alive: return None
        now = pygame.time.get_ticks()
        if now - self.last_attack_time < self.attack_cooldown: return None
        self.last_attack_time = now
        
        attack_cost = 10
        if self.inventory.get('TASER', 0) > 0 and self.try_spend_ap(attack_cost, allow_health_cost=False):
            self.inventory['TASER'] -= 1; self.logger.info("PLAYER", "Used TASER"); target.take_stun(3000)
            return ("TASER SHOT!", (self.rect.centerx, self.rect.centery)), ("ZAP", self.rect.centerx, self.rect.centery, 4*TILE_SIZE, self.role)
            
        if self.current_phase_ref != "NIGHT": return None
        
        if self.role == "MAFIA" and self.try_spend_ap(attack_cost, allow_health_cost=False):
            if target.role == "POLICE": 
                target.take_stun(2000)
                return ("STUNNED POLICE!", (self.rect.centerx, self.rect.centery)), ("SLASH", self.rect.centerx, self.rect.centery, 5*TILE_SIZE, self.role)
            if target.inventory.get('ARMOR', 0) > 0: 
                target.inventory['ARMOR'] -= 1
                return ("BLOCKED", (self.rect.centerx, self.rect.centery)), ("CLICK", self.rect.centerx, self.rect.centery, 3*TILE_SIZE, self.role)
            target.take_damage(70)
            self.logger.info("PLAYER", f"Attacked {target.name}")
            return ("STAB", (self.rect.centerx, self.rect.centery)), ("SLASH", self.rect.centerx, self.rect.centery, 5*TILE_SIZE, self.role)
            
        elif self.role == "POLICE" and self.try_spend_ap(attack_cost, allow_health_cost=False):
            if self.current_phase_ref in ['MORNING', 'DAY', 'VOTE', 'NOON', 'AFTERNOON'] or self.bullets_fired_today >= 1: return None
            self.bullets_fired_today += 1
            dx = target.rect.centerx - self.rect.centerx; dy = target.rect.centery - self.rect.centery; angle = math.atan2(dy, dx)
            self.bullets.append(Bullet(self.rect.centerx, self.rect.centery, angle, is_enemy=False))
            self.logger.info("PLAYER", "Fired Gun")
            return ("GUNSHOT", (self.rect.centerx, self.rect.centery)), ("GUNSHOT", self.rect.centerx, self.rect.centery, 25*TILE_SIZE, self.role)
        return None

    def do_heal(self, target):
        if self.role != "DOCTOR" or not self.alive: return None
        if not self.try_spend_ap(10, allow_health_cost=False): return "Not enough AP!"
        if target and target.alive:
            target.hp = min(target.max_hp, target.hp + 50)
            self.logger.info("PLAYER", f"Doctor Healed {target.name}")
            return f"Healed {target.name}!", ("GULP", target.rect.centerx, target.rect.centery, 4*TILE_SIZE, self.role)
        return "No target to heal."

    def interact_tile(self, gx, gy, npcs, mode='short'):
        px, py = self.rect.centerx // TILE_SIZE, self.rect.centery // TILE_SIZE
        dist = abs(px - gx) + abs(py - gy)
        if dist != 1: return None

        tid = 0; target_layer = None
        if 0 <= gx < self.map_width and 0 <= gy < self.map_height:
            if self.map_manager and self.map_manager.is_tile_on_cooldown(gx, gy): return "Cooldown!"
            for layer in ['object', 'wall', 'floor']:
                val = self.map_manager.get_tile_full(gx, gy, layer)
                if val[0] != 0:
                    tid_check = val[0]; cat = get_tile_category(tid_check); d_val = get_tile_interaction(tid_check); func = get_tile_function(tid_check)
                    if cat in [5, 9] or d_val > 0 or func in [2, 3] or tid_check == 5321025: tid = tid_check; target_layer = layer; break

        if tid == 0: return None
        self.logger.info("PLAYER", f"Interact with {tid} at ({gx}, {gy}) Mode: {mode}")

        if tid == VENDING_MACHINE_TID: return "OPEN_SHOP" if mode == 'short' else None

        if tid == 5321025: 
            if mode == 'short': return "Hold 'E' to Unlock"
            elif mode == 'long':
                if self.ap < 5: return "Not enough AP (5)"
                self.minigame.start(random.choice(['HACKING', 'MEMORY']), 2, lambda: self._open_chest_reward(gx, gy), self.fail_penalty)
                return f"Unlocking..."

        cat = get_tile_category(tid); d_val = get_tile_interaction(tid)
        if cat == 5:
            if d_val == 1: 
                if mode == 'short': 
                    self.map_manager.open_door(gx, gy, target_layer)
                    return "Opened", ("CREAK", gx*TILE_SIZE, gy*TILE_SIZE, 5*TILE_SIZE, self.role)
                elif mode == 'long':
                    from settings import INDOOR_ZONES
                    is_inside = (self.zone_map[py][px] in INDOOR_ZONES)
                    if is_inside or self.inventory.get('KEY', 0) > 0 or self.inventory.get('MASTER_KEY', 0) > 0:
                        if self.ap < 5: return "Not enough AP (5)"
                        if not is_inside and self.inventory.get('KEY', 0) > 0: self.inventory['KEY'] -= 1
                        self.try_spend_ap(5); self.map_manager.lock_door(gx, gy, target_layer)
                        return "Locked Door", ("CLICK", gx*TILE_SIZE, gy*TILE_SIZE, 3*TILE_SIZE, self.role)
                    else:
                        if self.ap < 5: return "Not enough AP (5)"
                        self.minigame.start('TIMING', 2, lambda: self.map_manager.lock_door(gx, gy, target_layer), self.fail_penalty)
                        return "Locking..."
            elif d_val == 3: 
                if mode == 'short': return "It's Locked."
                elif mode == 'long':
                    if self.inventory.get('KEY', 0) > 0: 
                        self.inventory['KEY'] -= 1; self.map_manager.unlock_door(gx, gy, target_layer)
                        return "Unlocked with Key", ("CLICK", gx*TILE_SIZE, gy*TILE_SIZE, 3*TILE_SIZE, self.role)
                    elif self.inventory.get('MASTER_KEY', 0) > 0: 
                        self.map_manager.unlock_door(gx, gy, target_layer)
                        return "Unlocked with Master Key", ("CLICK", gx*TILE_SIZE, gy*TILE_SIZE, 3*TILE_SIZE, self.role)
                    else:
                        if "Glass" in get_tile_name(tid): return "Cannot Pick Lock!"
                        if self.ap < 5: return "Not enough AP (5)"
                        self.minigame.start('LOCKPICK', 3, lambda: self.map_manager.unlock_door(gx, gy, target_layer), self.fail_penalty)
                        return "Picking Lock..."
            elif "Open" in get_tile_name(tid):
                if mode == 'short': self.map_manager.close_door(gx, gy, target_layer); return "Closed", ("SLAM", gx*TILE_SIZE, gy*TILE_SIZE, 6*TILE_SIZE, self.role)

        if mode == 'short':
            if self.role == "MAFIA" and self.current_phase_ref == "NIGHT":
                 cat = get_tile_category(tid)
                 if cat in [3, 5, 6]:
                     self.minigame.start('MASHING', 2, lambda: self.do_break(gx, gy), self.fail_penalty)
                     return "Breaking...", ("BANG!", gx*TILE_SIZE, gy*TILE_SIZE, 12*TILE_SIZE, self.role)

            job_key = self.role if self.role == "DOCTOR" else self.sub_role
            if job_key in WORK_SEQ:
                seq = WORK_SEQ[job_key]; target_idx = self.work_step % len(seq); target_tid = seq[target_idx]
                if tid == target_tid:
                    m_type = MINIGAME_MAP[job_key].get(target_idx, 'MASHING')
                    next_t = seq[(target_idx + 1) % len(seq)]; is_final = (target_idx == len(seq) - 1)
                    if self.ap < 10: return "Not enough AP (10)"
                    self.minigame.start(m_type, 1, lambda: self.work_complete(gx*TILE_SIZE, gy*TILE_SIZE, next_t, is_final), self.fail_penalty)
                    return f"Working ({m_type})..."
                elif tid in seq: return "Not today's task."
        return None

    def _open_chest_reward(self, gx, gy):
        self.try_spend_ap(5)
        roll = random.random(); cumulative = 0.0; selected_reward = None
        for rate in TREASURE_CHEST_RATES:
            cumulative += rate['prob']
            if roll < cumulative: selected_reward = rate; break
        if not selected_reward: selected_reward = TREASURE_CHEST_RATES[-1]
        
        msg = ""
        if selected_reward['type'] == 'EMPTY': msg = selected_reward['msg']
        elif selected_reward['type'] == 'GOLD': self.coins += selected_reward['amount']; msg = selected_reward['msg']
        elif selected_reward['type'] == 'ITEM':
            item = random.choice(selected_reward['items']); self.inventory[item] = self.inventory.get(item, 0) + 1
            msg = selected_reward['msg'].format(item=ITEMS[item]['name'])
            
        if self.map_manager: self.map_manager.set_tile(gx, gy, 5310025, layer='object')
        self.add_popup(msg, (255, 215, 0))

    def work_complete(self, px, py, next_tile, reward=False):
        self.try_spend_ap(10); gx, gy = px // TILE_SIZE, py // TILE_SIZE
        if self.sub_role == 'FARMER' and next_tile is not None: self.map_manager.set_tile(gx, gy, next_tile)
        if self.map_manager: self.map_manager.set_tile_cooldown(gx, gy, 3000)
        self.coins += 1; self.daily_work_count += 1

    def do_break(self, px, py):
        gx, gy = (px, py) if isinstance(px, int) and px < self.map_width else (px // TILE_SIZE, py // TILE_SIZE)
        if self.try_spend_ap(2): self.map_manager.set_tile(gx, gy, 5310005)

    def fail_penalty(self): self.try_spend_ap(2)

    def update_bullets(self, npcs):
        for b in self.bullets[:]:
            b.update()
            if b.x < 0 or b.x > self.map_width * TILE_SIZE or b.y < 0 or b.y > self.map_height * TILE_SIZE: self.bullets.remove(b); continue
            gx = int(b.x // TILE_SIZE); gy = int(b.y // TILE_SIZE)
            if 0 <= gx < self.map_width and 0 <= gy < self.map_height:
                hit_wall = False
                if self.map_manager:
                    if self.map_manager.check_any_collision(gx, gy): hit_wall = True
                else:
                    tid = self.map_data[gy][gx]; tid = tid[0] if isinstance(tid, (tuple, list)) else tid
                    if check_collision(tid): hit_wall = True
                if hit_wall: b.alive = False; self.bullets.remove(b); continue
            bullet_rect = pygame.Rect(b.x-2, b.y-2, 4, 4)
            targets = [self] if b.is_enemy else npcs
            for t in targets:
                if t.alive and bullet_rect.colliderect(t.rect): t.take_damage(70); b.alive = False; self.bullets.remove(b); break

    def draw(self, screen, camera_x, camera_y):
        if self.role == "SPECTATOR":
            draw_x = self.rect.centerx - camera_x; draw_y = self.rect.centery - camera_y
            s = pygame.Surface((40, 40), pygame.SRCALPHA); pygame.draw.circle(s, (100, 100, 255, 120), (20, 20), 15); pygame.draw.circle(s, (255, 255, 255, 180), (20, 20), 15, 2); screen.blit(s, (draw_x - 20, draw_y - 20))
            return
        if self.is_dead:
            draw_rect = self.rect.move(-camera_x, -camera_y); pygame.draw.rect(screen, (50, 50, 50), draw_rect)
        else: CharacterRenderer.draw_entity(screen, self, camera_x, camera_y)
        for b in self.bullets: b.draw(screen, camera_x, camera_y)



################################################################################
 FILE: main.py
################################################################################

--- [Code Analysis & Settings] ---
  (No specific structural elements found)

--- [Full Source Code] ---
from core.engine import GameEngine
import sys
import os

sys.path.append(os.path.dirname(os.path.abspath(__file__)))

if __name__ == "__main__":
    try:
        game = GameEngine()
        game.run()
    except Exception as e:
        import traceback
        traceback.print_exc()
        input("Error occurred. Press Enter to exit...")



################################################################################
 FILE: managers\__init__.py
################################################################################

--- [Code Analysis & Settings] ---
  (No specific structural elements found)

--- [Full Source Code] ---



################################################################################
 FILE: managers\resource_manager.py
################################################################################

--- [Code Analysis & Settings] ---

  [Class] ResourceManager
    [Method] get_instance(cls)
    [Method] __init__(self)
    [Method] _load_system_fonts(self)
    [Method] get_font(self, name)
    [Method] get_image(self, path, use_alpha)
      - Doc: 이미지를 로드하고 디스플레이 포맷에 맞춰 최적화(convert)하여 반환
    [Method] clear_cache(self)

--- [Full Source Code] ---
import pygame
import os
from systems.logger import GameLogger

class ResourceManager:
    _instance = None

    @classmethod
    def get_instance(cls):
        if cls._instance is None:
            cls._instance = ResourceManager()
        return cls._instance

    def __init__(self):
        if ResourceManager._instance is not None:
            raise Exception("This class is a singleton!")
        ResourceManager._instance = self

        self.logger = GameLogger.get_instance()
        self.fonts = {}
        self.sounds = {}
        self.images = {} # [추가] 이미지 캐시

        self._load_system_fonts()

    def _load_system_fonts(self):
        font_name = "malgungothic"
        if font_name not in pygame.font.get_fonts():
            font_name = "arial"

        try:
            self.fonts['default'] = pygame.font.SysFont(font_name, 18)
            self.fonts['bold'] = pygame.font.SysFont(font_name, 20, bold=True)
            self.fonts['large'] = pygame.font.SysFont(font_name, 28)
            self.fonts['title'] = pygame.font.SysFont(font_name, 60)
            self.fonts['small'] = pygame.font.SysFont(font_name, 12)
        except:
            self.logger.warning("RESOURCE", "Failed to load system fonts, using default")
            self.fonts['default'] = pygame.font.Font(None, 24)
            self.fonts['bold'] = pygame.font.Font(None, 26)
            self.fonts['large'] = pygame.font.Font(None, 36)
            self.fonts['title'] = pygame.font.Font(None, 70)
            self.fonts['small'] = pygame.font.Font(None, 16)

    def get_font(self, name):
        return self.fonts.get(name, self.fonts['default'])

    # [최적화] 이미지 로드 및 캐싱 메서드 추가
    def get_image(self, path, use_alpha=True):
        """이미지를 로드하고 디스플레이 포맷에 맞춰 최적화(convert)하여 반환"""
        if path in self.images:
            return self.images[path]
        
        try:
            if not os.path.exists(path):
                self.logger.error("RESOURCE", f"Image not found: {path}")
                return None
                
            img = pygame.image.load(path)
            # [핵심] 로드 직후 포맷 변환 (블리팅 속도 5~10배 향상)
            if use_alpha:
                img = img.convert_alpha()
            else:
                img = img.convert()
                
            self.images[path] = img
            return img
        except Exception as e:
            self.logger.error("RESOURCE", f"Failed to load image: {path} / {e}")
            return None
            
    def clear_cache(self):
        self.images.clear()
        # 폰트는 유지하거나 필요시 재생성


################################################################################
 FILE: map_editor.py
################################################################################

--- [Code Analysis & Settings] ---
  [Global Variable] UI_WIDTH = 340
  [Global Variable] MINIMAP_SIZE_BASE = 250
  [Global Variable] CAMERA_PADDING = 50

  [Class] MapEditor
    [Method] __init__(self)
    [Method] init_empty_map(self, w, h)
    [Method] update_filtered_tiles(self)
    [Method] get_selected_tile_id(self)
    [Method] grid_to_screen(self, gx, gy)
    [Method] screen_to_grid(self, sx, sy)
    [Method] get_selection_rect(self)
    [Method] apply_fill(self)
    [Method] rotate_clipboard(self)
      - Doc: 클립보드 내용을 90도 회전
    [Method] apply_paste(self, gx, gy)
    [Method] clamp_camera(self)
    [Method] save_map(self)
    [Method] load_map(self)
    [Method] handle_events(self)
    [Method] draw_button(self, text, rect, is_selected, hover_check)
    [Method] draw_menu(self)
    [Method] draw_input_size(self)
    [Method] draw_editor(self)
    [Method] draw_map_view(self)
    [Method] draw_grid_lines(self)
    [Method] draw_preview(self)
    [Method] draw_paste_preview(self, mx, my)
    [Method] draw_ui_panel(self)
    [Method] draw_minimap(self)
    [Method] handle_ui_click(self, mx, my)
    [Method] run(self)

--- [Full Source Code] ---
import pygame
import json
import sys
import os
import tkinter as tk
from tkinter import messagebox, filedialog
from settings import TILE_SIZE, FPS, ZONES
from colors import COLORS
from world.tiles import TILE_DATA, create_texture, get_tile_category, check_collision, get_tile_function, NEW_ID_MAP, get_tile_type, get_tile_interaction, get_tile_hiding

UI_WIDTH = 340
MINIMAP_SIZE_BASE = 250
CAMERA_PADDING = 50

class MapEditor:
    def __init__(self):
        pygame.init()
        self.root = tk.Tk(); self.root.withdraw()

        info = pygame.display.Info()
        self.screen_width = int(info.current_w * 0.9)
        self.screen_height = int(info.current_h * 0.9)

        self.screen = pygame.display.set_mode((self.screen_width, self.screen_height), pygame.RESIZABLE)
        pygame.display.set_caption("Pixel Night Map Editor - V9.8 (Deep Copy & Group Rotate)")

        self.clock = pygame.time.Clock()

        font_name = "malgungothic"
        if font_name not in pygame.font.get_fonts(): font_name = "arial"
        try:
            self.font = pygame.font.SysFont(font_name, 14)
            self.small_font = pygame.font.SysFont(font_name, 11)
            self.title_font = pygame.font.SysFont(font_name, 40)
        except:
            self.font = pygame.font.Font(None, 18)
            self.small_font = pygame.font.Font(None, 14)
            self.title_font = pygame.font.Font(None, 50)


        self.textures = {tid: create_texture(tid) for tid in TILE_DATA}
        self.ui_textures = {tid: pygame.transform.scale(surf, (24, 24)) for tid, surf in self.textures.items()}


        self.state = 'MENU'


        self.init_empty_map(50, 50)
        self.active_layer = 'floor'


        self.input_width_str = "50"
        self.input_height_str = "50"
        self.input_active_field = 0
        self.input_error_msg = ""


        self.camera_x = 0
        self.camera_y = 0
        self.zoom = 1.0
        self.min_zoom = 0.1
        self.max_zoom = 3.0


        self.tool_mode = 'BRUSH'
        self.clipboard = None
        self.mode = 'TILE'
        self.current_rotation = 0

        self.filters = {'A': None, 'B': None, 'C': None, 'D': None, 'E': None}
        self.filtered_tiles = []
        self.current_tile_idx = 0
        self.selected_zone_id = 1
        self.tile_list_scroll = 0

        self.update_filtered_tiles()


        self.is_dragging = False
        self.is_erasing = False
        self.drag_start_pos = (0, 0)
        self.drag_current_pos = (0, 0)


        self.ui_width = UI_WIDTH
        self.minimap_size = min(MINIMAP_SIZE_BASE, self.screen_height - 100, self.ui_width - 30)
        self.map_view_width = self.screen_width - self.ui_width
        self.mm_draw_rect = pygame.Rect(0, 0, 0, 0)
        self.ui_rects = {}

        self.running = True

    def init_empty_map(self, w, h):
        self.map_width, self.map_height = w, h
        self.layers = {
            'floor': [[(1110000, 0) for _ in range(w)] for _ in range(h)],
            'wall': [[(0, 0) for _ in range(w)] for _ in range(h)],
            'object': [[(0, 0) for _ in range(w)] for _ in range(h)]
        }
        self.zone_map = [[0 for _ in range(w)] for _ in range(h)]

    def update_filtered_tiles(self):
        results = []
        layer_cats = []
        if self.active_layer == 'floor': layer_cats = [1, 2]
        elif self.active_layer == 'wall': layer_cats = [3, 4]
        elif self.active_layer == 'object': layer_cats = [5, 6, 7, 8, 9]

        for tid in TILE_DATA.keys():
            cat = get_tile_category(tid)
            if cat not in layer_cats: continue
            if self.filters['A'] is not None and cat != self.filters['A']: continue
            if self.filters['B'] is not None and get_tile_type(tid) != self.filters['B']: continue
            c_val = 2 if check_collision(tid) else 1
            if self.filters['C'] is not None and c_val != self.filters['C']: continue
            if self.filters['D'] is not None and get_tile_interaction(tid) != self.filters['D']: continue
            if self.filters['E'] is not None and get_tile_hiding(tid) != self.filters['E']: continue
            results.append(tid)

        results.sort()
        self.filtered_tiles = results
        self.current_tile_idx = 0
        self.tile_list_scroll = 0

    def get_selected_tile_id(self):
        if not self.filtered_tiles: return 0
        if self.current_tile_idx >= len(self.filtered_tiles): self.current_tile_idx = 0
        return self.filtered_tiles[self.current_tile_idx]

    def grid_to_screen(self, gx, gy):
        return (gx * TILE_SIZE * self.zoom) - self.camera_x, (gy * TILE_SIZE * self.zoom) - self.camera_y

    def screen_to_grid(self, sx, sy):
        return int((sx + self.camera_x) / (TILE_SIZE * self.zoom)), int((sy + self.camera_y) / (TILE_SIZE * self.zoom))

    def get_selection_rect(self):
        x1, y1 = self.drag_start_pos; x2, y2 = self.drag_current_pos
        return min(x1, x2), max(x1, x2), min(y1, y2), max(y1, y2)

    def apply_fill(self):
        if self.tool_mode == 'BRUSH':
            sx, ex, sy, ey = self.get_selection_rect()
            tid = self.get_selected_tile_id()
            for y in range(sy, ey + 1):
                for x in range(sx, ex + 1):
                    if 0 <= x < self.map_width and 0 <= y < self.map_height:
                        if self.mode == 'TILE':
                            target_grid = self.layers[self.active_layer]
                            if self.is_erasing:
                                if self.active_layer == 'floor': target_grid[y][x] = (1110000, 0)
                                else: target_grid[y][x] = (0, 0)
                            else:
                                if self.active_layer in ['wall', 'object']:
                                    floor_tid = self.layers['floor'][y][x][0]
                                    if floor_tid == 0: continue
                                if self.active_layer == 'object' and get_tile_category(tid) == 5:
                                    self.layers['wall'][y][x] = (0, 0)
                                target_grid[y][x] = (tid, self.current_rotation)
                        else:
                            self.zone_map[y][x] = 0 if self.is_erasing else self.selected_zone_id

        elif self.tool_mode == 'COPY':
            sx, ex, sy, ey = self.get_selection_rect()
            w, h = ex - sx + 1, ey - sy + 1


            clipboard_data = {'floor': [], 'wall': [], 'object': [], 'zones': []}
            for y in range(sy, ey + 1):
                f_row, w_row, o_row, z_row = [], [], [], []
                for x in range(sx, ex + 1):
                    if 0 <= x < self.map_width and 0 <= y < self.map_height:
                        f_row.append(self.layers['floor'][y][x])
                        w_row.append(self.layers['wall'][y][x])
                        o_row.append(self.layers['object'][y][x])
                        z_row.append(self.zone_map[y][x])
                    else:
                        f_row.append((0,0)); w_row.append((0,0)); o_row.append((0,0)); z_row.append(0)
                clipboard_data['floor'].append(f_row)
                clipboard_data['wall'].append(w_row)
                clipboard_data['object'].append(o_row)
                clipboard_data['zones'].append(z_row)
            self.clipboard = {'w': w, 'h': h, 'data': clipboard_data}

    def rotate_clipboard(self):
        """클립보드 내용을 90도 회전"""
        if not self.clipboard: return
        w, h = self.clipboard['w'], self.clipboard['h']
        new_w, new_h = h, w
        new_data = {'floor': [], 'wall': [], 'object': [], 'zones': []}

        def rotate_grid(grid, is_tile=True):
            new_grid = [[None for _ in range(new_w)] for _ in range(new_h)]
            for y in range(h):
                for x in range(w):
                    nx, ny = h - 1 - y, x
                    val = grid[y][x]
                    if is_tile:
                        tid, rot = val
                        if tid != 0: new_grid[ny][nx] = (tid, (rot + 90) % 360)
                        else: new_grid[ny][nx] = (0, 0)
                    else:
                        new_grid[ny][nx] = val
            return new_grid

        new_data['floor'] = rotate_grid(self.clipboard['data']['floor'])
        new_data['wall'] = rotate_grid(self.clipboard['data']['wall'])
        new_data['object'] = rotate_grid(self.clipboard['data']['object'])
        new_data['zones'] = rotate_grid(self.clipboard['data']['zones'], is_tile=False)

        self.clipboard = {'w': new_w, 'h': new_h, 'data': new_data}

    def apply_paste(self, gx, gy):
        if not self.clipboard: return
        w, h = self.clipboard['w'], self.clipboard['h']
        for y in range(h):
            for x in range(w):
                mx, my = gx + x, gy + y
                if 0 <= mx < self.map_width and 0 <= my < self.map_height:
                    for layer in ['floor', 'wall', 'object']:
                        val = self.clipboard['data'][layer][y][x]

                        if val[0] != 0 or (layer == 'floor' and val[0] == 0):
                            if val[0] != 0: self.layers[layer][my][mx] = val

                    z_val = self.clipboard['data']['zones'][y][x]
                    if z_val != 0: self.zone_map[my][mx] = z_val

    def clamp_camera(self):
        mw, mh = self.map_width * TILE_SIZE * self.zoom, self.map_height * TILE_SIZE * self.zoom
        if mw < self.map_view_width: self.camera_x = -(self.map_view_width - mw) / 2
        else: self.camera_x = max(-CAMERA_PADDING, min(self.camera_x, mw - self.map_view_width + CAMERA_PADDING))
        if mh < self.screen_height: self.camera_y = -(self.screen_height - mh) / 2
        else: self.camera_y = max(-CAMERA_PADDING, min(self.camera_y, mh - self.screen_height + CAMERA_PADDING))

    def save_map(self):
        data = {"width": self.map_width, "height": self.map_height, "layers": self.layers, "zones": self.zone_map}
        try:
            with open("map.json", "w", encoding='utf-8') as f: json.dump(data, f)
            print("Map Saved!")
        except Exception as e: print(f"Save Error: {e}")

    def load_map(self):
        try:
            filename = filedialog.askopenfilename(initialdir=os.getcwd(), title="Select Map File", filetypes=[("JSON Files", "*.json"), ("All Files", "*.*")])
            if not filename: return False
            with open(filename, "r", encoding='utf-8') as f: data = json.load(f)
            load_w = data.get("width", 50); load_h = data.get("height", 50)

            if 'layers' not in data and 'tiles' in data:
                res = messagebox.askyesno("구형 맵 감지", "구형 맵 데이터입니다.\n최신 형식으로 변환하시겠습니까?")
                if res:
                    self.init_empty_map(load_w, load_h)
                    old_tiles = data['tiles']
                    rows = min(len(old_tiles), load_h)
                    for y in range(rows):
                        cols = min(len(old_tiles[y]), load_w)
                        for x in range(cols):
                            old_id = old_tiles[y][x]; new_id = NEW_ID_MAP.get(old_id, old_id); cat = get_tile_category(new_id); val = (new_id, 0)
                            if 0 <= y < self.map_height and 0 <= x < self.map_width:
                                if cat in [1, 2]: self.layers['floor'][y][x] = val
                                elif cat in [3, 4]: self.layers['wall'][y][x] = val
                                else:
                                    if self.layers['floor'][y][x][0] == 0: self.layers['floor'][y][x] = (1110000, 0)
                                    self.layers['object'][y][x] = val
                    loaded_zones = data.get("zones", [])
                    for y in range(min(len(loaded_zones), self.map_height)):
                        for x in range(min(len(loaded_zones[y]), self.map_width)): self.zone_map[y][x] = loaded_zones[y][x]
                else: return False
            else:
                self.init_empty_map(load_w, load_h)
                loaded_layers = data.get('layers', {})
                for k in ['floor', 'wall', 'object']:
                    if k in loaded_layers:
                        grid = loaded_layers[k]; rows = min(len(grid), self.map_height)
                        for y in range(rows):
                            cols = min(len(grid[y]), self.map_width)
                            for x in range(cols):
                                v = grid[y][x]
                                if isinstance(v, int): self.layers[k][y][x] = (v, 0)
                                elif isinstance(v, list): self.layers[k][y][x] = tuple(v)
                loaded_zones = data.get("zones", [])
                for y in range(min(len(loaded_zones), self.map_height)):
                    for x in range(min(len(loaded_zones[y]), self.map_width)): self.zone_map[y][x] = loaded_zones[y][x]

            self.state = 'EDITOR'; self.camera_x, self.camera_y = 0, 0; self.clamp_camera()
            self.update_filtered_tiles()
            return True
        except Exception as e: print(f"Load Error: {e}"); import traceback; traceback.print_exc(); return False

    def handle_events(self):
        for event in pygame.event.get():
            if event.type == pygame.QUIT: self.running = False
            if event.type == pygame.VIDEORESIZE:
                self.screen_width, self.screen_height = event.w, event.h
                self.screen = pygame.display.set_mode((self.screen_width, self.screen_height), pygame.RESIZABLE)
                self.map_view_width = self.screen_width - self.ui_width
                self.minimap_size = min(MINIMAP_SIZE_BASE, self.screen_height - 100, self.ui_width - 30)
                if self.state == 'EDITOR': self.clamp_camera()

            if self.state == 'MENU':
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_n: self.state = 'INPUT_SIZE'; self.input_error_msg = ""
                    elif event.key == pygame.K_l: self.load_map()
                    elif event.key == pygame.K_ESCAPE: self.running = False
                elif event.type == pygame.MOUSEBUTTONDOWN:
                    mx, my = pygame.mouse.get_pos(); cx, cy = self.screen_width // 2, self.screen_height // 2
                    if cx - 100 <= mx <= cx + 100:
                        if cy - 20 <= my <= cy + 30: self.state = 'INPUT_SIZE'; self.input_error_msg = ""
                        elif cy + 50 <= my <= cy + 100: self.load_map()

            elif self.state == 'INPUT_SIZE':
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_TAB: self.input_active_field = 1 - self.input_active_field
                    elif event.key == pygame.K_RETURN:
                        try:
                            w, h = int(self.input_width_str), int(self.input_height_str)
                            if 0 < w <= 500 and 0 < h <= 500: self.init_empty_map(w, h); self.state = 'EDITOR'; self.update_filtered_tiles()
                            else: self.input_error_msg = "1-500 Only"
                        except: self.input_error_msg = "Invalid Format"
                    elif event.key == pygame.K_ESCAPE: self.state = 'MENU'
                    elif event.key == pygame.K_BACKSPACE:
                        if self.input_active_field == 0: self.input_width_str = self.input_width_str[:-1]
                        else: self.input_height_str = self.input_height_str[:-1]
                    elif event.unicode.isdigit():
                        if self.input_active_field == 0: self.input_width_str += event.unicode
                        else: self.input_height_str += event.unicode

            elif self.state == 'EDITOR':
                mx, my = pygame.mouse.get_pos()
                if event.type == pygame.MOUSEWHEEL:
                    if mx < self.screen_width - self.ui_width:

                        world_mx = (mx + self.camera_x) / self.zoom
                        world_my = (my + self.camera_y) / self.zoom
                        new_zoom = max(self.min_zoom, min(self.max_zoom, self.zoom + (0.1 if event.y > 0 else -0.1)))
                        if new_zoom != self.zoom:
                            self.zoom = new_zoom
                            self.camera_x = (world_mx * self.zoom) - mx
                            self.camera_y = (world_my * self.zoom) - my
                        self.clamp_camera()
                    else:
                        self.tile_list_scroll = max(0, min(len(self.filtered_tiles) - 1, self.tile_list_scroll - event.y))
                elif event.type == pygame.MOUSEBUTTONDOWN:
                    if self.mm_draw_rect.collidepoint(mx, my):
                        if event.button == 1:
                            rx, ry = (mx - self.mm_draw_rect.x) / self.mm_draw_rect.width, (my - self.mm_draw_rect.y) / self.mm_draw_rect.height
                            self.camera_x, self.camera_y = rx * (self.map_width * TILE_SIZE * self.zoom) - (self.map_view_width / 2), ry * (self.map_height * TILE_SIZE * self.zoom) - (self.screen_height / 2); self.clamp_camera()
                    elif mx > self.screen_width - self.ui_width:
                        if event.button == 1: self.handle_ui_click(mx, my)
                    else:
                        if event.button in [1, 3]:
                            if self.tool_mode == 'PASTE':
                                if event.button == 1: gx, gy = self.screen_to_grid(mx, my); self.apply_paste(gx, gy)
                                elif event.button == 3: self.tool_mode = 'BRUSH'
                            else:
                                self.is_dragging = True; self.is_erasing = (event.button == 3); self.drag_start_pos = self.screen_to_grid(mx, my)
                elif event.type == pygame.MOUSEBUTTONUP:
                    if self.is_dragging and event.button in [1, 3]: self.apply_fill(); self.is_dragging = False
                elif event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_s and (pygame.key.get_mods() & pygame.KMOD_CTRL): self.save_map()
                    elif event.key == pygame.K_ESCAPE: self.state = 'MENU'
                    elif event.key == pygame.K_b: self.tool_mode = 'BRUSH'
                    elif event.key == pygame.K_c: self.tool_mode = 'COPY'
                    elif event.key == pygame.K_v:
                        if self.clipboard: self.tool_mode = 'PASTE'
                    elif event.key == pygame.K_r:
                        if self.tool_mode == 'PASTE': self.rotate_clipboard()
                        else: self.current_rotation = (self.current_rotation + 90) % 360
                    elif event.key == pygame.K_TAB: self.mode = 'ZONE' if self.mode == 'TILE' else 'TILE'
                    elif event.key == pygame.K_1: self.active_layer = 'floor'; self.update_filtered_tiles()
                    elif event.key == pygame.K_2: self.active_layer = 'wall'; self.update_filtered_tiles()
                    elif event.key == pygame.K_3: self.active_layer = 'object'; self.update_filtered_tiles()

    def draw_button(self, text, rect, is_selected=False, hover_check=True):
        mx, my = pygame.mouse.get_pos()
        color = COLORS['BUTTON_HOVER'] if hover_check and rect.collidepoint(mx, my) else COLORS['BUTTON']
        if is_selected: color = COLORS['SELECTION']
        pygame.draw.rect(self.screen, color, rect); pygame.draw.rect(self.screen, (200, 200, 200), rect, 1)
        txt = self.small_font.render(text, True, COLORS['TEXT'])
        self.screen.blit(txt, (rect.centerx - txt.get_width() // 2, rect.centery - txt.get_height() // 2))

    def draw_menu(self):
        cx, cy = self.screen_width // 2, self.screen_height // 2
        title = self.title_font.render("PIXEL NIGHT MAP EDITOR", True, COLORS['TEXT'])
        self.screen.blit(title, (cx - title.get_width() // 2, cy - 150))
        self.draw_button("NEW MAP", pygame.Rect(cx - 100, cy - 20, 200, 50))
        self.draw_button("LOAD MAP", pygame.Rect(cx - 100, cy + 50, 200, 50))

    def draw_input_size(self):
        cx, cy = self.screen_width // 2, self.screen_height // 2
        for i, text in enumerate([f"W: {self.input_width_str}", f"H: {self.input_height_str}"]):
            rect = pygame.Rect(cx - 110 + i*120, cy - 20, 100, 40); color = COLORS['SELECTION'] if self.input_active_field == i else COLORS['BUTTON']
            pygame.draw.rect(self.screen, color, rect, 2); self.screen.blit(self.font.render(text, True, COLORS['TEXT']), (rect.x + 10, rect.y + 10))

    def draw_editor(self):
        keys = pygame.key.get_pressed(); ms = 25 / self.zoom
        if keys[pygame.K_w] or keys[pygame.K_UP]: self.camera_y -= ms
        if keys[pygame.K_s] or keys[pygame.K_DOWN]:
            if not (pygame.key.get_mods() & pygame.KMOD_CTRL): self.camera_y += ms
        if keys[pygame.K_a] or keys[pygame.K_LEFT]: self.camera_x -= ms
        if keys[pygame.K_d] or keys[pygame.K_RIGHT]: self.camera_x += ms
        self.clamp_camera(); self.draw_map_view()
        mx, my = pygame.mouse.get_pos()
        self.drag_current_pos = self.screen_to_grid(mx, my)
        if mx < self.screen_width - self.ui_width and not self.mm_draw_rect.collidepoint(mx, my):
            if self.tool_mode == 'PASTE': self.draw_paste_preview(mx, my)
            elif self.is_dragging: self.draw_preview()
        self.draw_ui_panel(); self.draw_minimap()

    def draw_map_view(self):
        tp = TILE_SIZE * self.zoom; sc, ec = int(max(0, self.camera_x // tp)), int(min(self.map_width, (self.camera_x + self.map_view_width) // tp + 1))
        sr, er = int(max(0, self.camera_y // tp)), int(min(self.map_height, (self.screen_height // tp) + 1 + (self.camera_y // tp)))
        pygame.draw.rect(self.screen, COLORS['MAP_BORDER'], pygame.Rect(-self.camera_x, -self.camera_y, self.map_width * tp, self.map_height * tp), 2)
        layer_order = ['floor', 'wall', 'object']
        for layer in layer_order:
            grid = self.layers[layer]; alpha = 255 if layer == self.active_layer else 180
            for y in range(max(0, sr-1), min(self.map_height, er+1)):
                for x in range(max(0, sc-1), min(self.map_width, ec+1)):
                    sx, sy = self.grid_to_screen(x, y); tid, rot = grid[y][x]
                    if tid != 0:
                        if tid not in self.textures: self.textures[tid] = create_texture(tid)
                        surf = self.textures[tid]
                        if rot != 0: surf = pygame.transform.rotate(surf, rot)
                        surf = pygame.transform.scale(surf, (int(tp) + 1, int(tp) + 1))
                        if alpha < 255: surf.set_alpha(alpha)
                        self.screen.blit(surf, (sx, sy))
                    if layer == 'floor':
                        zid = self.zone_map[y][x]
                        if zid != 0:
                            s = pygame.Surface((int(tp) + 1, int(tp) + 1), pygame.SRCALPHA); s.fill(ZONES[zid]['color']); self.screen.blit(s, (sx, sy))
        self.draw_grid_lines()

    def draw_grid_lines(self):
        tp = TILE_SIZE * self.zoom
        for x in range(0, self.map_width + 1):
            sx, _ = self.grid_to_screen(x, 0)
            if 0 <= sx <= self.map_view_width:
                col, width = COLORS['GRID_10'], 1
                if x % 10 == 0: col = COLORS['GRID_50']
                if x % 50 == 0: col, width = COLORS['GRID'], 2
                if x == self.map_width // 2: col, width = COLORS['GRID_CENTER'], 3
                pygame.draw.line(self.screen, col, (sx, 0), (sx, self.screen_height), width)
        for y in range(0, self.map_height + 1):
            _, sy = self.grid_to_screen(0, y)
            if 0 <= sy <= self.screen_height:
                col, width = COLORS['GRID_10'], 1
                if y % 10 == 0: col = COLORS['GRID_50']
                if y % 50 == 0: col, width = COLORS['GRID'], 2
                if y == self.map_height // 2: col, width = COLORS['GRID_CENTER'], 3
                pygame.draw.line(self.screen, col, (0, sy), (self.map_view_width, sy), width)

    def draw_preview(self):
        sx, ex, sy, ey = self.get_selection_rect(); tp = TILE_SIZE * self.zoom
        preview_surf = None
        if self.mode == 'TILE' and not self.is_erasing:
            tid = self.get_selected_tile_id()
            if tid in self.textures:
                tex = self.textures[tid]
                if self.current_rotation != 0: tex = pygame.transform.rotate(tex, self.current_rotation)
                preview_surf = pygame.transform.scale(tex, (int(tp), int(tp))); preview_surf.set_alpha(150)
        for y in range(sy, ey + 1):
            for x in range(sx, ex + 1):
                px, py = self.grid_to_screen(x, y); r = (px, py, tp, tp)
                if self.tool_mode == 'COPY': pygame.draw.rect(self.screen, COLORS['COPY_SELECT'], r, 2)
                else:
                    if self.is_erasing: pygame.draw.rect(self.screen, (200, 50, 50), r, 2)
                    else:
                        if self.mode == 'TILE' and preview_surf: self.screen.blit(preview_surf, (px, py))
                        elif self.mode == 'ZONE':
                            c = ZONES[self.selected_zone_id]['color']; s = pygame.Surface((int(tp), int(tp)), pygame.SRCALPHA); s.fill(c); self.screen.blit(s, (px, py))
                        pygame.draw.rect(self.screen, (200, 200, 200), r, 1)

    def draw_paste_preview(self, mx, my):
        if not self.clipboard: return
        gx, gy = self.screen_to_grid(mx, my); tp = TILE_SIZE * self.zoom
        w, h = self.clipboard['w'], self.clipboard['h']
        for y in range(h):
            for x in range(w):
                sx, sy = self.grid_to_screen(gx + x, gy + y)
                tid, rot = 0, 0
                for layer in ['object', 'wall', 'floor']:
                    val = self.clipboard['data'][layer][y][x]
                    if val[0] != 0:
                        tid, rot = val; break

                if tid != 0:
                    if tid not in self.textures: self.textures[tid] = create_texture(tid)
                    t = self.textures[tid]
                    if rot != 0: t = pygame.transform.rotate(t, rot)
                    t = t.copy(); t.set_alpha(150); self.screen.blit(pygame.transform.scale(t, (int(tp), int(tp))), (sx, sy))
                pygame.draw.rect(self.screen, (255, 255, 255), (sx, sy, tp, tp), 1)

    def draw_ui_panel(self):
        self.ui_rects = {}
        pr = (self.screen_width - self.ui_width, 0, self.ui_width, self.screen_height)
        pygame.draw.rect(self.screen, COLORS['UI_BG'], pr); pygame.draw.rect(self.screen, COLORS['UI_BORDER'], pr, 2)
        y_off = 10; self.screen.blit(self.font.render(f"MODE: {self.mode} (TAB)", True, COLORS['SELECTION']), (pr[0] + 10, y_off)); y_off += 30
        if self.mode == 'TILE':
            self.screen.blit(self.small_font.render("Active Layer (1-3)", True, (200, 200, 200)), (pr[0] + 10, y_off)); y_off += 20
            for i, layer in enumerate(['floor', 'wall', 'object']):
                rect = pygame.Rect(pr[0] + 10 + i*100, y_off, 95, 25)
                self.draw_button(layer.upper(), rect, is_selected=(self.active_layer == layer)); self.ui_rects[f"LAYER_{layer}"] = rect
            y_off += 35
            self.screen.blit(self.small_font.render(f"Rotation: {self.current_rotation}° (R)", True, COLORS['SELECTION']), (pr[0] + 10, y_off)); y_off += 20
            filter_opts = { 'A': [1,2,3,4,5,6,7,8,9], 'B': [1,2,3], 'C': [1,2], 'D': [0,1,2], 'E': [0,1,2] }
            labels = {'A':'Cat','B':'Type','C':'Col','D':'Act','E':'Hide'}
            for f_key in ['A', 'B', 'C', 'D', 'E']:
                lbl = f"{f_key}: {labels[f_key]}"; self.screen.blit(self.small_font.render(lbl, True, (180, 180, 180)), (pr[0] + 10, y_off))
                all_rect = pygame.Rect(pr[0] + 60, y_off-2, 30, 18); self.draw_button("ALL", all_rect, is_selected=(self.filters[f_key] is None)); self.ui_rects[f"FILTER_{f_key}_ALL"] = all_rect
                for i, val in enumerate(filter_opts[f_key]):
                    rect = pygame.Rect(pr[0] + 95 + i*22, y_off-2, 20, 18); self.draw_button(str(val), rect, is_selected=(self.filters[f_key] == val)); self.ui_rects[f"FILTER_{f_key}_{val}"] = rect
                y_off += 22
            y_off += 10
            self.screen.blit(self.small_font.render(f"Found: {len(self.filtered_tiles)}", True, COLORS['SELECTION']), (pr[0] + 10, y_off)); y_off += 20
            item_h = 28; max_items = (self.screen_height - self.minimap_size - y_off - 150) // item_h
            visible_tiles = self.filtered_tiles[self.tile_list_scroll : self.tile_list_scroll + max_items]
            for i, tid in enumerate(visible_tiles):
                abs_idx = self.tile_list_scroll + i; btn_rect = pygame.Rect(pr[0] + 10, y_off, self.ui_width - 20, item_h - 3)
                if abs_idx == self.current_tile_idx: pygame.draw.rect(self.screen, (60, 60, 60), btn_rect); pygame.draw.rect(self.screen, COLORS['SELECTION'], btn_rect, 1)
                tex = self.ui_textures[tid]
                if self.current_rotation != 0: tex = pygame.transform.rotate(tex, self.current_rotation)
                if tex.get_width() > 24 or tex.get_height() > 24: tex = pygame.transform.scale(tex, (24, 24))
                self.screen.blit(tex, (btn_rect.x + 5, btn_rect.y + 2)); self.screen.blit(self.small_font.render(f"{tid}: {TILE_DATA[tid]['name']}", True, COLORS['TEXT']), (btn_rect.x + 35, btn_rect.y + 6))
                self.ui_rects[f"TILE_ABS_{abs_idx}"] = btn_rect; y_off += item_h
        else:
            for zid, info in ZONES.items():
                rect = pygame.Rect(pr[0] + 10, y_off, self.ui_width - 20, 25)
                if zid == self.selected_zone_id: pygame.draw.rect(self.screen, (60, 60, 60), rect); pygame.draw.rect(self.screen, COLORS['SELECTION'], rect, 1)
                pygame.draw.rect(self.screen, info['color'][:3], (rect.x + 5, rect.y + 5, 15, 15)); self.screen.blit(self.font.render(info['name'], True, COLORS['TEXT']), (rect.x + 30, rect.y + 2))
                self.ui_rects[f"ZONE_ID_{zid}"] = rect; y_off += 28
        gy = self.screen_height - self.minimap_size - 140
        for t in ["WASD: Cam | Wheel: Zoom", "L-Drag: Place | R-Drag: Erase", "B: Brush | C: Copy | V: Paste", "R: Rotate | 1/2/3: Layer", "Ctrl+S: Save | ESC: Menu"]: self.screen.blit(self.small_font.render(t, True, (180, 180, 180)), (pr[0] + 10, gy)); gy += 16

    def draw_minimap(self):
        mm_x, mm_y = self.screen_width - self.minimap_size - 20, self.screen_height - self.minimap_size - 20
        scale = min(self.minimap_size / self.map_width, self.minimap_size / self.map_height)
        self.mm_draw_rect = pygame.Rect(mm_x, mm_y, int(self.map_width * scale), int(self.map_height * scale))
        pygame.draw.rect(self.screen, (0, 0, 0), self.mm_draw_rect); pygame.draw.rect(self.screen, COLORS['UI_BORDER'], self.mm_draw_rect, 1)
        for y in range(self.map_height):
            for x in range(self.map_width):
                tid = self.layers['wall'][y][x][0]
                if tid == 0: tid = self.layers['floor'][y][x][0]
                if tid != 0 and tid in TILE_DATA: pygame.draw.rect(self.screen, TILE_DATA[tid]['color'], (int(mm_x + x * scale), int(mm_y + y * scale), max(1, int(scale)), max(1, int(scale))))
        vw, vh = self.screen_width / self.zoom, self.screen_height / self.zoom; clipped = pygame.Rect(int(mm_x + (self.camera_x / TILE_SIZE) * scale), int(mm_y + (self.camera_y / TILE_SIZE) * scale), int(vw / TILE_SIZE * scale), int(vh / TILE_SIZE * scale)).clip(self.mm_draw_rect)
        if clipped.width > 0: pygame.draw.rect(self.screen, (255, 255, 255), clipped, 1)

    def handle_ui_click(self, mx, my):
        for key, rect in self.ui_rects.items():
            if rect.collidepoint(mx, my):
                if key.startswith("LAYER_"): self.active_layer = key.replace("LAYER_", "").lower(); self.update_filtered_tiles()
                elif key.startswith("FILTER_"):
                    parts = key.split('_'); f_key = parts[1]; val = parts[2]
                    self.filters[f_key] = None if val == "ALL" else int(val); self.update_filtered_tiles()
                elif key.startswith("TILE_ABS_"): self.current_tile_idx = int(key.replace("TILE_ABS_", ""))
                elif key.startswith("ZONE_ID_"): self.selected_zone_id = int(key.replace("ZONE_ID_", ""))
                return

    def run(self):
        while self.running:
            self.handle_events(); self.screen.fill(COLORS['BG'])
            if self.state == 'MENU': self.draw_menu()
            elif self.state == 'INPUT_SIZE': self.draw_input_size()
            elif self.state == 'EDITOR': self.draw_editor()
            pygame.display.flip(); self.clock.tick(FPS)
        pygame.quit(); sys.exit()

if __name__ == "__main__": MapEditor().run()



################################################################################
 FILE: settings.py
################################################################################

--- [Code Analysis & Settings] ---
  [Global Variable] SCREEN_WIDTH = 1280
  [Global Variable] SCREEN_HEIGHT = 720
  [Global Variable] TILE_SIZE = 32
  [Global Variable] FPS = 60
  [Global Variable] SHARED_FONTS = {Dict with 0 keys}
  [Global Variable] MAX_PLAYERS = 15
  [Global Variable] MAX_SPECTATORS = 5
  [Global Variable] MAX_TOTAL_USERS = 20
  [Global Variable] DAILY_QUOTA = 5
  [Global Variable] WEATHER_TYPES = [List with 4 elements]
  [Global Variable] WEATHER_PROBS = [List with 4 elements]
  [Global Variable] SPEED_WALK = 3.2
  [Global Variable] SPEED_RUN = 4.8
  [Global Variable] SPEED_CROUCH = 1.5
  [Global Variable] BASE_SPEED_PPS = 192
  [Global Variable] POLICE_SPEED_MULTI = 1.25
  [Global Variable] NOISE_RADIUS = {Dict with 5 keys}
  [Global Variable] SOUND_INFO = {Dict with 21 keys}
  [Global Variable] SOUND_COLORS = Dynamic/Complex
  [Global Variable] VENDING_MACHINE_TID = 8321006
  [Global Variable] CCTV_TID = 7310011
  [Global Variable] DEFAULT_PHASE_DURATIONS = {Dict with 6 keys}
  [Global Variable] PHASE_SETTINGS = {Dict with 6 keys}
  [Global Variable] VISION_RADIUS = {Dict with 7 keys}
  [Global Variable] MAFIA_DETECT_RANGE = 200
  [Global Variable] TREASURE_CHEST_RATES = [List with 3 elements]
  [Global Variable] AP_COSTS = {Dict with 10 keys}
  [Global Variable] ITEMS = {Dict with 17 keys}
  [Global Variable] WORK_SEQ = {Dict with 4 keys}
  [Global Variable] MINIGAME_MAP = {Dict with 5 keys}
  [Global Variable] BED_TILES = [List with 2 elements]
  [Global Variable] ZONES = {Dict with 9 keys}
  [Global Variable] INDOOR_ZONES = [List with 3 elements]

--- [Full Source Code] ---
import pygame

SCREEN_WIDTH = 1280
SCREEN_HEIGHT = 720
TILE_SIZE = 32
FPS = 60

# [최적화] 전역 폰트 캐시 저장소 추가
SHARED_FONTS = {}

MAX_PLAYERS = 15
MAX_SPECTATORS = 5
MAX_TOTAL_USERS = 20
DAILY_QUOTA = 5

# [Update] Weather System
WEATHER_TYPES = ['CLEAR', 'RAIN', 'FOG', 'SNOW']
WEATHER_PROBS = [0.7, 0.1, 0.1, 0.1]

# [Update] Movement Speeds (Pixels per Frame at 60 FPS)
# Goal: 6 Tiles (192px) per Second -> 192 / 60 = 3.2
SPEED_WALK = 3.2      # Approx 6 Tiles/sec
SPEED_RUN = 4.8       # Approx 9 Tiles/sec
SPEED_CROUCH = 1.5    # Approx 3 Tiles/sec

BASE_SPEED_PPS = 192 # Base Pixels Per Second (Reference for UI)

POLICE_SPEED_MULTI = 1.25

NOISE_RADIUS = {
    'RUN': 10 * TILE_SIZE,
    'WALK': 6 * TILE_SIZE,
    'CROUCH': 1 * TILE_SIZE,
    'GUN': 25 * TILE_SIZE,
    'SCREAM': 15 * TILE_SIZE
}

# [Update] Enhanced Sound Information
# Key: Sound Type, Value: {base_rad: Tile Radius, color: (R, G, B)}
SOUND_INFO = {
    # [Movement]
    'FOOTSTEP': {'base_rad': 6, 'color': (200, 200, 200)},
    'THUD':     {'base_rad': 10, 'color': (150, 150, 150)}, # Run
    'RUSTLE':   {'base_rad': 4, 'color': (100, 200, 100)},  # Crouch/Bush
    
    # [Status]
    'HEARTBEAT':{'base_rad': 5, 'color': (200, 50, 50)},    # Anxiety
    'COUGH':    {'base_rad': 8, 'color': (200, 200, 100)},  # Pain
    'SCREAM':   {'base_rad': 15, 'color': (255, 0, 0)},     # Fear
    
    # [Environment/Door]
    'CREAK':    {'base_rad': 5, 'color': (180, 180, 180)},  # Open Door
    'SLAM':     {'base_rad': 8, 'color': (150, 150, 150)},  # Close Door
    'CLICK':    {'base_rad': 4, 'color': (200, 200, 200)},  # Lock/Unlock
    'BANG!':    {'base_rad': 12, 'color': (200, 50, 50)},   # Break/Impact
    'CRASH':    {'base_rad': 15, 'color': (200, 100, 50)},  # Destroy
    
    # [Item/Work]
    'GULP':     {'base_rad': 4, 'color': (100, 200, 255)},  # Drink
    'CRUNCH':   {'base_rad': 4, 'color': (200, 150, 50)},   # Eat
    'KA-CHING': {'base_rad': 5, 'color': (255, 215, 0)},    # Buy
    'TAP':      {'base_rad': 4, 'color': (200, 200, 200)},  # Work
    'BEEP':     {'base_rad': 4, 'color': (100, 255, 255)},  # Device
    
    # [Combat/Skill]
    'GUNSHOT':  {'base_rad': 25, 'color': (255, 200, 50)},
    'SLASH':    {'base_rad': 4, 'color': (255, 0, 0)},      # Knife
    'ZAP':      {'base_rad': 4, 'color': (100, 100, 255)},  # Taser
    'SIREN':    {'base_rad': 999, 'color': (0, 100, 255)},  # Global
    'BOOM':     {'base_rad': 999, 'color': (100, 100, 100)} # Global
}

# Compatibility
SOUND_COLORS = {k: v['color'] for k, v in SOUND_INFO.items()}
SOUND_COLORS['NOISE'] = (150, 150, 150)
SOUND_COLORS['TALK'] = (255, 255, 100)

VENDING_MACHINE_TID = 8321006
CCTV_TID = 7310011

DEFAULT_PHASE_DURATIONS = {
    'DAWN': 20,
    'MORNING': 20,
    'NOON': 40,
    'AFTERNOON': 40,
    'EVENING': 20,
    'NIGHT': 100
}

# [추가] 시간대별 조명 및 시야 설정
# alpha: 화면 어두움 정도 (0: 완전 밝음 ~ 255: 완전 암전)
# vision_factor: 시야 거리 비율 (1.0:멀리 ~ 0.0:코앞)
# clarity: 시야 내부 선명도 (255:선명 ~ 0:흐릿함/어두움) << [NEW]
PHASE_SETTINGS = {
    'DAWN':      {'alpha': 240, 'vision_factor': 0.0, 'clarity': 50}, 
    'MORNING':   {'alpha': 40,  'vision_factor': 0.8, 'clarity': 200}, 
    'NOON':      {'alpha': 0,   'vision_factor': 1.0, 'clarity': 255}, 
    'AFTERNOON': {'alpha': 20,  'vision_factor': 1.0, 'clarity': 255}, 
    'EVENING':   {'alpha': 150, 'vision_factor': 0.6, 'clarity': 180}, 
    'NIGHT':     {'alpha': 245, 'vision_factor': 0.0, 'clarity': 80}  
}

VISION_RADIUS = {
    'DAY': 12,
    'NIGHT_CITIZEN': 5,
    'NIGHT_POLICE_FLASH': 12,
    'NIGHT_MAFIA': 8,
    'BLACKOUT': 1.5,
    'DAWN': 0,
    'SPECTATOR': 40
}

MAFIA_DETECT_RANGE = 200

TREASURE_CHEST_RATES = [
    {'type': 'EMPTY', 'prob': 0.3, 'msg': "Empty..."},
    {'type': 'GOLD',  'prob': 0.6, 'amount': 3, 'msg': "Found 3 Gold!"},
    {'type': 'ITEM',  'prob': 0.1, 'items': ['TANGERINE', 'CHOCOBAR', 'BATTERY'], 'msg': "Found {item}!"}
]

AP_COSTS = {
    'WORK': 1, 'HEAL': 1, 'LOCKPICK': 1, 'REPAIR': 1, 'KILL': 1,
    'SEARCH': 2, 'BREAK_DOOR': 2, 'SABOTAGE': 5, 'SIREN': 5, 'INTERROGATE': 1
}

ITEMS = {
    'TANGERINE':    {'name': '귤', 'price': 3, 'desc': 'HP +2', 'key': pygame.K_1},
    'CHOCOBAR':     {'name': '초코바', 'price': 3, 'desc': 'AP +2', 'key': pygame.K_2},
    'TORTILLA':     {'name': '치즈또띠아', 'price': 7, 'desc': 'HP +3, AP +3', 'key': pygame.K_3},
    'MEDKIT':       {'name': '구급키트', 'price': 15, 'desc': 'HP Full Recovery', 'key': pygame.K_4},
    'ENERGY_DRINK': {'name': '에너지드링크', 'price': 10, 'desc': 'HP -3, Infinite Stamina (Night)', 'key': pygame.K_5},
    'PEANUT_BUTTER':{'name': '땅콩버터', 'price': 15, 'desc': 'Noise -30% (Night)', 'key': pygame.K_6},
    'COFFEE':       {'name': '커피', 'price': 8, 'desc': 'Job Speed x2', 'key': pygame.K_7},
    'PAINKILLER':   {'name': '진통제', 'price': 12, 'desc': 'Ignore Pain Penalty', 'key': pygame.K_8},
    'BATTERY':      {'name': '건전지', 'price': 3, 'desc': 'Battery +50%', 'key': pygame.K_9},
    'POWERBANK':    {'name': '보조배터리', 'price': 10, 'desc': 'Battery +100% (2 Uses)', 'key': pygame.K_0},
    'KEY':          {'name': '열쇠', 'price': 5, 'desc': 'Open Locked Door', 'key': pygame.K_MINUS},
    'MASTER_KEY':   {'name': '만능키', 'price': 20, 'desc': 'Open Locked Door (3 Uses)', 'key': pygame.K_EQUALS},
    'SMOKE_BOMB':   {'name': '연막탄', 'price': 10, 'desc': 'Auto-Smoke on Danger', 'key': None},
    'ARMOR':        {'name': '방탄방검복', 'price': 30, 'desc': 'Block 1 Attack', 'key': None},
    'POTION':       {'name': '소생약', 'price': 50, 'desc': 'Revive Next Morning', 'key': None},
    'TASER':        {'name': '테이저건', 'price': 25, 'desc': 'Stun Enemy 3s (1 Use)', 'key': None},
    'TRAP':         {'name': '덫', 'price': 10, 'desc': 'Place Trap (Stun 3s)', 'key': None}
}

WORK_SEQ = {
    'FARMER': [9312000, 9312001, 9312002], # Empty -> Sprout -> Harvest
    'MINER': [9322004, 9322005, 9322006],  # Ore -> Rubble -> Furnace
    'FISHER': [9312003, 9322007, 8320205], # Spot -> Cutting Board -> Fridge
    'DOCTOR': [9322008, 9322009, 9322011], # Microscope -> Surgery Table -> Computer
}

MINIGAME_MAP = {
    'FARMER': {0: 'MASHING', 1: 'CIRCLE', 2: 'TIMING'},
    'MINER': {0: 'MASHING', 1: 'CIRCLE', 2: 'TIMING'},
    'FISHER': {0: 'MASHING', 1: 'TIMING', 2: 'FREQUENCY'},
    'DOCTOR': {0: 'WIRING', 1: 'MEMORY', 2: 'CIRCLE'},
    'COMMON': {'LOCKPICK': 'WIRING', 'REPAIR': 'WIRING', 'BREAK': 'MASHING'}
}

BED_TILES = [8321211, 9322009]

# Hiding logic is now handled dynamically based on Tile ID structure (5th digit E)
# E=1: Passive Hide, E=2: Active Hide


ZONES = {
    0: {'name': 'None', 'color': (0, 0, 0, 0)},
    1: {'name': 'Spawn/Safety', 'color': (0, 255, 0, 50)},
    2: {'name': 'Work: Farmer', 'color': (255, 255, 0, 50)},
    3: {'name': 'Work: Miner', 'color': (150, 150, 150, 50)},
    4: {'name': 'Work: Fisher', 'color': (0, 0, 255, 50)},
    5: {'name': 'Mafia Hideout', 'color': (255, 0, 0, 50)},
    6: {'name': 'House/Residential', 'color': (200, 150, 100, 50)},
    7: {'name': 'Hospital/Medical', 'color': (255, 255, 255, 50)},
    8: {'name': 'Building/Indoor', 'color': (100, 100, 120, 50)}
}

INDOOR_ZONES = [6, 7, 8]


################################################################################
 FILE: states\__init__.py
################################################################################

--- [Code Analysis & Settings] ---
  (No specific structural elements found)

--- [Full Source Code] ---



################################################################################
 FILE: states\lobby_state.py
################################################################################

--- [Code Analysis & Settings] ---

  [Class] LobbyState
    [Method] __init__(self, game)
    [Method] enter(self, params)
    [Method] update(self, dt)
    [Method] draw(self, screen)
    [Method] handle_event(self, event)

--- [Full Source Code] ---
import pygame
import random
from core.base_state import BaseState
from managers.resource_manager import ResourceManager
from colors import COLORS
from settings import SCREEN_WIDTH, SCREEN_HEIGHT, MAX_PLAYERS, MAX_SPECTATORS, MAX_TOTAL_USERS, DEFAULT_PHASE_DURATIONS

class LobbyState(BaseState):
    def __init__(self, game):
        super().__init__(game)
        self.resource_manager = ResourceManager.get_instance()
        self.font = self.resource_manager.get_font('default')
        self.bold_font = self.resource_manager.get_font('bold')
        self.large_font = self.resource_manager.get_font('large')

        self.lobby_buttons = {}

        if 'participants' not in self.game.shared_data:
            self.game.shared_data['participants'] = [{'name': 'Player 1', 'type': 'PLAYER', 'role': 'RANDOM', 'group': 'PLAYER'}]
        self.participants = self.game.shared_data['participants']

        self.time_scale = 100  # Percentage (100 means 100% of DEFAULT_PHASE_DURATIONS)

    def enter(self, params=None):
        pass

    def update(self, dt):
        pass

    def draw(self, screen):
        self.lobby_buttons = {}
        screen.fill(COLORS['MENU_BG'])
        w, h = screen.get_width(), screen.get_height()
        mx, my = pygame.mouse.get_pos()

        player_group = [p for p in self.participants if p['group'] == 'PLAYER']
        spectator_group = [p for p in self.participants if p['group'] == 'SPECTATOR']

        left_area_x = 50
        left_area_w = 600
        start_y = 100

        title = self.large_font.render(f"PLAYERS ({len(player_group)}/{MAX_PLAYERS})", True, (100, 255, 100))
        screen.blit(title, (left_area_x, 40))

        for i, p in enumerate(player_group):
            pidx = self.participants.index(p)
            rect_obj = pygame.Rect(left_area_x, start_y + i*55, left_area_w, 45)
            pygame.draw.rect(screen, COLORS['SLOT_BG'], rect_obj)
            pygame.draw.rect(screen, (100, 100, 120), rect_obj, 1)

            p_txt = self.font.render(f"{p['name']} [{p['type']}]", True, (255, 255, 255))
            screen.blit(p_txt, (rect_obj.x + 15, rect_obj.y + 10))

            role_rect = pygame.Rect(rect_obj.right - 180, rect_obj.y + 7, 100, 30)
            r_col = COLORS['BUTTON_HOVER'] if role_rect.collidepoint(mx, my) else COLORS['ROLE_BTN']
            pygame.draw.rect(screen, r_col, role_rect)
            role_txt = self.font.render(p['role'], True, (255, 255, 0))
            screen.blit(role_txt, role_txt.get_rect(center=role_rect.center))
            self.lobby_buttons[f"ROLE_{pidx}"] = (role_rect, pidx)

            if len(spectator_group) < MAX_SPECTATORS:
                move_rect = pygame.Rect(rect_obj.right - 50, rect_obj.y + 7, 40, 30)
                m_col = (100, 100, 100) if move_rect.collidepoint(mx, my) else (60, 60, 60)
                pygame.draw.rect(screen, m_col, move_rect)
                m_txt = self.bold_font.render("->", True, (200, 200, 200))
                screen.blit(m_txt, m_txt.get_rect(center=move_rect.center))
                self.lobby_buttons[f"TO_SPEC_{pidx}"] = move_rect

        if len(player_group) < MAX_PLAYERS:
            add_rect = pygame.Rect(left_area_x, start_y + len(player_group)*55, 180, 40)
            a_col = COLORS['BUTTON_HOVER'] if add_rect.collidepoint(mx, my) else COLORS['BUTTON']
            pygame.draw.rect(screen, a_col, add_rect)
            screen.blit(self.font.render("+ ADD PLAYER BOT", True, (255, 255, 255)), (add_rect.x+20, add_rect.y+8))
            self.lobby_buttons['ADD_BOT_PLAYER'] = add_rect

        right_area_x = left_area_x + left_area_w + 50
        right_area_w = 400

        title_spec = self.large_font.render(f"SPECTATORS ({len(spectator_group)}/{MAX_SPECTATORS})", True, (150, 150, 255))
        screen.blit(title_spec, (right_area_x, 40))

        for i, p in enumerate(spectator_group):
            pidx = self.participants.index(p)
            rect_obj = pygame.Rect(right_area_x, start_y + i*55, right_area_w, 45)
            pygame.draw.rect(screen, (30, 30, 40), rect_obj)
            pygame.draw.rect(screen, (100, 100, 120), rect_obj, 1)

            if len(player_group) < MAX_PLAYERS:
                move_rect = pygame.Rect(rect_obj.x + 10, rect_obj.y + 7, 40, 30)
                m_col = (100, 100, 100) if move_rect.collidepoint(mx, my) else (60, 60, 60)
                pygame.draw.rect(screen, m_col, move_rect)
                m_txt = self.bold_font.render("<-", True, (200, 200, 200))
                screen.blit(m_txt, m_txt.get_rect(center=move_rect.center))
                self.lobby_buttons[f"TO_PLAYER_{pidx}"] = move_rect

            p_txt = self.font.render(f"{p['name']} [{p['type']}]", True, (200, 200, 200))
            screen.blit(p_txt, (rect_obj.x + 60, rect_obj.y + 10))

        if len(spectator_group) < MAX_SPECTATORS:
            add_rect = pygame.Rect(right_area_x, start_y + len(spectator_group)*55, 180, 40)
            a_col = COLORS['BUTTON_HOVER'] if add_rect.collidepoint(mx, my) else COLORS['BUTTON']
            pygame.draw.rect(screen, a_col, add_rect)
            screen.blit(self.font.render("+ ADD SPEC BOT", True, (255, 255, 255)), (add_rect.x+20, add_rect.y+8))
            self.lobby_buttons['ADD_BOT_SPEC'] = add_rect

        # Time Scale UI
        sx, sy = w - 450, h - 250
        pygame.draw.rect(screen, (30, 30, 40), (sx - 20, sy - 40, 420, 120))
        pygame.draw.rect(screen, (100, 100, 120), (sx - 20, sy - 40, 420, 120), 2)
        screen.blit(self.bold_font.render("TIME SETTINGS", True, (200, 200, 200)), (sx, sy - 30))

        screen.blit(self.font.render("TIME SCALE:", True, (255, 255, 255)), (sx, sy + 30))
        
        # Minus Button
        m_rect = pygame.Rect(sx + 150, sy + 25, 30, 30)
        pygame.draw.rect(screen, COLORS['BUTTON'], m_rect)
        screen.blit(self.bold_font.render("-", True, (255,255,255)), (m_rect.x+10, m_rect.y+5))
        self.lobby_buttons["SCALE_MINUS"] = m_rect

        # Scale Value
        val_txt = self.large_font.render(f"{self.time_scale}%", True, (0, 255, 0))
        screen.blit(val_txt, (sx + 200, sy + 20))

        # Plus Button
        p_rect = pygame.Rect(sx + 300, sy + 25, 30, 30)
        pygame.draw.rect(screen, COLORS['BUTTON'], p_rect)
        screen.blit(self.bold_font.render("+", True, (255,255,255)), (p_rect.x+8, p_rect.y+5))
        self.lobby_buttons["SCALE_PLUS"] = p_rect

        start_rect = pygame.Rect(w - 250, h - 100, 200, 60)
        s_col = (0, 150, 0) if start_rect.collidepoint(mx, my) else (0, 100, 0)
        pygame.draw.rect(screen, s_col, start_rect)
        pygame.draw.rect(screen, (255, 255, 255), start_rect, 2)
        screen.blit(self.large_font.render("START", True, (255, 255, 255)), (start_rect.x+55, start_rect.y+15))
        self.lobby_buttons['START'] = start_rect

    def handle_event(self, event):
        if event.type == pygame.MOUSEBUTTONDOWN:
            if event.button == 1:
                mx, my = event.pos
                btns = self.lobby_buttons

                if 'START' in btns and btns['START'].collidepoint(mx, my):
                    # Calculate durations based on Time Scale
                    scale = self.time_scale / 100.0
                    custom = {}
                    for k, v in DEFAULT_PHASE_DURATIONS.items():
                        custom[k] = int(v * scale)
                    
                    self.game.shared_data['custom_durations'] = custom

                    from states.play_state import PlayState
                    self.game.state_machine.change(PlayState(self.game))

                if 'ADD_BOT_PLAYER' in btns and btns['ADD_BOT_PLAYER'].collidepoint(mx, my):
                    if len(self.participants) < MAX_TOTAL_USERS:
                        self.participants.append({'name': f'Bot {len(self.participants)}', 'type': 'BOT', 'role': 'RANDOM', 'group': 'PLAYER'})

                if 'ADD_BOT_SPEC' in btns and btns['ADD_BOT_SPEC'].collidepoint(mx, my):
                    if len(self.participants) < MAX_TOTAL_USERS:
                        self.participants.append({'name': f'SpecBot {len(self.participants)}', 'type': 'BOT', 'role': 'RANDOM', 'group': 'SPECTATOR'})
                
                if 'SCALE_MINUS' in btns and btns['SCALE_MINUS'].collidepoint(mx, my):
                    self.time_scale = max(50, self.time_scale - 10)
                
                if 'SCALE_PLUS' in btns and btns['SCALE_PLUS'].collidepoint(mx, my):
                    self.time_scale = min(200, self.time_scale + 10)

                for k, v in btns.items():
                    if k.startswith("ROLE_") and v[0].collidepoint(mx, my):
                        roles = ["RANDOM", "FARMER", "MINER", "FISHER", "POLICE", "DOCTOR", "MAFIA"]
                        p = self.participants[v[1]]
                        if p['group'] == 'PLAYER':
                            curr_idx = roles.index(p['role']) if p['role'] in roles else 0
                            p['role'] = roles[(curr_idx+1)%len(roles)]

                    elif k.startswith("TO_SPEC_") and v.collidepoint(mx, my):
                        idx = int(k.replace("TO_SPEC_", ""))
                        self.participants[idx]['group'] = 'SPECTATOR'

                    elif k.startswith("TO_PLAYER_") and v.collidepoint(mx, my):
                        idx = int(k.replace("TO_PLAYER_", ""))
                        self.participants[idx]['group'] = 'PLAYER'


################################################################################
 FILE: states\menu_state.py
################################################################################

--- [Code Analysis & Settings] ---

  [Class] MenuState
    [Method] __init__(self, game)
    [Method] enter(self, params)
    [Method] update(self, dt)
    [Method] draw(self, screen)
    [Method] handle_event(self, event)

--- [Full Source Code] ---
import pygame
from core.base_state import BaseState
from managers.resource_manager import ResourceManager
from colors import COLORS
from settings import SCREEN_WIDTH, SCREEN_HEIGHT

class MenuState(BaseState):
    def __init__(self, game):
        super().__init__(game)
        self.resource_manager = ResourceManager.get_instance()
        self.buttons = {}
        self.title_font = self.resource_manager.get_font('title')
        self.large_font = self.resource_manager.get_font('large')

    def enter(self, params=None):
        pass

    def update(self, dt):
        pass

    def draw(self, screen):
        screen.fill(COLORS['MENU_BG'])
        w, h = screen.get_width(), screen.get_height()


        title_surf = self.title_font.render("PIXEL NIGHT", True, (255, 255, 255))
        title_rect = title_surf.get_rect(center=(w // 2, h // 3))
        screen.blit(title_surf, title_rect)


        btn_rect = pygame.Rect(w // 2 - 150, h // 2, 300, 60)
        mx, my = pygame.mouse.get_pos()

        is_hover = btn_rect.collidepoint(mx, my)
        col = COLORS['BUTTON_HOVER'] if is_hover else COLORS['BUTTON']

        pygame.draw.rect(screen, col, btn_rect)
        pygame.draw.rect(screen, (255, 255, 255), btn_rect, 2)

        txt_surf = self.large_font.render("START MISSION", True, (255, 255, 255))
        txt_rect = txt_surf.get_rect(center=btn_rect.center)
        screen.blit(txt_surf, txt_rect)

        self.buttons['Start'] = btn_rect

    def handle_event(self, event):
        if event.type == pygame.MOUSEBUTTONDOWN:
            if event.button == 1:
                mx, my = event.pos
                if 'Start' in self.buttons and self.buttons['Start'].collidepoint(mx, my):

                    from states.lobby_state import LobbyState
                    self.game.state_machine.change(LobbyState(self.game))



################################################################################
 FILE: states\play_state.py
################################################################################

--- [Code Analysis & Settings] ---

  [Class] PlayState
    [Method] __init__(self, game)
    [Method] create_light_surface(self, radius)
    [Method] create_smooth_gradient(self, radius)
    [Method] enter(self, params)
    [Method] find_safe_spawn(self)
    [Method] init_game_objects(self)
    [Method] update(self, dt)
    [Method] _update_spectator_camera(self)
    [Method] _advance_phase(self)
    [Method] execute_siren(self)
    [Method] execute_sabotage(self)
    [Method] execute_gunshot(self, shooter, target_pos)
    [Method] trigger_sabotage(self)
    [Method] trigger_siren(self)
    [Method] _handle_npc_action(self, action, n, now)
    [Method] _process_sound_effect(self, f)
    [Method] _handle_v_action(self)
    [Method] _process_voting_results(self)
    [Method] draw(self, screen)
    [Method] handle_event(self, event)

--- [Full Source Code] ---
import pygame
import random
import math
from core.base_state import BaseState
from settings import *
from world.map_manager import MapManager
from entities.player import Player, Bullet
from entities.npc import Dummy
from systems.camera import Camera
from systems.fov import FOV
from systems.effects import VisualSound, SoundDirectionIndicator
from systems.renderer import CharacterRenderer, MapRenderer
from world.tiles import get_texture
from colors import COLORS
from managers.resource_manager import ResourceManager
from ui import UI

class PlayState(BaseState):
    def __init__(self, game):
        super().__init__(game)
        self.logger = game.logger
        self.resource_manager = ResourceManager.get_instance()

        self.map_manager = MapManager()
        self.map_renderer = None
        self.camera = None
        self.fov = None

        self.player = None
        self.npcs = []
        self.effects = []
        self.indicators = []
        self.noise_list = []
        self.bloody_footsteps = []
        self.visible_tiles = set()
        
        # [추가] 타일의 밝기(Alpha)를 저장할 딕셔너리
        self.tile_alphas = {} 

        self.day_count = 1
        self.phases = ["DAWN", "MORNING", "NOON", "AFTERNOON", "EVENING", "NIGHT"]
        self.current_phase_idx = 0
        self.current_phase = self.phases[0]
        self.state_timer = 30
        self.is_blackout = False
        self.blackout_timer = 0
        self.is_mafia_frozen = False
        self.frozen_timer = 0
        self.has_murder_occurred = False
        self.is_revealed = False
        self.daily_news_log = []
        self.mafia_last_seen_zone = None 

        self.light_img = self.create_light_surface(TILE_SIZE * 3)
        self.zoom_level = 1.5
        
        # [수정] 렌더링 최적화 및 마스킹용 Surface 미리 생성
        self.canvas = None
        self.last_canvas_size = (0, 0)
        self.dark_surface = None
        self.light_mask = None     # 빛의 모양을 잡을 마스크
        self.gradient_halo = None  # 부드러운 그라데이션 이미지

        # [추가] 부드러운 그라데이션 이미지 생성 (한 번만 생성해서 재사용)
        # 충분히 큰 사이즈로 생성 (예: 화면 대각선 길이)
        max_radius = 1000 
        self.gradient_halo = self.create_smooth_gradient(max_radius)

        self.ui = None
        
        # [New] Chat System
        self.is_chatting = False
        self.chat_text = ""
        
        # [New] Vote UI
        self.show_vote_ui = False
        self.my_vote_target = None
        self.vote_btn_rect = None
        self.candidate_rects = []

        # [New] Weather Particles
        self.weather_particles = [] # [x, y, speed, type]
        for _ in range(100):
            self.weather_particles.append([
                random.randint(0, self.game.screen_width),
                random.randint(0, self.game.screen_height),
                random.randint(5, 10),
                random.choice([0, 1]) # 0: Rain, 1: Snow
            ])

        # [New] Emotion Timers
        self.heartbeat_timer = 0
        self.blink_timer = 0
        
        # [추가] 현재 밝기 및 시야 계수
        self.current_ambient_alpha = 0
        self.current_vision_factor = 1.0
        self.current_clarity = 255

        # [추가] 전체 화면 효과용 Surface 미리 생성
        self.effect_surf = pygame.Surface((self.game.screen_width, self.game.screen_height), pygame.SRCALPHA)

    def create_light_surface(self, radius):
        surf = pygame.Surface((radius * 2, radius * 2), pygame.SRCALPHA)
        for r in range(radius, 0, -2):
            alpha = int(255 * (r / radius)**2)
            pygame.draw.circle(surf, (alpha, alpha, alpha, alpha), (radius, radius), r)
        return surf

    # [추가] 고품질 그라데이션 생성 함수
    def create_smooth_gradient(self, radius):
        surf = pygame.Surface((radius * 2, radius * 2), pygame.SRCALPHA)
        # 중심(255)에서 외곽(0)으로 떨어지는 부드러운 그라데이션
        for r in range(radius, 0, -2):
            # 2차 함수(Square)를 사용하여 더 부드러운 감쇠 효과 (Linear보다 자연스러움)
            ratio = r / radius
            alpha = int(255 * (1 - ratio * ratio)) # Center bright, edge dark
            pygame.draw.circle(surf, (255, 255, 255, alpha), (radius, radius), r)
        return surf

    def enter(self, params=None):
        self.logger.info("PLAY", "Entering PlayState...")

        self.map_manager.load_map("map.json")
        self.map_renderer = MapRenderer(self.map_manager)

        self.camera = Camera(self.game.screen_width, self.game.screen_height, self.map_manager.width, self.map_manager.height)
        self.camera.set_bounds(self.map_manager.width * TILE_SIZE, self.map_manager.height * TILE_SIZE)
        self.camera.set_zoom(self.zoom_level)
        self.fov = FOV(self.map_manager.width, self.map_manager.height, self.map_manager)

        self.init_game_objects()

        self.ui = UI(self)

        self.day_count = 1
        self.current_phase_idx = 0
        self.current_phase = self.phases[0]
        durations = self.game.shared_data.get('custom_durations', DEFAULT_PHASE_DURATIONS)
        self.ui.custom_durations = durations
        self.state_timer = durations.get(self.current_phase, 30)
        
        # [Update] Weather System
        from settings import WEATHER_TYPES, WEATHER_PROBS
        self.weather = random.choices(WEATHER_TYPES, weights=WEATHER_PROBS, k=1)[0]
        self.logger.info("GAME", f"Weather set to: {self.weather}")
        if self.weather == 'RAIN': self.ui.show_alert("It's Raining...", (100, 100, 255))
        elif self.weather == 'FOG': self.ui.show_alert("Dense Fog...", (150, 150, 150))
        elif self.weather == 'SNOW': self.ui.show_alert("It's Snowing...", (200, 200, 255))

    def find_safe_spawn(self):
        c = self.map_manager.get_spawn_points(zone_id=1)
        return random.choice(c) if c else (100, 100)

    def init_game_objects(self):
        participants = self.game.shared_data.get('participants', [])
        cit_jobs = ["FARMER", "MINER", "FISHER"]

        random_indices = [i for i, p in enumerate(participants) if p['group'] == 'PLAYER' and p['role'] == 'RANDOM']
        if random_indices:
            r_pool = ["MAFIA", "POLICE", "DOCTOR"]
            while len(r_pool) < len(random_indices): r_pool.append("CITIZEN")
            if len(participants) >= 4 and "MAFIA" not in [p['role'] for p in participants if p['role'] != 'RANDOM']:
                if "MAFIA" not in r_pool: r_pool[0] = "MAFIA"
            
            random.shuffle(r_pool)
            for p in participants:
                if p['role'] in r_pool: r_pool.remove(p['role'])
            random.shuffle(random_indices)
            for idx in random_indices:
                if r_pool: participants[idx]['role'] = r_pool.pop(0)
                else: participants[idx]['role'] = random.choice(cit_jobs)

        sx, sy = self.find_safe_spawn()
        self.player = Player(sx, sy, self.map_manager.width, self.map_manager.height, None, self.map_manager.zone_map, map_manager=self.map_manager)
        self.player.is_player = True

        my_data = next((p for p in participants if p['type'] == 'PLAYER'), None)
        if my_data:
            self.player.name = my_data['name']
            if my_data['group'] == 'SPECTATOR':
                self.player.change_role("SPECTATOR")
            else:
                if my_data['role'] in cit_jobs: self.player.change_role("CITIZEN", my_data['role'])
                else: self.player.change_role(my_data['role'])

        self.npcs = []
        for p in participants:
            if p['type'] == 'BOT':
                if p['group'] == 'SPECTATOR':
                    pass
                else:
                    nx, ny = self.find_safe_spawn()
                    rt = "CITIZEN" if p['role'] in cit_jobs else p['role']
                    n = Dummy(nx, ny, None, self.map_manager.width, self.map_manager.height, name=p['name'], role=rt, zone_map=self.map_manager.zone_map, map_manager=self.map_manager)
                    if p['role'] in cit_jobs: n.sub_role = p['role']
                    
                    # [추가] 투표 로직을 위한 변수 안전 초기화
                    n.vote_count = 0 
                    
                    self.npcs.append(n)

    def update(self, dt):
        if not self.player: return

        # [추가] 게임 오버 처리
        if self.player.is_dead and self.player.role != "SPECTATOR":
            self.logger.info("GAME", "PLAYER DIED - GAME OVER")
            self.ui.show_alert("YOU DIED!", (255, 0, 0))
            self.player.change_role("SPECTATOR")
            # 추가적인 게임 오버 UI나 상태 전환 로직이 있다면 여기에 추가

        # [대규모 개편] 시간 흐름에 따른 밝기/시야 이중 보간 시스템
        
        # 1. 현재/다음 페이즈 정보 가져오기
        current_phase_key = self.current_phase
        next_phase_idx = (self.current_phase_idx + 1) % len(self.phases)
        next_phase_key = self.phases[next_phase_idx]
        
        # 설정값 로드
        curr_cfg = PHASE_SETTINGS.get(current_phase_key, PHASE_SETTINGS['NOON'])
        next_cfg = PHASE_SETTINGS.get(next_phase_key, PHASE_SETTINGS['NOON'])

        # 2. 진행률(Progress) 계산 (0.0 ~ 1.0)
        durations = self.game.shared_data.get('custom_durations', DEFAULT_PHASE_DURATIONS)
        total_time = durations.get(current_phase_key, 60)
        progress = 1.0 - (self.state_timer / max(total_time, 1))
        progress = max(0.0, min(1.0, progress)) # 0~1 사이로 제한

        # 3. [핵심] 밝기(Alpha)와 시야율(Factor) 독립 보간
        # 현재 설정에서 다음 설정으로 서서히 변해갑니다.
        
        # (A) 밝기 계산
        self.current_ambient_alpha = curr_cfg['alpha'] + (next_cfg['alpha'] - curr_cfg['alpha']) * progress
        
        # (B) 시야율 계산
        self.current_vision_factor = curr_cfg['vision_factor'] + (next_cfg['vision_factor'] - curr_cfg['vision_factor']) * progress
        
        # [NEW] 선명도 보간
        # 예: 저녁(180) -> 밤(80)으로 서서히 어두워짐
        self.current_clarity = curr_cfg.get('clarity', 255) + (next_cfg.get('clarity', 255) - curr_cfg.get('clarity', 255)) * progress

        now = pygame.time.get_ticks()
        self.noise_list = []
        
        # [수정] 카메라 크기를 실제 화면 크기로 설정 (Camera 클래스 내부에서 Zoom 계산 수행)
        if self.camera:
            self.camera.resize(self.game.screen_width, self.game.screen_height)

        if not self.player.is_dead:
            # Block input if Chatting or UI open
            if not (self.ui.show_vending or self.ui.show_inventory or self.ui.show_voting or self.is_chatting):
                if not self.player.is_stunned():
                    fx = self.player.update(self.current_phase, self.npcs, self.is_blackout, self.weather)
                    if fx:
                        for f in fx: self._process_sound_effect(f)

                    for p in self.player.popups:
                        if p['text'] == "OPEN_SHOP":
                            self.ui.toggle_vending_machine()
                            self.player.popups.remove(p); break

                self.player.update_bullets(self.npcs)

        # [Update] Weather Particle Movement
        if self.weather in ['RAIN', 'SNOW']:
            # 현재 창의 실제 크기를 가져옴
            current_w, current_h = pygame.display.get_surface().get_size()
            for p in self.weather_particles:
                p[1] += p[2]
                if self.weather == 'RAIN': p[0] -= 1
                
                # 현재 화면 높이를 벗어나면 재설정
                if p[1] > current_h:
                    p[1] = -10
                    # 현재 화면 너비 안에서 랜덤 위치로 재설정
                    p[0] = random.randint(0, current_w)

        # [New] Emotion System Logic
        if self.player.role in ["CITIZEN", "DOCTOR", "FARMER", "MINER", "FISHER"]:
            # 1. Anxiety (Heartbeat)
            if self.current_phase == "NIGHT":
                nearest_dist = float('inf')
                for n in self.npcs:
                    if n.role == "MAFIA" and n.alive:
                        d = math.hypot(n.rect.centerx - self.player.rect.centerx, n.rect.centery - self.player.rect.centery)
                        if d < nearest_dist: nearest_dist = d
                
                if nearest_dist < 640:
                    intensity = int((640 - nearest_dist) / 60)
                    self.player.status_effects['ANXIETY'] = intensity
                    beat_interval = max(300, int(nearest_dist * 2))
                    if now - self.heartbeat_timer > beat_interval:
                        self.heartbeat_timer = now
                        self.effects.append(VisualSound(self.player.rect.centerx, self.player.rect.centery, "THUMP", (100, 0, 0), size_scale=0.5))
                else: self.player.status_effects['ANXIETY'] = 0
            else: self.player.status_effects['ANXIETY'] = 0

            # 2. Fatigue (Low AP)
            self.player.status_effects['FATIGUE'] = (self.player.ap <= 5)

            # 3. Pain (Low HP)
            if self.player.hp <= 5:
                self.player.status_effects['PAIN'] = True
                self.player.is_hiding = False
                if random.random() < 0.02:
                    self.effects.append(VisualSound(self.player.rect.centerx, self.player.rect.centery, "GROAN...", (200, 200, 200), 1.0))
            else: self.player.status_effects['PAIN'] = False

        # Record Mafia Location randomly during Night for Daily News
        if self.current_phase == "NIGHT" and random.random() < 0.005:
            for n in self.npcs:
                if n.role == "MAFIA" and n.alive:
                    gx, gy = int(n.rect.centerx // TILE_SIZE), int(n.rect.centery // TILE_SIZE)
                    if 0 <= gy < self.map_manager.height and 0 <= gx < self.map_manager.width:
                        zid = self.map_manager.zone_map[gy][gx]
                        if zid in ZONES and zid != 1: # Ignore Spawn
                            self.mafia_last_seen_zone = ZONES[zid]['name']

        for n in self.npcs:
            if n.is_stunned(): continue
            action = n.update(self.current_phase, self.player, self.npcs, self.is_mafia_frozen, self.noise_list, self.day_count, self.bloody_footsteps)
            self._handle_npc_action(action, n, now)

        if self.is_blackout and now > self.blackout_timer: self.is_blackout = False
        if self.is_mafia_frozen and now > self.frozen_timer: self.is_mafia_frozen = False

        self.map_manager.update_doors(dt, [self.player] + self.npcs)
        self.bloody_footsteps = [bf for bf in self.bloody_footsteps if now < bf[2]]

        if self.player.role == "SPECTATOR":
            self._update_spectator_camera()
        else:
            self.camera.update(self.player.rect.centerx, self.player.rect.centery)

        for e in self.effects[:]: e.update()
        self.effects = [e for e in self.effects if e.alive]
        
        for i in self.indicators[:]: 
            i.update()
            if not i.alive: self.indicators.remove(i)

        durations = self.game.shared_data.get('custom_durations', DEFAULT_PHASE_DURATIONS)
        total_dur = durations.get(self.current_phase, 60)
        
        # [수정] 어둠 지수 기반 시야 반경 계산
        rad = self.player.get_vision_radius(self.current_vision_factor, self.is_blackout, self.weather)
        
        direction = None
        angle = 60
        if self.player.role == "POLICE" and self.player.flashlight_on and self.current_phase in ['EVENING', 'NIGHT', 'DAWN']:
            direction = self.player.facing_dir
            
        self.visible_tiles = self.fov.cast_rays(self.player.rect.centerx, self.player.rect.centery, rad, direction, angle)

        # 2. [추가] 시야 페이드 효과 (렌더링용)
        fade_speed = 15 # 프레임당 투명도 변화량 (조절 가능)
        
        # 현재 보이는 타일은 투명도 증가 (밝게)
        for tile in self.visible_tiles:
            current_alpha = self.tile_alphas.get(tile, 0)
            if current_alpha < 255:
                self.tile_alphas[tile] = min(255, current_alpha + fade_speed)
        
        # 안 보이는 타일은 투명도 감소 (어둡게)
        # 딕셔너리 변경 에러 방지를 위해 list로 키 복사
        for tile in list(self.tile_alphas.keys()):
            if tile not in self.visible_tiles:
                self.tile_alphas[tile] -= fade_speed
                if self.tile_alphas[tile] <= 0:
                    del self.tile_alphas[tile] # 완전히 어두워지면 제거

        self.state_timer -= dt
        if self.state_timer <= 0:
            self._advance_phase()

    def _update_spectator_camera(self):
        keys = pygame.key.get_pressed()
        cam_dx, cam_dy = 0, 0
        cam_speed = 15

        if keys[pygame.K_LEFT]: cam_dx = -cam_speed
        if keys[pygame.K_RIGHT]: cam_dx = cam_speed
        if keys[pygame.K_UP]: cam_dy = -cam_speed
        if keys[pygame.K_DOWN]: cam_dy = cam_speed

        if cam_dx != 0 or cam_dy != 0:
            self.ui.spectator_follow_target = None
            self.camera.move(cam_dx, cam_dy)
        elif self.ui.spectator_follow_target:
            t = self.ui.spectator_follow_target
            if t.alive: self.camera.update(t.rect.centerx, t.rect.centery)
            else: self.ui.spectator_follow_target = None

    def _advance_phase(self):
        if self.current_phase == "AFTERNOON":
            self.show_vote_ui = False
            self._process_voting_results()

        self.current_phase_idx = (self.current_phase_idx + 1) % len(self.phases)
        self.current_phase = self.phases[self.current_phase_idx]

        if self.current_phase == "MORNING":
            self.day_count += 1
            
            # 플레이어가 실내 구역에 있는지 확인
            gx, gy = int(self.player.rect.centerx // TILE_SIZE), int(self.player.rect.centery // TILE_SIZE)
            is_indoors = False
            
            # 맵 범위 체크 및 구역 확인
            if 0 <= gx < self.map_manager.width and 0 <= gy < self.map_manager.height:
                if self.map_manager.zone_map[gy][gx] in INDOOR_ZONES:
                    is_indoors = True
            
            self.player.morning_process(is_indoors)
            for n in self.npcs: n.morning_process()
            self.has_murder_occurred = False
            
            # [Update] Daily News Logic
            if self.mafia_last_seen_zone:
                self.daily_news_log.append(f"Suspicious activity detected near {self.mafia_last_seen_zone}.")
                self.mafia_last_seen_zone = None
            
            self.ui.show_daily_news(self.daily_news_log)
            self.daily_news_log = []

        durations = self.game.shared_data.get('custom_durations', DEFAULT_PHASE_DURATIONS)
        self.state_timer = durations.get(self.current_phase, 30)

    def execute_siren(self):
        count = 0
        for n in self.npcs:
            if n.role == "MAFIA" and n.alive:
                n.is_frozen = True
                n.frozen_timer = pygame.time.get_ticks() + 5000
                count += 1
                self.effects.append(VisualSound(n.rect.centerx, n.rect.centery, "SIREN", (0, 0, 255), 2.0))
        
        self.is_mafia_frozen = True
        self.frozen_timer = pygame.time.get_ticks() + 5000

        if self.player.role == "MAFIA" and self.player.alive:
             self.player.add_popup("FROZEN BY SIREN!", (0, 0, 255))

        self.logger.info("GAME", f"Siren Triggered! {count} Mafias frozen.")
        self.daily_news_log.append("Last night, the Police used the Siren to freeze Mafias!")
        self.ui.show_alert("!!! SIREN !!!", (100, 100, 255))

    def execute_sabotage(self):
        self.is_blackout = True
        self.blackout_timer = pygame.time.get_ticks() + 10000
        self.logger.info("GAME", "Sabotage Triggered! Blackout started.")
        self.effects.append(VisualSound(self.player.rect.centerx, self.player.rect.centery, "BOOM", (50, 50, 50), 3.0))
        self.daily_news_log.append("마피아, 사회에 공포 조성!!")
        self.ui.show_alert("!!! SABOTAGE !!!", (255, 0, 0))
        
        targets = [n for n in self.npcs if n.role in ["CITIZEN", "DOCTOR"]]
        if self.player.role in ["CITIZEN", "DOCTOR"]: targets.append(self.player)
        
        for t in targets:
            if t.alive:
                t.emotions['FEAR'] = 1
                if t.is_hiding:
                    t.is_hiding = False
                    t.hiding_type = 0
                    t.add_popup("REVEALED!", (255, 0, 0))

    def execute_gunshot(self, shooter, target_pos=None):
        start_x, start_y = shooter.rect.centerx, shooter.rect.centery
        angle = 0
        if target_pos:
            dx, dy = target_pos[0] - start_x, target_pos[1] - start_y
            angle = math.atan2(dy, dx)
        else:
            angle = math.atan2(shooter.facing_dir[1], shooter.facing_dir[0])
            
        is_enemy = (shooter.role != "PLAYER")
        self.player.bullets.append(Bullet(start_x, start_y, angle, is_enemy=is_enemy))
        self.effects.append(VisualSound(start_x, start_y, "BANG!", (255, 200, 50), 2.0))
        if shooter.role == "POLICE":
             self.daily_news_log.append(f"Gunshots fired by Police near {shooter.name}.")

    def trigger_sabotage(self): self.execute_sabotage()
    def trigger_siren(self): self.execute_siren()

    def _handle_npc_action(self, action, n, now):
        if action == "USE_SIREN":
            self.execute_siren()
        elif action == "USE_SABOTAGE":
            self.execute_sabotage()
        elif action == "SHOOT_TARGET" and n.chase_target:
            self.execute_gunshot(n, (n.chase_target.rect.centerx, n.chase_target.rect.centery))
        elif action == "MURDER_OCCURRED":
            self.has_murder_occurred = True
            self.daily_news_log.append("A tragic murder occurred last night.")
        elif action == "FOOTSTEP":
            # [Update] NPC Footsteps integrated with the Sound System
            from settings import TILE_SIZE
            radius = 6 * TILE_SIZE
            if hasattr(self, 'weather') and self.weather == 'RAIN':
                radius *= 0.8
            
            # Send (Type, X, Y, Radius, Role)
            sound_data = ("FOOTSTEP", n.rect.centerx, n.rect.centery, radius, n.role)
            self._process_sound_effect(sound_data)

    def _process_sound_effect(self, f):
        # Data Unpacking (Compatible with 4 or 5 arguments)
        if len(f) == 5:
            s_type, fx_x, fx_y, rad, source_role = f
        else:
            s_type, fx_x, fx_y, rad = f
            source_role = "UNKNOWN"

        if hasattr(self, 'weather') and self.weather == 'RAIN': rad *= 0.8

        dist = math.sqrt((self.player.rect.centerx - fx_x)**2 + (self.player.rect.centery - fx_y)**2)
        
        # Check hearing range (1.5x of radius)
        if dist < rad * 1.5:
            from settings import SOUND_INFO, TILE_SIZE
            
            # Get Base Info
            info = SOUND_INFO.get(s_type, {'base_rad': 5, 'color': (200, 200, 200)})
            base_color = info['color']
            
            my_role = self.player.role
            importance = 1.0
            final_color = base_color
            shake = False
            blink = False
            
            # --- [Listener-Speaker Importance Logic] ---
            
            # 1. Citizen/Doctor (Escaper) Viewpoint
            if my_role in ["CITIZEN", "DOCTOR"]:
                if source_role == "MAFIA":
                    importance = 2.0
                    final_color = (255, 50, 50) # Red (Danger)
                    shake = True # [Added] Shake for Mafia sounds
                    if s_type in ["BANG!", "SLASH", "SCREAM", "GUNSHOT"]: importance = 2.5
                elif source_role == "POLICE":
                    importance = 1.5
                    final_color = (50, 150, 255) # Blue (Rescue)
            
            # 2. Mafia (Predator) Viewpoint
            elif my_role == "MAFIA":
                if source_role == "POLICE":
                    importance = 2.5
                    final_color = (200, 50, 255) # Purple (Warning)
                    blink = True # [Added] Blink for Police sounds
                    if s_type == "SIREN": importance = 3.0
                elif source_role in ["CITIZEN", "DOCTOR"]:
                    importance = 1.5
                    final_color = (255, 255, 100) # Yellow (Prey)
            
            # 3. Police (Chaser) Viewpoint
            elif my_role == "POLICE":
                if source_role == "MAFIA":
                    importance = 2.0
                    final_color = (255, 150, 0) # Orange (Target)
                elif source_role in ["CITIZEN", "DOCTOR"]:
                    importance = 0.6 # Low importance (Noise)

            # Global sounds
            if s_type in ["SIREN", "BOOM"]: 
                importance = 2.5
                blink = True

            # --- [Size Calculation & Clamping] ---
            # Distance Falloff: Closer is bigger
            dist_factor = 1.0 - (dist / (rad * 1.5))
            dist_factor = max(0.2, dist_factor)
            
            # Base Scale (based on radius)
            base_scale = (rad / (6 * TILE_SIZE))
            
            # Final Scale = base * importance * distance
            final_scale = base_scale * importance * dist_factor
            
            # [Clamp] Limit max size to prevent blocking view (Max 2.5x)
            final_scale = max(0.5, min(2.5, final_scale))

            self.effects.append(VisualSound(fx_x, fx_y, s_type, final_color, size_scale=final_scale, shake=shake, blink=blink))
            self.indicators.append(SoundDirectionIndicator(fx_x, fx_y))

    def _handle_v_action(self):
        if not self.player.alive: return
        
        targets = []
        action_range = 100
        
        for n in self.npcs:
            if not n.alive: continue
            dist = math.hypot(n.rect.centerx - self.player.rect.centerx, n.rect.centery - self.player.rect.centery)
            if dist <= action_range:
                targets.append((dist, n))
        
        targets.sort(key=lambda x: x[0])
        closest_target = targets[0][1] if targets else None
        
        if self.player.role == "DOCTOR":
            res = self.player.do_heal(closest_target)
            if res:
                if isinstance(res, tuple):
                    msg, sound = res
                    if msg: self.player.add_popup(msg, (200, 200, 255))
                    if sound: self._process_sound_effect(sound)
                else:
                    self.player.add_popup(res, (200, 200, 255))
        else:
            res = self.player.do_attack(closest_target)
            if res:
                # Format: (msg_data, sound_data)
                popup_data, sound_data = res
                self.player.add_popup(popup_data[0], (255, 50, 50))
                if sound_data:
                    self._process_sound_effect(sound_data)
                    # For news logging
                    if "GUNSHOT" in popup_data[0]:
                        self.daily_news_log.append("Gunshots heard!")

    def _process_voting_results(self):
        if self.my_vote_target:
            self.my_vote_target.vote_count += 1
            self.my_vote_target = None

        for n in self.npcs:
            if n.alive and random.random() < 0.3:
                target = random.choice([self.player] + [x for x in self.npcs if x.alive])
                target.vote_count += 1

        candidates = [self.player] + self.npcs
        candidates.sort(key=lambda x: x.vote_count, reverse=True)
        
        # [수정] 동점자 처리 공정성 확보
        if candidates:
            max_votes = candidates[0].vote_count
            
            if max_votes >= 2:
                # 동점자 리스트 확보
                top_candidates = [c for c in candidates if c.vote_count == max_votes]
                # 무작위 선택
                top = random.choice(top_candidates)
                
                top.is_dead = True
                role_reveal = top.role
                news_msg = f"BREAKING NEWS: {top.name} was EXECUTED! And he was a [{role_reveal}]."
                self.daily_news_log.append(news_msg) 
                # User code uses chat log for immediate feedback
                self.player.add_popup("EXECUTION!", (255, 0, 0))
                self.effects.append(VisualSound(self.player.rect.centerx, self.player.rect.centery - 50, "EXECUTION!", (255, 0, 0), 5.0))
                self.effects.append(VisualSound(top.rect.centerx, top.rect.centery, "DEAD", (150, 0, 0), 3.0))
            else:
                self.player.add_popup("Vote Failed", (200, 200, 200))

        for c in candidates: c.vote_count = 0

    def draw(self, screen):
        screen.fill(COLORS['BG'])

        if not self.camera: return

        vw, vh = int(self.game.screen_width / self.zoom_level), int(self.game.screen_height / self.zoom_level)
        
        # [Optimization] Surface Caching: Recreate only when size changes
        if self.canvas is None or self.last_canvas_size != (vw, vh):
            self.canvas = pygame.Surface((vw, vh))
            self.dark_surface = pygame.Surface((vw, vh), pygame.SRCALPHA)
            self.light_mask = pygame.Surface((vw, vh), pygame.SRCALPHA) # 마스크 초기화
            self.last_canvas_size = (vw, vh)
            
        self.canvas.fill(COLORS['BG'])

        sc = int(max(0, self.camera.x // TILE_SIZE))
        ec = int(min(self.map_manager.width, (self.camera.x + vw) // TILE_SIZE + 2))
        sr = int(max(0, self.camera.y // TILE_SIZE))
        er = int(min(self.map_manager.height, (self.camera.y + vh) // TILE_SIZE + 2))

        # [최적화] MapRenderer 사용
        if self.map_renderer:
            self.map_renderer.draw(self.canvas, self.camera, 0)

        # [수정] 핀 시스템 (Zone Centroid 방식)
        offscreen_pins = [] # 화면 밖 핀 저장용
        
        if not self.player.is_dead:
            job_k = "DOCTOR" if self.player.role == "DOCTOR" else self.player.sub_role
            if job_k in WORK_SEQ:
                target_tid = WORK_SEQ[job_k][self.player.work_step % 3]
                if target_tid in self.map_manager.tile_cache:
                    target_pixels = self.map_manager.tile_cache[target_tid]
                    
                    sum_x, sum_y = 0, 0
                    count = 0
                    off_screen_exists = False
                    
                    # 1. 화면 내 타일에는 직접 표시 & 중심점 계산
                    for (px, py) in target_pixels:
                        # 화면 안에 있는지 확인
                        if self.camera.x - TILE_SIZE <= px <= self.camera.x + vw + TILE_SIZE and \
                           self.camera.y - TILE_SIZE <= py <= self.camera.y + vh + TILE_SIZE:
                            # 화면 안: 노란 박스 그리기
                            pygame.draw.rect(self.canvas, (255, 255, 0), (px - self.camera.x, py - self.camera.y, TILE_SIZE, TILE_SIZE), 2)
                        else:
                            off_screen_exists = True
                        
                        sum_x += px
                        sum_y += py
                        count += 1
                    
                    # 2. 화면 밖 목표가 있다면, 구역의 중심점(Zone Center)으로 핀 하나만 표시
                    if off_screen_exists and count > 0:
                        # 구역의 중심점 계산
                        avg_x = sum_x / count
                        avg_y = sum_y / count
                        
                        center_x = self.camera.x + vw / 2
                        center_y = self.camera.y + vh / 2
                        
                        # 중심점 기준 방향 벡터 계산
                        dx = (avg_x + TILE_SIZE / 2) - center_x
                        dy = (avg_y + TILE_SIZE / 2) - center_y
                        
                        if dx != 0 or dy != 0:
                            margin = 30
                            half_w = self.game.screen_width / 2 - margin
                            half_h = self.game.screen_height / 2 - margin
                            
                            scale_x = abs(half_w / dx) if dx != 0 else float('inf')
                            scale_y = abs(half_h / dy) if dy != 0 else float('inf')
                            scale = min(scale_x, scale_y)
                            
                            pin_x = self.game.screen_width / 2 + dx * scale
                            pin_y = self.game.screen_height / 2 + dy * scale
                            
                            # 핀 하나만 추가
                            offscreen_pins.append((int(pin_x), int(pin_y)))

        for n in self.npcs:
            if (int(n.rect.centerx//TILE_SIZE), int(n.rect.centery//TILE_SIZE)) in self.visible_tiles or self.player.role == "SPECTATOR":
                n.draw(self.canvas, self.camera.x, self.camera.y, self.player.role, self.player.device_on)

        if not self.player.is_dead:
            CharacterRenderer.draw_entity(self.canvas, self.player, self.camera.x, self.camera.y, self.player.role, self.current_phase, self.player.device_on)

        for fx in self.effects: fx.draw(self.canvas, self.camera.x, self.camera.y)
        
        for i in self.indicators: i.draw(self.canvas, self.player.rect, self.camera.x, self.camera.y)

        if self.player.role != "SPECTATOR":
            # [수정] 계산된 자연스러운 밝기(Alpha) 적용
            
            # 정전(Blackout)은 페이즈와 무관하게 즉시 어두워짐
            final_alpha = 250 if self.is_blackout else int(self.current_ambient_alpha)
            
            # 값 안전장치 (0~255)
            final_alpha = max(0, min(255, final_alpha))
            
            self.dark_surface.fill((5, 5, 10, final_alpha))

            # 시야 처리 (새벽+비마피아 제외)
            if not (self.current_phase == 'DAWN' and self.player.role != "MAFIA"):
                # B. Light Mask 초기화
                self.light_mask.fill((0, 0, 0, 0))

                # C. [Polygon] 시야 다각형 계산 및 그리기
                # 타일 사각형 대신, 정밀한 레이캐스팅 다각형을 사용합니다.
                # [수정] 어둠 지수 기반 시야 반경 계산
                radius_tiles = self.player.get_vision_radius(self.current_vision_factor, self.is_blackout, self.weather)
                
                direction = None
                angle_width = 60
                if self.player.role == "POLICE" and self.player.flashlight_on and self.current_phase in ['EVENING', 'NIGHT', 'DAWN']:
                    direction = self.player.facing_dir

                # 다각형 점들 계산 (절대 좌표)
                poly_points_abs = self.fov.get_poly_points(
                    self.player.rect.centerx, 
                    self.player.rect.centery, 
                    radius_tiles, 
                    direction, 
                    angle_width
                )
                
                # 카메라 상대 좌표로 변환
                poly_points_rel = []
                cam_x, cam_y = self.camera.x, self.camera.y
                for px, py in poly_points_abs:
                    poly_points_rel.append((px - cam_x, py - cam_y))
                
                # [수정] 선명도(Clarity) 적용
                draw_clarity = self.current_clarity
                
                # [예외] 경찰 손전등: 켜진 방향은 아주 밝아야 함 (선명도 MAX)
                if self.player.role == "POLICE" and self.player.flashlight_on:
                    draw_clarity = 240 # 손전등 빛은 매우 밝음
                
                # [예외] 마피아: 밤눈이 밝음 (페널티 완화)
                elif self.player.role == "MAFIA" and self.current_phase in ['NIGHT', 'DAWN']:
                    draw_clarity = max(draw_clarity, 180) # 최소 180 보장

                # 정전 시에는 선명도 급감 (코앞도 잘 안 보임)
                if self.is_blackout and self.player.role != "MAFIA":
                    draw_clarity = min(draw_clarity, 50)
                
                # 다각형 그리기 (흰색) -> 이것이 '보이는 영역'의 모양이 됩니다.
                if len(poly_points_rel) > 2:
                    pygame.draw.polygon(self.light_mask, (255, 255, 255, int(draw_clarity)), poly_points_rel)

                # D. [Gradient] 부드러운 그라데이션 곱하기 (Multiply)
                radius_px = int(radius_tiles * TILE_SIZE * 1.2)
                halo = pygame.transform.scale(self.gradient_halo, (radius_px * 2, radius_px * 2))
                
                px = self.player.rect.centerx - self.camera.x
                py = self.player.rect.centery - self.camera.y
                
                # 다각형 모양 위에 그라데이션을 덧씌웁니다.
                self.light_mask.blit(halo, (px - radius_px, py - radius_px), special_flags=pygame.BLEND_RGBA_MULT)

                # E. [Final] 어둠에서 빛 파내기
                self.dark_surface.blit(self.light_mask, (0, 0), special_flags=pygame.BLEND_RGBA_SUB)

            self.canvas.blit(self.dark_surface, (0, 0))
            
        now = pygame.time.get_ticks()
        
        if self.is_mafia_frozen: 
            cycle = (now // 200) % 2
            flash_color = (255, 0, 0, 50) if cycle == 0 else (0, 0, 255, 50)
            overlay = pygame.Surface((vw, vh), pygame.SRCALPHA)
            overlay.fill(flash_color)
            self.canvas.blit(overlay, (0, 0))

        if self.is_blackout:
            cycle = (now // 500) % 2
            if cycle == 0:
                overlay = pygame.Surface((vw, vh), pygame.SRCALPHA)
                pygame.draw.rect(overlay, (255, 0, 0, 100), (0, 0, vw, vh), 20)
                self.canvas.blit(overlay, (0, 0))

        if self.player.minigame.active:
            self.player.minigame.draw(self.canvas, self.player.rect.centerx - self.camera.x, self.player.rect.top - self.camera.y - 60)

        screen.blit(pygame.transform.scale(self.canvas, (self.game.screen_width, self.game.screen_height)), (0, 0))

        # [요청 2] 날씨 및 이펙트 (가변 해상도 지원)
        # 현재 화면 크기 가져오기
        sw, sh = screen.get_width(), screen.get_height()

        # [수정] 캔버스 위에 핀 그리기 (UI처럼 최상단 표시)
        for (px, py) in offscreen_pins:
            pygame.draw.circle(screen, (255, 50, 50), (px, py), 8)
            pygame.draw.circle(screen, (255, 255, 255), (px, py), 10, 2)

        # [New] Weather Visuals
        if self.weather == 'RAIN':
            for p in self.weather_particles:
                start_pos = (p[0], p[1])
                end_pos = (p[0] - 2, p[1] + 10)
                pygame.draw.line(screen, (150, 150, 255, 150), start_pos, end_pos, 1)
        elif self.weather == 'SNOW':
            for p in self.weather_particles:
                pygame.draw.circle(screen, (255, 255, 255, 200), (int(p[0]), int(p[1])), 2)
        elif self.weather == 'FOG':
            # [수정] Surface 재사용
            if self.effect_surf.get_size() != (sw, sh):
                self.effect_surf = pygame.Surface((sw, sh), pygame.SRCALPHA)
                
            alpha = 100 + int(math.sin(pygame.time.get_ticks() * 0.002) * 20)
            self.effect_surf.fill((200, 200, 220, alpha))
            screen.blit(self.effect_surf, (0, 0))

        # [감정 효과]
        anxiety_level = self.player.status_effects.get('ANXIETY', 0)
        if anxiety_level > 0:
            pulse = (math.sin(pygame.time.get_ticks() * 0.01) + 1) * 0.5
            alpha = int(anxiety_level * 10 * pulse)
            # [수정] Surface 재사용
            if self.effect_surf.get_size() != (sw, sh):
                self.effect_surf = pygame.Surface((sw, sh), pygame.SRCALPHA)
                
            self.effect_surf.fill((0, 0, 0, 0)) # Clear previous drawing
            pygame.draw.rect(self.effect_surf, (255, 0, 0, alpha), (0, 0, sw, sh), 30)
            screen.blit(self.effect_surf, (0, 0))

        # [Removed] Fatigue Visuals (Black bars)

        if self.ui:
            self.ui.draw(screen)
            
            if self.show_vote_ui:
                self.candidate_rects = self.ui.draw_vote_popup(screen, self.game.screen_width, self.game.screen_height, self.npcs, self.player, self.my_vote_target)
            else:
                self.candidate_rects = []

        # [Moved] Draw Chat UI at the very end
        if self.is_chatting:
            chat_bg = pygame.Surface((self.game.screen_width, 40))
            chat_bg.fill((0, 0, 0))
            chat_bg.set_alpha(200)
            screen.blit(chat_bg, (0, self.game.screen_height - 40))
            
            font = pygame.font.SysFont("arial", 24)
            txt_surf = font.render(f"Chat: {self.chat_text}", True, (255, 255, 255))
            screen.blit(txt_surf, (10, self.game.screen_height - 35))
            
            if (pygame.time.get_ticks() // 500) % 2 == 0: # Blink cursor
                cursor_x = 10 + txt_surf.get_width()
                pygame.draw.line(screen, (255, 255, 255), (cursor_x, self.game.screen_height - 35), (cursor_x, self.game.screen_height - 5), 2)

    def handle_event(self, event):
        # [New] Chat Event Handling
        if event.type == pygame.KEYDOWN and event.key == pygame.K_RETURN:
            self.is_chatting = not self.is_chatting
            if not self.is_chatting:
                # Send chat (Locally add to popup for now as it's single player view)
                if self.chat_text.strip():
                    self.player.add_popup(self.chat_text, (255, 255, 255))
                    self.chat_text = ""
            return

        if self.is_chatting:
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_BACKSPACE:
                    self.chat_text = self.chat_text[:-1]
                else:
                    if len(self.chat_text) < 50:
                        self.chat_text += event.unicode
            return

        # [수정] UI가 열려있을 때 처리 (뉴스 포함, ESC 등 키보드 처리)
        if self.ui.show_vending or self.ui.show_inventory or self.ui.show_voting or self.ui.show_news:
            if event.type == pygame.KEYDOWN:
                res = self.ui.handle_keyboard(event.key, self.npcs)
                if res:
                    # 반환값이 튜플(메시지, 사운드)인 경우 처리
                    if isinstance(res, tuple):
                        msg, sound = res
                        if msg: self.player.add_popup(msg)
                        if sound: self._process_sound_effect(sound)
                    elif isinstance(res, str): # 단순 문자열 메시지인 경우
                        self.player.add_popup(res)
                return

        if event.type == pygame.KEYDOWN:
            if not self.player.is_dead and self.player.role != "SPECTATOR":
                if event.key == pygame.K_z:
                    if self.current_phase == "AFTERNOON":
                        self.show_vote_ui = not self.show_vote_ui
                    else:
                        self.player.add_popup("Vote in AFTERNOON", (255, 100, 100))
                
                elif event.key == pygame.K_v:
                    self._handle_v_action()

                elif event.key == pygame.K_f:
                    self.player.toggle_flashlight()
                
                elif event.key == pygame.K_q:
                    msg = self.player.toggle_device()
                    if msg: self.player.add_popup(msg)

                # [I] 키로 인벤토리 열기
                elif event.key == pygame.K_i:
                    self.ui.toggle_inventory()

                elif event.key == pygame.K_r:
                    msg = self.player.use_active_skill()
                    if msg:
                        if msg == "USE_SABOTAGE":
                            self.execute_sabotage()
                        elif msg == "USE_SIREN":
                            self.execute_siren()
                        else:
                            self.player.add_popup(msg)
                    else:
                        self.player.add_popup("Cannot use skill yet!", (150, 150, 150))

                else:
                    for k, v in ITEMS.items():
                        if v['key'] == event.key:
                            # [수정] 아이템 사용 시 사운드 처리 (튜플 리턴 대응)
                            res = self.player.use_item(k)
                            if isinstance(res, tuple):
                                msg, sound = res
                                if msg: self.player.add_popup(msg)
                                if sound: self._process_sound_effect(sound)
                            elif res:
                                self.player.add_popup(res)
                            break

        if self.player.minigame.active:
            self.player.minigame.handle_event(event)
            return

        if event.type == pygame.MOUSEBUTTONDOWN:
            if event.button == 1: # Left Click
                if self.show_vote_ui and self.candidate_rects:
                    for target, rect in self.candidate_rects:
                        if rect.collidepoint(event.pos):
                            self.my_vote_target = target
                            self.player.add_popup(f"Voted for {target.name}", (100, 255, 100))

                if self.player.role == "SPECTATOR":
                    for rect, ent in self.ui.entity_rects:
                        if rect.collidepoint(event.pos): self.ui.spectator_follow_target = ent; break
                    if hasattr(self.ui, 'skip_btn_rect') and self.ui.skip_btn_rect.collidepoint(event.pos):
                        self.state_timer = 0
                # Mouse attack removed as per request (replaced by V key)

        if event.type == pygame.MOUSEWHEEL:
            if self.player.role == "SPECTATOR":
                mx, my = pygame.mouse.get_pos()
                if mx > self.game.screen_width - 300:
                    self.ui.spectator_scroll_y = max(0, self.ui.spectator_scroll_y - event.y * 20)
                else:
                    self.zoom_level = max(0.2, min(4.0, self.zoom_level + (0.2 if event.y > 0 else -0.2)))
                    self.camera.set_zoom(self.zoom_level)


################################################################################
 FILE: systems\__init__.py
################################################################################

--- [Code Analysis & Settings] ---
  (No specific structural elements found)

--- [Full Source Code] ---
from .fov import FOV
from .camera import Camera
from .minigame import MiniGameManager
from .effects import VisualSound
from .logger import GameLogger



################################################################################
 FILE: systems\camera.py
################################################################################

--- [Code Analysis & Settings] ---

  [Class] Camera
    [Method] __init__(self, screen_width, screen_height, map_width, map_height)
    [Method] x(self)
    [Method] x(self, value)
    [Method] y(self)
    [Method] y(self, value)
    [Method] resize(self, w, h)
    [Method] set_zoom(self, zoom)
    [Method] set_bounds(self, width_px, height_px)
    [Method] _update_viewport_size(self)
      - Doc: 줌이나 해상도 변경 시 1회만 호출
    [Method] move(self, dx, dy)
    [Method] update(self, target_x, target_y)

--- [Full Source Code] ---
import pygame
from settings import TILE_SIZE

class Camera:
    def __init__(self, screen_width, screen_height, map_width=0, map_height=0):
        self.camera_x = 0.0
        self.camera_y = 0.0
        self.width = screen_width
        self.height = screen_height
        
        self.map_width = map_width
        self.map_height = map_height
        self.zoom_level = 1.0

        self.map_width_px = map_width * TILE_SIZE
        self.map_height_px = map_height * TILE_SIZE
        
        # [수정] 초기화 시 뷰포트 크기 계산 (__init__ 마지막에 호출)
        self._update_viewport_size()

    @property
    def x(self):
        return self.camera_x

    @x.setter
    def x(self, value):
        self.camera_x = value

    @property
    def y(self):
        return self.camera_y

    @y.setter
    def y(self, value):
        self.camera_y = value

    def resize(self, w, h):
        self.width = w
        self.height = h
        self._update_viewport_size()

    def set_zoom(self, zoom):
        self.zoom_level = zoom
        self._update_viewport_size()
        
    def set_bounds(self, width_px, height_px):
        self.map_width_px = width_px
        self.map_height_px = height_px

    def _update_viewport_size(self):
        """줌이나 해상도 변경 시 1회만 호출"""
        if self.zoom_level > 0:
            self.view_w = self.width / self.zoom_level
            self.view_h = self.height / self.zoom_level
        else:
            self.view_w = self.width
            self.view_h = self.height

    def move(self, dx, dy):
        self.camera_x += dx
        self.camera_y += dy

    def update(self, target_x, target_y):
        # 타겟을 화면 중앙에 위치시키기 위한 카메라의 좌상단 좌표 계산
        x = target_x - self.view_w / 2
        y = target_y - self.view_h / 2

        # 맵 경계 제한 (Clamp)
        # 가로축
        if self.map_width_px > self.view_w:
            x = max(0, min(x, self.map_width_px - self.view_w))
        else:
            # 맵이 화면보다 작으면 중앙 정렬
            x = -(self.view_w - self.map_width_px) / 2

        # 세로축
        if self.map_height_px > self.view_h:
            y = max(0, min(y, self.map_height_px - self.view_h))
        else:
            # 맵이 화면보다 작으면 중앙 정렬
            y = -(self.view_h - self.map_height_px) / 2

        self.camera_x = x
        self.camera_y = y



################################################################################
 FILE: systems\effects.py
################################################################################

--- [Code Analysis & Settings] ---

  [Class] VisualSound
    [Method] __init__(self, x, y, text, color, size_scale, duration, shake, blink)
    [Method] render_text_with_outline(self, text, font, inner_color, outline_color, thickness)
    [Method] update(self)
    [Method] draw(self, screen, camera_x, camera_y)

  [Class] SoundDirectionIndicator
    - Doc: [New] Indicates direction of sound if off-screen
    [Method] __init__(self, source_x, source_y, duration)
    [Method] _create_glow_surface(self)
    [Method] update(self)
    [Method] draw(self, screen, player_rect, camera_x, camera_y)

--- [Full Source Code] ---
import pygame
import math
import random
from settings import SCREEN_WIDTH, SCREEN_HEIGHT, SHARED_FONTS

class VisualSound:
    def __init__(self, x, y, text, color, size_scale=1.0, duration=1500, shake=False, blink=False):
        self.x = x
        self.y = y
        self.text = str(text)
        self.base_color = color
        self.color = color
        self.duration = duration
        self.start_time = pygame.time.get_ticks()
        self.alive = True
        
        self.shake = shake
        self.blink = blink

        angle_deg = random.uniform(240, 300)
        self.angle_rad = math.radians(angle_deg)
        self.speed = 1.2 * size_scale

        base_size = int(max(16, (52 * size_scale) * 0.5))

        # [최적화] 폰트 객체 캐싱 및 재사용
        font_key = (base_size, 'arial black')
        if font_key not in SHARED_FONTS:
            if not pygame.font.get_init():
                pygame.font.init()
            try:
                SHARED_FONTS[font_key] = pygame.font.SysFont("arial black", base_size, bold=True)
            except:
                SHARED_FONTS[font_key] = pygame.font.SysFont("arial", base_size, bold=True)
        
        self.font = SHARED_FONTS[font_key]

        # [최적화] 깜빡임 효과용 이미지를 미리 생성 (매 프레임 렌더링 방지)
        self.normal_image = self.render_text_with_outline(self.text, self.font, color, (0, 0, 0), 2)
        self.blink_image = None
        if self.blink:
            self.blink_image = self.render_text_with_outline(self.text, self.font, (255, 255, 255), (0, 0, 0), 2)
            
        self.image = self.normal_image

        self.offset_x = 0
        self.offset_y = 0
        self.alpha = 255

    def render_text_with_outline(self, text, font, inner_color, outline_color, thickness):
        text_surf = font.render(text, True, inner_color)
        outline_surf = font.render(text, True, outline_color)
        w, h = text_surf.get_size()
        final_surf = pygame.Surface((w + thickness*2, h + thickness*2), pygame.SRCALPHA)

        for dx, dy in [(-thickness,0), (thickness,0), (0,-thickness), (0,thickness)]:
            final_surf.blit(outline_surf, (dx + thickness, dy + thickness))
        final_surf.blit(text_surf, (thickness, thickness))
        return final_surf

    def update(self):
        now = pygame.time.get_ticks()
        elapsed = now - self.start_time
        if elapsed > self.duration:
            self.alive = False
            return

        progress = elapsed / self.duration
        dist = self.speed * (elapsed / 12)
        
        # Base Movement
        self.offset_x = math.cos(self.angle_rad) * dist
        self.offset_y = math.sin(self.angle_rad) * dist + (progress**2 * 30)

        # [Added] Shake Effect
        if self.shake:
            shake_intensity = 3 * (1 - progress)
            self.offset_x += random.uniform(-shake_intensity, shake_intensity)
            self.offset_y += random.uniform(-shake_intensity, shake_intensity)

        # [Added] Blink Effect (최적화됨: 이미지 교체만 수행)
        if self.blink and self.blink_image:
            if (now // 200) % 2 == 0:
                self.image = self.blink_image
            else:
                self.image = self.normal_image

        if progress > 0.6:
            self.alpha = int(255 * (1 - (progress - 0.6) / 0.4))
        else:
            self.alpha = 255

    def draw(self, screen, camera_x, camera_y):
        if not self.alive: return
        draw_x = self.x - camera_x - (self.image.get_width() // 2) + self.offset_x
        draw_y = self.y - camera_y - (self.image.get_height() // 2) + self.offset_y

        draw_surf = self.image.copy()
        draw_surf.set_alpha(self.alpha)
        screen.blit(draw_surf, (draw_x, draw_y))

class SoundDirectionIndicator:
    """[New] Indicates direction of sound if off-screen"""
    # [최적화] 모든 인스턴스가 공유하는 정적 글로우 이미지
    _SHARED_GLOW_SURF = None

    def __init__(self, source_x, source_y, duration=500):
        self.source_x = source_x
        self.source_y = source_y
        self.duration = duration
        self.start_time = pygame.time.get_ticks()
        self.alive = True
        
        # [최적화] 최초 1회만 생성하고 이후에는 공유된 서피스 참조
        if SoundDirectionIndicator._SHARED_GLOW_SURF is None:
            SoundDirectionIndicator._SHARED_GLOW_SURF = self._create_glow_surface()
            
        self.glow_img = SoundDirectionIndicator._SHARED_GLOW_SURF

    def _create_glow_surface(self):
        surf = pygame.Surface((200, 200), pygame.SRCALPHA)
        for r in range(100, 0, -2):
            alpha = int(150 * (r / 100))
            pygame.draw.circle(surf, (255, 0, 0, alpha), (100, 100), r)
        return surf

    def update(self):
        if pygame.time.get_ticks() - self.start_time > self.duration:
            self.alive = False

    def draw(self, screen, player_rect, camera_x, camera_y):
        dx = self.source_x - player_rect.centerx
        dy = self.source_y - player_rect.centery
        dist = math.sqrt(dx**2 + dy**2)
        
        if dist < 400: return 

        angle = math.atan2(dy, dx)
        
        cx, cy = SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2
        radius_x = SCREEN_WIDTH // 2 - 50
        radius_y = SCREEN_HEIGHT // 2 - 50
        
        edge_x = cx + math.cos(angle) * radius_x
        edge_y = cy + math.sin(angle) * radius_y
        
        elapsed = pygame.time.get_ticks() - self.start_time
        alpha = 255 - int(255 * (elapsed / self.duration))
        
        final_surf = self.glow_img.copy()
        final_surf.set_alpha(alpha)
        screen.blit(final_surf, (edge_x - 100, edge_y - 100), special_flags=pygame.BLEND_ADD)


################################################################################
 FILE: systems\fov.py
################################################################################

--- [Code Analysis & Settings] ---

  [Class] FOV
    [Method] __init__(self, map_width, map_height, map_manager)
    [Method] cast_rays(self, px, py, radius, direction, angle_width)
    [Method] get_poly_points(self, px, py, radius, direction, angle_width)

--- [Full Source Code] ---
import math
import pygame
from settings import TILE_SIZE, SCREEN_WIDTH, SCREEN_HEIGHT, INDOOR_ZONES
from world.tiles import check_collision

class FOV:
    def __init__(self, map_width, map_height, map_manager):
        self.map_width = map_width
        self.map_height = map_height
        self.map_manager = map_manager
        
        # [최적화] 삼각함수 Lookup Table 생성 (0도 ~ 360도)
        self.sin_table = {}
        self.cos_table = {}
        for deg in range(361):
            rad = math.radians(deg)
            self.sin_table[deg] = math.sin(rad)
            self.cos_table[deg] = math.cos(rad)
        
    def cast_rays(self, px, py, radius, direction=None, angle_width=60):
        visible_tiles = set()
        
        cx, cy = int(px // TILE_SIZE), int(py // TILE_SIZE)
        visible_tiles.add((cx, cy)) 
        
        if radius <= 0: return visible_tiles

        player_zone = 0
        if 0 <= cx < self.map_width and 0 <= cy < self.map_height:
            player_zone = self.map_manager.zone_map[cy][cx]
        is_player_indoors = (player_zone in INDOOR_ZONES)

        max_dist_px = radius * TILE_SIZE
        step_size = TILE_SIZE / 2.0  
        
        if direction and (direction[0] != 0 or direction[1] != 0):
            center_angle = math.degrees(math.atan2(direction[1], direction[0]))
            # 음수 각도 보정
            if center_angle < 0: center_angle += 360
            
            start_angle = int(center_angle - angle_width / 2)
            end_angle = int(center_angle + angle_width / 2)
            angle_step = 2
        else:
            start_angle = 0
            end_angle = 360
            angle_step = 3 

        # [최적화] 지역 변수 캐싱
        wall_data = self.map_manager.map_data['wall']
        obj_data = self.map_manager.map_data['object']
        zone_data = self.map_manager.zone_map
        width, height = self.map_width, self.map_height
        
        # Lookup table 캐싱
        sin_tbl = self.sin_table
        cos_tbl = self.cos_table

        for angle_deg in range(start_angle, end_angle, angle_step):
            # [최적화] 각도 정규화 (0~360) 및 테이블 조회
            norm_deg = angle_deg % 360
            sin_a = sin_tbl[norm_deg]
            cos_a = cos_tbl[norm_deg]
            
            current_dist = 0
            while current_dist < max_dist_px:
                current_dist += step_size
                
                nx = px + cos_a * current_dist
                ny = py + sin_a * current_dist
                
                gx, gy = int(nx // TILE_SIZE), int(ny // TILE_SIZE)
                
                if not (0 <= gx < width and 0 <= gy < height):
                    break
                
                visible_tiles.add((gx, gy))

                # [최적화] 직접 배열 접근 및 인라인 충돌 검사
                # get_tile 함수 호출 제거
                
                # 1. 벽 충돌 검사
                w_val = wall_data[gy][gx]
                tid_wall = w_val[0] if isinstance(w_val, (tuple, list)) else w_val
                
                is_blocking = False
                if tid_wall != 0 and check_collision(tid_wall):
                    is_blocking = True
                
                # 2. 오브젝트(문 등) 충돌 검사
                if not is_blocking:
                    o_val = obj_data[gy][gx]
                    tid_obj = o_val[0] if isinstance(o_val, (tuple, list)) else o_val
                    
                    if tid_obj != 0 and check_collision(tid_obj):
                        is_blocking = True

                # 3. 실내/실외 시야 차단 로직
                target_zone = zone_data[gy][gx]
                is_target_indoors = (target_zone in INDOOR_ZONES)
                
                if not is_player_indoors and is_target_indoors:
                    if is_blocking:
                        break # 외벽은 보이고 그 뒤는 안 보임
                    else:
                        break # 내부 바닥도 안 보임
                
                if is_blocking:
                    break
        return visible_tiles

    # [추가] 렌더링용 고해상도 다각형 계산 메서드
    def get_poly_points(self, px, py, radius, direction=None, angle_width=60):
        points = []
        points.append((px, py)) # 중심점 추가

        if radius <= 0: return points

        cx, cy = int(px // TILE_SIZE), int(py // TILE_SIZE)
        player_zone = 0
        if 0 <= cx < self.map_width and 0 <= cy < self.map_height:
             player_zone = self.map_manager.zone_map[cy][cx]
        is_player_indoors = (player_zone in INDOOR_ZONES)

        max_dist_px = radius * TILE_SIZE
        
        # [설정] 품질 조절: step이 작을수록 벽에 딱 붙어서 매끄러움 (4px 권장)
        # angle_step이 작을수록 원이 부드러움 (1~2도 권장)
        step_size = 4.0 
        
        start_angle, end_angle, angle_step = 0, 360, 2
        if direction and (direction[0] != 0 or direction[1] != 0):
            center_angle = math.degrees(math.atan2(direction[1], direction[0]))
            if center_angle < 0: center_angle += 360
            
            start_angle = int(center_angle - angle_width / 2)
            end_angle = int(center_angle + angle_width / 2)
            angle_step = 1 # 손전등은 더 정밀하게

        # 최적화를 위한 지역 변수
        width, height = self.map_width, self.map_height
        wall_data = self.map_manager.map_data['wall']
        obj_data = self.map_manager.map_data['object']
        zone_data = self.map_manager.zone_map
        
        # Lookup table 캐싱
        sin_tbl = self.sin_table
        cos_tbl = self.cos_table

        # 모든 각도에 대해 레이캐스팅
        for angle_deg in range(start_angle, end_angle + 1, angle_step):
            # [최적화] 테이블 조회
            norm_deg = angle_deg % 360
            sin_a = sin_tbl[norm_deg]
            cos_a = cos_tbl[norm_deg]
            
            current_dist = 0
            hit_x, hit_y = px, py
            
            while current_dist < max_dist_px:
                current_dist += step_size
                nx = px + cos_a * current_dist
                ny = py + sin_a * current_dist
                
                gx, gy = int(nx // TILE_SIZE), int(ny // TILE_SIZE)
                
                # 맵 밖으로 나가면 종료
                if not (0 <= gx < width and 0 <= gy < height):
                    hit_x, hit_y = nx, ny
                    break
                
                # 충돌 검사
                is_blocking = False
                
                # 1. Wall
                w_val = wall_data[gy][gx]
                tid_wall = w_val[0] if isinstance(w_val, (tuple, list)) else w_val
                if tid_wall != 0 and check_collision(tid_wall): is_blocking = True
                
                # 2. Object
                if not is_blocking:
                    o_val = obj_data[gy][gx]
                    tid_obj = o_val[0] if isinstance(o_val, (tuple, list)) else o_val
                    if tid_obj != 0 and check_collision(tid_obj): is_blocking = True

                # 3. Zone
                target_zone = zone_data[gy][gx]
                is_target_indoors = (target_zone in INDOOR_ZONES)
                if not is_player_indoors and is_target_indoors:
                    is_blocking = True # 실내 타일 진입 시 시야 차단
                
                if is_blocking:
                    hit_x, hit_y = nx, ny
                    break
                
                hit_x, hit_y = nx, ny
            
            points.append((hit_x, hit_y))
            
        return points



################################################################################
 FILE: systems\logger.py
################################################################################

--- [Code Analysis & Settings] ---

  [Class] GameLogger
    [Method] get_instance(cls)
    [Method] __init__(self)
    [Method] _process_logs(self)
      - Doc: 백그라운드에서 큐에 쌓인 로그를 파일에 기록
    [Method] log(self, level, category, message)
    [Method] info(self, category, message)
    [Method] error(self, category, message)
    [Method] debug(self, category, message)
    [Method] shutdown(self)

--- [Full Source Code] ---
import logging
import os
import threading
import queue
from datetime import datetime

class GameLogger:
    _instance = None
    
    @classmethod
    def get_instance(cls):
        if cls._instance is None:
            cls._instance = GameLogger()
        return cls._instance

    def __init__(self):
        # [최적화] 로그 메시지 큐 생성
        self.log_queue = queue.Queue()
        self.running = True
        
        # 로거 설정
        self.logger = logging.getLogger("PixelNight")
        self.logger.setLevel(logging.DEBUG)
        
        if not os.path.exists("logs"):
            os.makedirs("logs")
            
        filename = f"logs/game_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log"
        file_handler = logging.FileHandler(filename, encoding='utf-8')
        formatter = logging.Formatter('%(asctime)s - [%(levelname)s] - %(message)s')
        file_handler.setFormatter(formatter)
        self.logger.addHandler(file_handler)

        # [최적화] 별도 쓰레드에서 파일 쓰기 작업 수행
        self.worker_thread = threading.Thread(target=self._process_logs, daemon=True)
        self.worker_thread.start()

    def _process_logs(self):
        """백그라운드에서 큐에 쌓인 로그를 파일에 기록"""
        while self.running or not self.log_queue.empty():
            try:
                # 0.1초 대기하며 로그 가져오기
                record = self.log_queue.get(timeout=0.1)
                level, category, message = record
                
                full_msg = f"[{category}] {message}"
                if level == 'INFO': self.logger.info(full_msg)
                elif level == 'ERROR': self.logger.error(full_msg)
                elif level == 'DEBUG': self.logger.debug(full_msg)
                elif level == 'WARNING': self.logger.warning(full_msg)
                
                self.log_queue.task_done()
            except queue.Empty:
                continue
            except Exception as e:
                print(f"Logging Error: {e}")

    def log(self, level, category, message):
        # [최적화] 메인 로직에서는 큐에 넣기만 하고 즉시 리턴 (Non-blocking)
        self.log_queue.put((level, category, message))

    def info(self, category, message):
        self.log('INFO', category, message)

    def error(self, category, message):
        self.log('ERROR', category, message)
        
    def debug(self, category, message):
        self.log('DEBUG', category, message)

    def shutdown(self):
        self.running = False
        if self.worker_thread.is_alive():
            self.worker_thread.join(timeout=1.0)


################################################################################
 FILE: systems\minigame.py
################################################################################

--- [Code Analysis & Settings] ---

  [Class] MiniGameManager
    [Method] __init__(self)
    [Method] start(self, game_type, difficulty, on_success, on_fail)
    [Method] init_specific_game(self)
    [Method] update(self)
    [Method] handle_event(self, event)
    [Method] success_game(self)
    [Method] fail_game(self)
    [Method] draw(self, screen, x, y)

--- [Full Source Code] ---
import pygame
import random
import math
from settings import *
from colors import *

class MiniGameManager:
    def __init__(self):
        self.active = False
        self.game_type = None
        self.difficulty = 1
        self.on_success = None
        self.on_fail = None

        self.width = 240
        self.height = 160
        self.bg_color = (25, 25, 35)
        self.border_color = (180, 180, 190)

        # 폰트 로드 (시스템 폰트 -> 기본 폰트 순)
        try:
            self.font_title = pygame.font.SysFont("arial", 20, bold=True)
            self.font_ui = pygame.font.SysFont("arial", 14) # UI 폰트 크기 조정
            self.font_big = pygame.font.SysFont("arial", 30, bold=True)
        except:
            self.font_title = pygame.font.Font(None, 26)
            self.font_ui = pygame.font.Font(None, 20)
            self.font_big = pygame.font.Font(None, 34)

        self.start_time = 0
        self.duration = 10000

        # 게임별 상태 변수들
        self.mash_progress = 0; self.mash_decay = 0.35
        self.timing_cursor = 0; self.timing_dir = 1; self.timing_speed = 3; self.timing_target = (0, 0)
        self.cmd_seq = []; self.cmd_idx = 0
        self.circle_angle = 0; self.circle_speed = 2; self.circle_target_angle = 0; self.circle_tolerance = 35

        self.wires_left = []; self.wires_right = []; self.wire_connections = {}
        self.wire_l_idx = 0; self.wire_r_idx = 0; self.wire_selected_l = -1
        self.wire_state = 0

        self.memory_grid = []; self.memory_seq = []; self.memory_next = 1
        self.mem_cursor = [0, 0]
        
        # [추가] 락픽 전용 변수
        self.lock_pins = []        # 핀들의 현재 높이 (0.0 ~ 1.0)
        self.lock_targets = []     # 각 핀의 성공 구간 (min, max)
        self.lock_current_pin = 0  # 현재 시도 중인 핀 인덱스
        self.lock_cursor = 0.0     # 움직이는 커서 위치
        self.lock_dir = 1.0        # 커서 이동 방향
        self.lock_speed = 0.02     # 커서 이동 속도

    def start(self, game_type, difficulty, on_success, on_fail):
        self.active = True
        self.game_type = game_type
        self.difficulty = difficulty
        self.on_success = on_success
        self.on_fail = on_fail
        self.start_time = pygame.time.get_ticks()

        base_time = 10000
        if game_type in ['WIRING', 'MEMORY', 'LOCKPICK']: base_time = 15000
        self.duration = base_time

        self.init_specific_game()

    def init_specific_game(self):
        if self.game_type == 'MASHING':
            self.mash_progress = 20
        elif self.game_type == 'TIMING':
            self.timing_cursor = 0; self.timing_dir = 1; self.timing_speed = 3 + self.difficulty
            w = 60 - (self.difficulty*4); c = self.width//2; self.timing_target = (c-w//2 - 20, c+w//2 - 20)
        elif self.game_type == 'COMMAND':
            self.cmd_seq = [random.choice(['UP','DOWN','LEFT','RIGHT']) for _ in range(3+self.difficulty)]; self.cmd_idx = 0
        elif self.game_type == 'CIRCLE':
            self.circle_angle = 0; self.circle_speed = 2 + self.difficulty*0.5; self.circle_target_angle = random.randint(45, 315)
        elif self.game_type == 'WIRING':
            # [수정] 색상 직접 정의 (Import 의존성 제거)
            safe_colors = [(255, 50, 50), (50, 100, 255), (255, 200, 50), (50, 200, 50)]
            random.shuffle(safe_colors)
            
            self.wires_left = [{'color': c, 'id': i} for i, c in enumerate(safe_colors)]
            indices = list(range(4)); random.shuffle(indices)
            self.wires_right = [{'color': safe_colors[i], 'id': i} for i in indices]
            self.wire_connections = {}; self.wire_l_idx = 0; self.wire_r_idx = 0; self.wire_selected_l = -1; self.wire_state = 0
        elif self.game_type == 'MEMORY':
            count = min(9, 3 + self.difficulty)
            cells = []
            for y in range(3):
                for x in range(3): cells.append((x,y))
            random.shuffle(cells)
            self.memory_grid = [[None]*3 for _ in range(3)]
            for i in range(count):
                x, y = cells[i]
                self.memory_grid[y][x] = {'num': i+1, 'clicked': False}
            self.memory_next = 1; self.mem_cursor = [1, 1]
        elif self.game_type == 'LOCKPICK':
            # 핀 개수: 기본 3개 + 난이도
            num_pins = 3 + self.difficulty
            self.lock_pins = [0.0] * num_pins # 0.0(바닥) ~ 1.0(완료)
            self.lock_targets = []
            self.lock_current_pin = 0
            self.lock_cursor = 0.0
            self.lock_dir = 1.0
            self.lock_speed = 0.03 + (self.difficulty * 0.005)
            
            # 각 핀마다 성공 구간(Sweet Spot) 랜덤 설정 (상단 70% ~ 95% 사이)
            for _ in range(num_pins):
                center = random.uniform(0.7, 0.9)
                width = 0.15 - (self.difficulty * 0.02) # 난이도 높을수록 구간 좁아짐
                self.lock_targets.append((center - width/2, center + width/2))

    def update(self):
        if not self.active: return
        if pygame.time.get_ticks() - self.start_time > self.duration: self.fail_game(); return

        if self.game_type == 'MASHING':
            self.mash_progress = max(0, self.mash_progress - self.mash_decay)
        elif self.game_type == 'TIMING':
            self.timing_cursor += self.timing_speed * self.timing_dir
            if self.timing_cursor < 0 or self.timing_cursor > self.width - 40: self.timing_dir *= -1
        elif self.game_type == 'CIRCLE':
            self.circle_angle = (self.circle_angle + self.circle_speed) % 360
        elif self.game_type == 'LOCKPICK':
            # 현재 핀에 대해 커서가 위아래로 움직임 (0.0 <-> 1.0)
            self.lock_cursor += self.lock_speed * self.lock_dir
            if self.lock_cursor >= 1.0:
                self.lock_cursor = 1.0; self.lock_dir = -1.0
            elif self.lock_cursor <= 0.0:
                self.lock_cursor = 0.0; self.lock_dir = 1.0
            
            # 현재 핀의 높이를 커서에 맞춰 시각적으로 보여줌
            self.lock_pins[self.lock_current_pin] = self.lock_cursor

    def handle_event(self, event):
        if not self.active or event.type != pygame.KEYDOWN: return

        if self.game_type == 'MASHING':
            if event.key == pygame.K_SPACE:
                self.mash_progress += 12
                if self.mash_progress >= 100: self.success_game()
        elif self.game_type == 'TIMING':
            if event.key == pygame.K_SPACE:
                bar_x = self.width // 2 - 100
                if self.timing_target[0] <= self.timing_cursor <= self.timing_target[1]: self.success_game()
                else: self.fail_game()
        elif self.game_type == 'COMMAND':
            target = self.cmd_seq[self.cmd_idx]
            k = event.key
            valid = (target=='UP' and k==pygame.K_UP) or (target=='DOWN' and k==pygame.K_DOWN) or (target=='LEFT' and k==pygame.K_LEFT) or (target=='RIGHT' and k==pygame.K_RIGHT)
            if valid:
                self.cmd_idx += 1
                if self.cmd_idx >= len(self.cmd_seq): self.success_game()
            else: self.fail_game()
        elif self.game_type == 'CIRCLE':
            if event.key == pygame.K_SPACE:
                diff = abs(self.circle_angle - self.circle_target_angle)
                if diff > 180: diff = 360 - diff
                if diff <= self.circle_tolerance: self.success_game()
                else: self.fail_game()
        elif self.game_type == 'WIRING':
            if self.wire_state == 0: # 왼쪽 선택 중
                if event.key == pygame.K_UP: self.wire_l_idx = max(0, self.wire_l_idx - 1)
                elif event.key == pygame.K_DOWN: self.wire_l_idx = min(3, self.wire_l_idx + 1)
                elif event.key == pygame.K_SPACE:
                    if self.wires_left[self.wire_l_idx]['id'] not in self.wire_connections:
                        self.wire_selected_l = self.wire_l_idx; self.wire_state = 1
            elif self.wire_state == 1: # 오른쪽 선택 중
                if event.key == pygame.K_UP: self.wire_r_idx = max(0, self.wire_r_idx - 1)
                elif event.key == pygame.K_DOWN: self.wire_r_idx = min(3, self.wire_r_idx + 1)
                elif event.key == pygame.K_LEFT: self.wire_state = 0; self.wire_selected_l = -1 # 취소
                elif event.key == pygame.K_SPACE:
                    l_id = self.wires_left[self.wire_selected_l]['id']
                    # 색상(튜플)이 정확히 일치하는지 확인
                    if self.wires_left[self.wire_selected_l]['color'] == self.wires_right[self.wire_r_idx]['color']:
                        self.wire_connections[l_id] = self.wires_right[self.wire_r_idx]['id']
                        self.wire_state = 0; self.wire_selected_l = -1
                        if len(self.wire_connections) == 4: self.success_game()
                    else: self.fail_game()
        elif self.game_type == 'MEMORY':
            if event.key == pygame.K_UP: self.mem_cursor[1] = max(0, self.mem_cursor[1] - 1)
            elif event.key == pygame.K_DOWN: self.mem_cursor[1] = min(2, self.mem_cursor[1] + 1)
            elif event.key == pygame.K_LEFT: self.mem_cursor[0] = max(0, self.mem_cursor[0] - 1)
            elif event.key == pygame.K_RIGHT: self.mem_cursor[0] = min(2, self.mem_cursor[0] + 1)
            elif event.key == pygame.K_SPACE:
                cx, cy = self.mem_cursor
                item = self.memory_grid[cy][cx]
                if item and not item['clicked']:
                    if item['num'] == self.memory_next:
                        item['clicked'] = True; self.memory_next += 1
                        count = sum(1 for row in self.memory_grid for x in row if x)
                        if self.memory_next > count: self.success_game()
                    else: self.fail_game()
        elif self.game_type == 'LOCKPICK':
            if event.key == pygame.K_SPACE:
                # 타이밍 체크
                current_val = self.lock_cursor
                target_min, target_max = self.lock_targets[self.lock_current_pin]
                
                if target_min <= current_val <= target_max:
                    # 성공! 핀 고정
                    self.lock_pins[self.lock_current_pin] = 1.0 # 고정됨 시각화
                    self.lock_current_pin += 1
                    self.lock_cursor = 0.0 # 다음 핀을 위해 커서 리셋
                    
                    if self.lock_current_pin >= len(self.lock_pins):
                        self.success_game()
                else:
                    # 실패! 패널티 (시간 감소 혹은 처음부터?)
                    # 여기서는 현재 핀만 실패 처리하고 약간의 딜레이 느낌으로 0으로 떨어뜨림
                    self.lock_cursor = 0.0
                    self.start_time -= 1000 # 시간 1초 차감 패널티

    def success_game(self): self.active = False; self.on_success() if self.on_success else None
    def fail_game(self): self.active = False; self.on_fail() if self.on_fail else None

    def draw(self, screen, x, y):
        if not self.active: return

        rect = pygame.Rect(x - self.width//2, y, self.width, self.height)
        pygame.draw.rect(screen, self.bg_color, rect, border_radius=8)
        pygame.draw.rect(screen, self.border_color, rect, 2, border_radius=8)

        now = pygame.time.get_ticks()
        ratio = max(0, 1.0 - (now - self.start_time) / self.duration)
        pygame.draw.rect(screen, (0, 200, 0), (rect.x + 10, rect.y + 10, (self.width-20)*ratio, 4))

        title = self.font_title.render(self.game_type, True, (255, 255, 255))
        screen.blit(title, (rect.centerx - title.get_width()//2, rect.y + 20))
        cx, cy = rect.centerx, rect.centery + 10

        if self.game_type == 'MASHING':
            pygame.draw.rect(screen, (40, 40, 40), (cx-80, cy, 160, 25))
            pygame.draw.rect(screen, (0, 255, 100), (cx-80, cy, 160*(self.mash_progress/100), 25))
            t = self.font_ui.render("Mash SPACE!", True, (200, 200, 200))
            screen.blit(t, (cx - t.get_width()//2, cy + 30))
            
        elif self.game_type == 'TIMING':
            pygame.draw.rect(screen, (40, 40, 40), (cx-100, cy, 200, 25))
            tx, tx2 = self.timing_target
            pygame.draw.rect(screen, (255, 255, 0), (cx-100 + tx, cy, tx2-tx, 25))
            pygame.draw.rect(screen, (255, 255, 255), (cx-100 + self.timing_cursor, cy-2, 3, 29))
            
        elif self.game_type == 'COMMAND':
            start_x = cx - (len(self.cmd_seq)*35)//2
            for i, c in enumerate(self.cmd_seq):
                col = (0, 255, 0) if i < self.cmd_idx else (80, 80, 80)
                if i == self.cmd_idx: col = (255, 255, 0)
                txt = self.font_big.render({'UP':'▲','DOWN':'▼','LEFT':'◀','RIGHT':'▶'}[c], True, col)
                screen.blit(txt, (start_x + i*35, cy-15))
                
        elif self.game_type == 'CIRCLE':
            pygame.draw.circle(screen, (40, 40, 40), (cx, cy), 45, 3)
            tr = math.radians(self.circle_target_angle)
            pygame.draw.circle(screen, (255, 255, 0), (int(cx + math.cos(tr)*45), int(cy + math.sin(tr)*45)), 6)
            ar = math.radians(self.circle_angle)
            pygame.draw.line(screen, (255, 255, 255), (cx, cy), (int(cx + math.cos(ar)*45), int(cy + math.sin(ar)*45)), 2)
            
        elif self.game_type == 'WIRING':
            # [수정] WIRING 게임 렌더링 개선 및 안내 문구 추가
            for i, w in enumerate(self.wires_left):
                wy = rect.y + 55 + i*25
                # 왼쪽 컬러 박스
                pygame.draw.rect(screen, w['color'], (rect.x + 20, wy, 15, 15))
                # 왼쪽 선택 커서 (wire_l_idx)
                if self.wire_state == 0 and self.wire_l_idx == i: 
                    pygame.draw.rect(screen, (255, 255, 255), (rect.x + 18, wy-2, 19, 19), 2)
                # 이미 선택된 왼쪽 항목 (wire_selected_l)
                elif self.wire_selected_l == i: 
                    pygame.draw.rect(screen, (255, 255, 0), (rect.x + 18, wy-2, 19, 19), 2)
                
                # 연결된 선 그리기
                if w['id'] in self.wire_connections:
                    for j, rw in enumerate(self.wires_right):
                        if rw['id'] == self.wire_connections[w['id']]:
                            ry = rect.y + 55 + j*25
                            pygame.draw.line(screen, w['color'], (rect.x+35, wy+7), (rect.right-35, ry+7), 2)
            
            for i, w in enumerate(self.wires_right):
                wy = rect.y + 55 + i*25
                # 오른쪽 컬러 박스
                pygame.draw.rect(screen, w['color'], (rect.right - 35, wy, 15, 15))
                # 오른쪽 선택 커서 (wire_r_idx) - 상태가 1일 때만 표시
                if self.wire_state == 1 and self.wire_r_idx == i: 
                    pygame.draw.rect(screen, (255, 255, 255), (rect.right - 37, wy-2, 19, 19), 2)
                    
            # 하단 도움말
            msg = "Connect Matching Colors!"
            help_txt = self.font_ui.render(msg, True, (180, 180, 180))
            screen.blit(help_txt, (rect.centerx - help_txt.get_width()//2, rect.bottom - 16))

        elif self.game_type == 'MEMORY':
            sx = cx - 50; sy = cy - 45
            for y in range(3):
                for x in range(3):
                    bx, by = sx + x*35, sy + y*35; item = self.memory_grid[y][x]
                    if self.mem_cursor == [x, y]: pygame.draw.rect(screen, (255, 255, 0), (bx-2, by-2, 34, 34), 2)
                    if item:
                        pygame.draw.rect(screen, (0, 150, 0) if item['clicked'] else (50, 50, 60), (bx, by, 30, 30))
                        if not item['clicked']:
                            t = self.font_ui.render(str(item['num']), True, (255, 255, 255))
                            screen.blit(t, (bx + 15 - t.get_width()//2, by + 15 - t.get_height()//2))
                            
        elif self.game_type == 'LOCKPICK':
            # 핀 그리기 설정
            num_pins = len(self.lock_pins)
            pin_w = 20
            pin_gap = 10
            total_w = num_pins * pin_w + (num_pins - 1) * pin_gap
            start_x = cx - total_w // 2
            
            # 기준선 (Lock Cylinder Line)
            pygame.draw.line(screen, (100, 100, 100), (rect.left + 20, cy + 20), (rect.right - 20, cy + 20), 2)
            
            for i in range(num_pins):
                px = start_x + i * (pin_w + pin_gap)
                py_base = cy + 20 # 핀의 바닥 위치
                
                # 타겟 영역 (성공 구간) 표시 (배경에 흐릿하게)
                t_min, t_max = self.lock_targets[i]
                t_h = 40 # 핀 최대 높이
                
                target_y_start = py_base - (t_max * t_h)
                target_height = (t_max - t_min) * t_h
                
                # 현재 핀만 타겟 영역을 진하게 표시
                target_col = (50, 100, 50) 
                if i == self.lock_current_pin: target_col = (100, 200, 100)
                elif i < self.lock_current_pin: target_col = (0, 0, 0) # 이미 성공한 핀은 타겟 안보임
                
                if i >= self.lock_current_pin:
                    pygame.draw.rect(screen, target_col, (px, target_y_start, pin_w, target_height))
                
                # 핀(Pin) 그리기
                pin_val = self.lock_pins[i]
                current_h = pin_val * t_h
                pin_rect = pygame.Rect(px, py_base - current_h, pin_w, current_h)
                
                pin_col = (200, 200, 200) # 기본 핀 색
                if i < self.lock_current_pin: pin_col = (50, 255, 50) # 성공한 핀 (초록)
                elif i == self.lock_current_pin: pin_col = (255, 255, 0) # 현재 핀 (노랑)
                
                pygame.draw.rect(screen, pin_col, pin_rect, border_radius=2)
                
            # 안내 문구
            t = self.font_ui.render("Press SPACE in Green Zone", True, (150, 150, 150))
            screen.blit(t, (cx - t.get_width()//2, rect.bottom - 25))


################################################################################
 FILE: systems\renderer.py
################################################################################

--- [Code Analysis & Settings] ---

  [Class] CharacterRenderer
    [Method] clear_cache(cls)
    [Method] _get_cache_key(cls, entity, is_highlighted)
    [Method] draw_entity(screen, entity, camera_x, camera_y, viewer_role, current_phase, viewer_device_on)

  [Class] MapRenderer
    - Doc: [New] 화면에 보이는 타일만 렌더링하는 최적화된 맵 렌더러 (Culling 적용)
    [Method] __init__(self, map_manager)
    [Method] draw(self, screen, camera, dt)

--- [Full Source Code] ---
import pygame
from settings import *
from colors import *

class CharacterRenderer:
    _sprite_cache = {}
    
    # [추가] 폰트 객체 미리 생성 (클래스 변수)
    pygame.font.init()
    NAME_FONT = pygame.font.SysFont("arial", 11, bold=True)
    POPUP_FONT = pygame.font.SysFont("arial", 12, bold=True)

    # [최적화] 반복 사용되는 Rect 객체 상수화
    RECT_BODY = pygame.Rect(4, 4, 24, 24)
    RECT_CLOTH = pygame.Rect(4, 14, 24, 14)
    RECT_ARM_L = pygame.Rect(8, 14, 4, 14)
    RECT_ARM_R = pygame.Rect(20, 14, 4, 14)
    RECT_HAT_TOP = pygame.Rect(2, 2, 28, 5)
    RECT_HAT_RIM = pygame.Rect(6, 0, 20, 7)

    # [최적화] 텍스트 서피스 캐시 저장소
    _name_surface_cache = {}

    @classmethod
    def clear_cache(cls):
        cls._sprite_cache.clear()
        cls._name_surface_cache.clear()

    @classmethod
    def _get_cache_key(cls, entity, is_highlighted):
        skin_idx = entity.custom.get('skin', 0)
        cloth_idx = entity.custom.get('clothes', 0)
        hat_idx = entity.custom.get('hat', 0)
        facing = getattr(entity, 'facing_dir', (0, 1))
        
        return (
            skin_idx, cloth_idx, hat_idx,
            entity.role, entity.sub_role,
            facing, is_highlighted
        )

    @staticmethod
    def draw_entity(screen, entity, camera_x, camera_y, viewer_role="PLAYER", current_phase="DAY", viewer_device_on=False):
        if not entity.alive: return

        draw_x = entity.rect.x - camera_x
        draw_y = entity.rect.y - camera_y

        screen_w, screen_h = screen.get_width(), screen.get_height()
        if not (-50 < draw_x < screen_w + 50 and -50 < draw_y < screen_h + 50): return

        alpha = 255
        is_highlighted = False

        if viewer_role == "MAFIA" and viewer_device_on:
            is_highlighted = True
            alpha = 255 

        if entity.is_hiding and not is_highlighted:
            is_visible = False
            if getattr(entity, 'is_player', False) or entity.name == "Player 1": is_visible, alpha = True, 120
            elif viewer_role == "SPECTATOR": is_visible, alpha = True, 120
            if not is_visible: return

        cache_key = CharacterRenderer._get_cache_key(entity, is_highlighted)
        
        if cache_key in CharacterRenderer._sprite_cache:
            base_surf = CharacterRenderer._sprite_cache[cache_key]
        else:
            base_surf = pygame.Surface((TILE_SIZE, TILE_SIZE), pygame.SRCALPHA)
            
            skin_idx = entity.custom.get('skin', 0) % len(CUSTOM_COLORS['SKIN'])
            cloth_idx = entity.custom.get('clothes', 0) % len(CUSTOM_COLORS['CLOTHES'])
            body_color = CUSTOM_COLORS['SKIN'][skin_idx]
            clothes_color = CUSTOM_COLORS['CLOTHES'][cloth_idx]

            if is_highlighted:
                body_color = (255, 50, 50)
                clothes_color = (150, 0, 0)

            pygame.draw.ellipse(base_surf, (0, 0, 0, 80), (4, TILE_SIZE - 8, TILE_SIZE - 8, 6))
            pygame.draw.rect(base_surf, body_color, CharacterRenderer.RECT_BODY, border_radius=6)

            if entity.role == "MAFIA":
                if current_phase == "NIGHT":
                    pygame.draw.rect(base_surf, (30, 30, 35), CharacterRenderer.RECT_CLOTH, border_bottom_left_radius=6, border_bottom_right_radius=6)
                    pygame.draw.polygon(base_surf, (180, 0, 0), [(16, 14), (13, 22), (19, 22)])
                else:
                    fake_color = clothes_color
                    if entity.sub_role == "POLICE": fake_color = (20, 40, 120)
                    elif entity.sub_role == "DOCTOR": fake_color = (240, 240, 250)

                    pygame.draw.rect(base_surf, fake_color, CharacterRenderer.RECT_CLOTH, border_bottom_left_radius=6, border_bottom_right_radius=6)
                    if entity.sub_role == "FARMER":
                        pygame.draw.rect(base_surf, (120, 80, 40), CharacterRenderer.RECT_ARM_L)
                        pygame.draw.rect(base_surf, (120, 80, 40), CharacterRenderer.RECT_ARM_R)

            elif entity.role == "DOCTOR":
                pygame.draw.rect(base_surf, (240, 240, 250), CharacterRenderer.RECT_CLOTH, border_bottom_left_radius=6, border_bottom_right_radius=6)
                pygame.draw.rect(base_surf, (255, 50, 50), (14, 16, 4, 10))
                pygame.draw.rect(base_surf, (255, 50, 50), (11, 19, 10, 4))
            elif entity.role == "POLICE":
                pygame.draw.rect(base_surf, (20, 40, 120), CharacterRenderer.RECT_CLOTH, border_bottom_left_radius=6, border_bottom_right_radius=6)
                pygame.draw.circle(base_surf, (255, 215, 0), (10, 18), 3)
            else:
                pygame.draw.rect(base_surf, clothes_color, CharacterRenderer.RECT_CLOTH, border_bottom_left_radius=6, border_bottom_right_radius=6)
                if entity.sub_role == "FARMER":
                    pygame.draw.rect(base_surf, (120, 80, 40), CharacterRenderer.RECT_ARM_L)
                    pygame.draw.rect(base_surf, (120, 80, 40), CharacterRenderer.RECT_ARM_R)

            f_dir = getattr(entity, 'facing_dir', (0, 1))
            ox, oy = f_dir[0] * 3, f_dir[1] * 2
            pygame.draw.circle(base_surf, (255, 255, 255), (16 - 5 + ox, 12 + oy), 3)
            pygame.draw.circle(base_surf, (0, 0, 0), (16 - 5 + ox + f_dir[0], 12 + oy + f_dir[1]), 1)
            pygame.draw.circle(base_surf, (255, 255, 255), (16 + 5 + ox, 12 + oy), 3)
            pygame.draw.circle(base_surf, (0, 0, 0), (16 + 5 + ox + f_dir[0], 12 + oy + f_dir[1]), 1)

            hat_idx = entity.custom.get('hat', 0) % len(CUSTOM_COLORS['HAT'])
            if hat_idx > 0:
                hat_color = CUSTOM_COLORS['HAT'][hat_idx]
                pygame.draw.rect(base_surf, hat_color, CharacterRenderer.RECT_HAT_TOP)
                pygame.draw.rect(base_surf, hat_color, CharacterRenderer.RECT_HAT_RIM)
            
            CharacterRenderer._sprite_cache[cache_key] = base_surf

        final_surf = base_surf
        if alpha < 255:
            final_surf = base_surf.copy()
            final_surf.set_alpha(alpha)

        screen.blit(final_surf, (draw_x, draw_y))

        # [최적화] 텍스트 렌더링 캐싱 시스템 적용
        name_color = (230, 230, 230)

        if entity.role == "POLICE" and viewer_role in ["POLICE", "SPECTATOR"]: name_color = (100, 180, 255)
        elif entity.role == "MAFIA" and viewer_role in ["MAFIA", "SPECTATOR"]: name_color = (255, 100, 100)
        
        # 캐시 키: (엔티티ID 혹은 이름, 색상)
        text_cache_key = (id(entity), entity.name, name_color)
        
        if text_cache_key in CharacterRenderer._name_surface_cache:
            name_surf = CharacterRenderer._name_surface_cache[text_cache_key]
        else:
            name_surf = CharacterRenderer.NAME_FONT.render(entity.name, True, name_color)
            CharacterRenderer._name_surface_cache[text_cache_key] = name_surf

        # 캐릭터 가로 중심(TILE_SIZE/2)에서 텍스트 절반 너비만큼 빼서 중앙 정렬
        text_x = draw_x + (TILE_SIZE // 2) - (name_surf.get_width() // 2)
        screen.blit(name_surf, (text_x, draw_y - 14))

        # [최적화] 팝업 텍스트도 최초 1회만 렌더링 후 p['surface']에 저장하여 재사용
        if hasattr(entity, 'popups'):
            for p in entity.popups[:]:
                if pygame.time.get_ticks() > p['timer']:
                    entity.popups.remove(p)
                    continue
                
                if 'surface' not in p:
                    p['surface'] = CharacterRenderer.POPUP_FONT.render(p['text'], True, p.get('color', (255, 255, 0)))
                
                p_surf = p['surface']
                
                elapsed = 1500 - (p['timer'] - pygame.time.get_ticks())
                offset_y = int(elapsed * 0.03)
                
                # 중앙 정렬
                popup_x = draw_x + (TILE_SIZE // 2) - (p_surf.get_width() // 2)
                popup_y = draw_y - 20 - offset_y
                
                screen.blit(p_surf, (popup_x, popup_y))

from world.tiles import get_texture

class MapRenderer:
    """
    [New] 화면에 보이는 타일만 렌더링하는 최적화된 맵 렌더러 (Culling 적용)
    """
    def __init__(self, map_manager):
        self.map_manager = map_manager

    def draw(self, screen, camera, dt):
        # 1. 카메라가 비추는 영역(Viewport) 계산
        # 화면보다 여유 있게(-1 ~ +1 타일) 그려서 끊김 방지
        vw, vh = camera.width / camera.zoom_level, camera.height / camera.zoom_level
        
        start_col = int(max(0, camera.x // TILE_SIZE))
        start_row = int(max(0, camera.y // TILE_SIZE))
        end_col = int(min(self.map_manager.width, (camera.x + vw) // TILE_SIZE + 2))
        end_row = int(min(self.map_manager.height, (camera.y + vh) // TILE_SIZE + 2))

        # 2. 오프셋 미리 계산
        cam_x, cam_y = camera.x, camera.y
        
        # 3. 최적화된 지역 변수 참조
        floors = self.map_manager.map_data['floor']
        walls = self.map_manager.map_data['wall']
        objects = self.map_manager.map_data['object']

        # 4. 보이는 범위(Viewport)만 이중 반복문 순회
        for r in range(start_row, end_row):
            for c in range(start_col, end_col):
                draw_x = c * TILE_SIZE - cam_x
                draw_y = r * TILE_SIZE - cam_y

                # (1) 바닥 (Floor)
                tile_data = floors[r][c]
                tid = tile_data[0] if isinstance(tile_data, (tuple, list)) else tile_data
                rot = tile_data[1] if isinstance(tile_data, (tuple, list)) else 0
                if tid != 0:
                    img = get_texture(tid, rot)
                    if img: screen.blit(img, (draw_x, draw_y))

                # (2) 벽 (Wall)
                tile_data = walls[r][c]
                tid = tile_data[0] if isinstance(tile_data, (tuple, list)) else tile_data
                rot = tile_data[1] if isinstance(tile_data, (tuple, list)) else 0
                if tid != 0:
                    img = get_texture(tid, rot)
                    if img: screen.blit(img, (draw_x, draw_y))

                # (3) 오브젝트 (Object)
                tile_data = objects[r][c]
                tid = tile_data[0] if isinstance(tile_data, (tuple, list)) else tile_data
                rot = tile_data[1] if isinstance(tile_data, (tuple, list)) else 0
                if tid != 0:
                    img = get_texture(tid, rot)
                    if img: screen.blit(img, (draw_x, draw_y))



################################################################################
 FILE: ui.py
################################################################################

--- [Code Analysis & Settings] ---
  [Global Variable] MINIMAP_COLORS = {Dict with 6 keys}
  [Global Variable] DEFAULT_COLORS = {Dict with 3 keys}

  [Class] UI
    [Method] __init__(self, game)
    [Method] _create_panel_bg(self, w, h)
    [Method] generate_minimap_surface(self)
    [Method] show_alert(self, text, color)
    [Method] toggle_vending_machine(self)
    [Method] toggle_inventory(self)
    [Method] show_daily_news(self, news_log)
    [Method] calculate_game_time(self)
    [Method] draw_emotion_panel(self, screen, w, h)
      - Doc: 플레이어의 감정 상태 및 이동 속도 상세 표시 패널 (우측 하단)
    [Method] draw_minimap(self, screen, w, h, npcs, is_blackout)
      - Doc: 우측 하단, 감정 패널 바로 위에 미니맵 표시
    [Method] draw(self, screen)
    [Method] draw_top_hud(self, screen, w, h)
    [Method] _draw_player_status(self, screen)
      - Doc: 좌측 상단: 플레이어 상태 (HP, AP, Coin, Role)
    [Method] _draw_env_status(self, screen, screen_w)
    [Method] _draw_bar(self, screen, x, y, w, h, ratio, color, label)
    [Method] draw_controls(self, screen, w, h)
    [Method] draw_key_icon(self, screen, x, y, key, label)
    [Method] draw_motion_tracker(self, screen, w, h)
    [Method] draw_police_hud(self, screen, w, h)
    [Method] draw_interaction(self, screen)
    [Method] draw_stamina_bar(self, screen)
    [Method] draw_vote_ui(self, screen, w, h)
    [Method] draw_vote_popup(self, screen, sw, sh, npcs, player, current_target)
    [Method] draw_daily_news(self, screen, w, h)
    [Method] handle_keyboard(self, key, npcs)
    [Method] draw_item_icon(self, screen, key, rect, is_sel)
    [Method] draw_vending_machine(self, screen, w, h)
    [Method] draw_inventory(self, screen, w, h)
    [Method] _draw_spectator_ui(self, screen, w, h)

--- [Full Source Code] ---
import pygame
import math
import random
from settings import *
from colors import *

# 미니맵에 표시할 타일 ID별 색상 정의 (R, G, B)
# 실제 사용하는 타일 ID에 맞춰서 색을 추가/수정해주세요.
MINIMAP_COLORS = {
    # [Floor]
    1110000: (100, 80, 50),    # Dirt (갈색)
    1110001: (34, 139, 34),    # Grass (초록색)
    1110002: (100, 100, 100),  # Stone (회색)
    
    # [Wall]
    3220000: (50, 50, 50),     # Wall (진한 회색)
    
    # [Object]
    5310000: (0, 0, 255),      # Water/Object (파랑)
    8321006: (255, 0, 0),      # Vending Machine (빨강)
}

# 기본 색상 (매핑되지 않은 타일용)
DEFAULT_COLORS = {
    'floor': (40, 40, 40),
    'wall': (100, 100, 100),
    'object': (200, 200, 100)
}

class UI:
    def __init__(self, game):
        self.game = game
        try:
            self.font_main = pygame.font.SysFont("malgungothic", 20)
            self.font_small = pygame.font.SysFont("malgungothic", 14)
            self.font_big = pygame.font.SysFont("malgungothic", 30, bold=True)
            self.font_digit = pygame.font.SysFont("consolas", 18, bold=True)
        except:
            self.font_main = pygame.font.Font(None, 24)
            self.font_small = pygame.font.Font(None, 18)
            self.font_big = pygame.font.Font(None, 40)
            self.font_digit = pygame.font.Font(None, 20)
            
        # [Fix] 참조 편의를 위한 단축 속성 설정 및 미니맵 변수 초기화
        self.map_manager = game.map_manager
        self.player = game.player
        self.minimap_surface = None
        self.radar_timer = 0
        self.radar_blips = []
            
        self.show_news = False
        self.news_timer = 0
        self.news_text = []

        # Motion Tracker Variables
        self.scan_angle = 0
        self.scan_dir = 1
        self.scan_speed = 2
        
        self.dim_surface = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        self.dim_surface.fill((0, 0, 0, 180))

        # [Compatibility]
        self.custom_durations = DEFAULT_PHASE_DURATIONS.copy()

        # [State Variables]
        self.show_vending = False
        self.show_inventory = False
        self.show_voting = False
        self.sel_idx = 0
        
        # Alert System
        self.alert_text = ""
        self.alert_timer = 0
        self.alert_color = (255, 255, 255)

        # Spectator System
        self.spectator_follow_target = None
        self.spectator_scroll_y = 0
        self.entity_rects = []
        self.skip_btn_rect = None

        # [최적화] UI 패널 배경 미리 생성 (매 프레임 생성 방지)
        self.panel_bg_status = self._create_panel_bg(360, 110)
        self.panel_bg_env = self._create_panel_bg(160, 80)
        self.panel_bg_emotion = self._create_panel_bg(220, 140)
        self.panel_bg_police = self._create_panel_bg(200, 120)
        
    # [최적화] 배경 생성 헬퍼 함수
    def _create_panel_bg(self, w, h):
        s = pygame.Surface((w, h), pygame.SRCALPHA)
        pygame.draw.rect(s, (20, 20, 25, 200), (0, 0, w, h), border_radius=10)
        pygame.draw.rect(s, (80, 80, 90, 255), (0, 0, w, h), 2, border_radius=10)
        return s

    # [Fix] 미니맵 생성 함수 추가
    def generate_minimap_surface(self):
        w = self.map_manager.width
        h = self.map_manager.height
        surf = pygame.Surface((w, h))
        surf.fill((20, 20, 25)) # 전체 배경 (아주 어두운 남색)

        # 맵 데이터 가져오기
        floors = self.map_manager.map_data['floor']
        walls = self.map_manager.map_data['wall']
        objects = self.map_manager.map_data['object']
        
        # 픽셀 단위로 접근하기 위해 PixelArray 사용 (속도 향상)
        pixels = pygame.PixelArray(surf)

        for y in range(h):
            for x in range(w):
                # 1. 바닥 (Floor) 그리기
                f_val = floors[y][x]
                f_tid = f_val[0] if isinstance(f_val, (tuple, list)) else f_val
                if f_tid != 0:
                    col = MINIMAP_COLORS.get(f_tid, DEFAULT_COLORS['floor'])
                    pixels[x, y] = col
                
                # 2. 벽 (Wall) 덮어쓰기
                w_val = walls[y][x]
                w_tid = w_val[0] if isinstance(w_val, (tuple, list)) else w_val
                if w_tid != 0:
                    col = MINIMAP_COLORS.get(w_tid, DEFAULT_COLORS['wall'])
                    pixels[x, y] = col
                
                # 3. 사물 (Object) 덮어쓰기
                o_val = objects[y][x]
                o_tid = o_val[0] if isinstance(o_val, (tuple, list)) else o_val
                if o_tid != 0:
                    col = MINIMAP_COLORS.get(o_tid, DEFAULT_COLORS['object'])
                    pixels[x, y] = col
        
        pixels.close() # PixelArray 사용 종료
        self.cached_minimap = None # 캐시 무효화
        return surf

    def show_alert(self, text, color=(255, 255, 255)):
        self.alert_text = text
        self.alert_color = color
        self.alert_timer = pygame.time.get_ticks() + 3000

    def toggle_vending_machine(self):
        self.show_vending = not self.show_vending
        if self.show_vending: self.show_inventory = False; self.show_voting = False; self.sel_idx = 0

    def toggle_inventory(self):
        self.show_inventory = not self.show_inventory
        if self.show_inventory: self.show_vending = False; self.show_voting = False; self.sel_idx = 0

    def show_daily_news(self, news_log):
        self.show_news = True
        self.news_text = news_log if news_log else ["No special news today."]

    def calculate_game_time(self):
        phase = self.game.current_phase
        timer = self.game.state_timer
        
        start_times = {'DAWN': (4, 0), 'MORNING': (6, 0), 'NOON': (8, 0), 'AFTERNOON': (16, 0), 'EVENING': (17, 0), 'NIGHT': (19, 0)}
        phase_lengths = {'DAWN': 120, 'MORNING': 120, 'NOON': 480, 'AFTERNOON': 60, 'EVENING': 120, 'NIGHT': 540}
        
        durations = self.game.game.shared_data.get('custom_durations', DEFAULT_PHASE_DURATIONS)
        total_duration = durations.get(phase, 60)
        elapsed = max(0, total_duration - timer)
        ratio = elapsed / total_duration if total_duration > 0 else 0
        
        start_h, start_m = start_times.get(phase, (0, 0))
        add_minutes = int(phase_lengths.get(phase, 60) * ratio)
        current_minutes = start_m + add_minutes
        current_h = (start_h + current_minutes // 60) % 24
        current_m = current_minutes % 60
        return f"{current_h:02d}:{current_m:02d}"

    def draw_emotion_panel(self, screen, w, h):
        """플레이어의 감정 상태 및 이동 속도 상세 표시 패널 (우측 하단)"""
        player = self.game.player
        if not player or player.role == "SPECTATOR": return
        
        # 속도 계산 (PPS: Pixels Per Second)
        current_speed_frame = player.get_current_speed(getattr(player, 'weather', 'CLEAR'))
        current_speed_px = current_speed_frame * FPS 
        base_speed = 192 # settings.BASE_SPEED_PPS (초당 6타일 기준)
        ratio = (current_speed_px / base_speed) * 100
        
        # 1. 패널 배경 (화면 우측 하단)
        panel_w, panel_h = 220, 140
        x = w - panel_w - 20
        y = h - panel_h - 20
        
        # [최적화] 캐시된 배경 사용
        screen.blit(self.panel_bg_emotion, (x, y))

        # 2. 속도 모니터링
        speed_col = (200, 255, 200) if ratio >= 100 else (255, 100, 100)
        speed_text = self.font_main.render(f"SPEED: {int(current_speed_px)} px/s ({int(ratio)}%)", True, speed_col)
        screen.blit(speed_text, (x + 15, y + 15))

        # 구분선
        pygame.draw.line(screen, (80, 80, 90), (x+15, y+40), (x+panel_w-15, y+40), 1)

        # 3. 감정 및 상태 리스트 출력
        y_offset = 50
        active_statuses = []
        
        # Emotions
        for emo, val in player.emotions.items():
            if val:
                if emo == 'FEAR': active_statuses.append(('FEAR', 'Speed -30%', (100, 100, 255)))
                elif emo == 'RAGE': active_statuses.append(('RAGE', 'Stamina ∞', (255, 50, 50)))
                elif emo == 'PAIN': active_statuses.append(('PAIN', f'Lv.{val} Slow', (255, 100, 100)))
                elif emo == 'HAPPINESS': active_statuses.append(('HAPPY', 'Speed +10%', (255, 255, 100)))
                elif emo == 'ANXIETY': active_statuses.append(('ANXTY', 'Heartbeat', (255, 150, 50)))
            
        # Status Effects
        if player.status_effects.get('FATIGUE'): active_statuses.append(('FATIGUE', 'Speed -30%', (150, 150, 150)))
        if player.status_effects.get('DOPAMINE'): active_statuses.append(('DOPA', 'Speed +20%', (255, 0, 255)))
        
        if not active_statuses:
            text = self.font_small.render("- Normal State -", True, (150, 150, 150))
            screen.blit(text, (x + 15, y + y_offset))
        else:
            for title, desc, color in active_statuses[:4]: # Max 4 items
                text = self.font_small.render(f"■ {title}: {desc}", True, color)
                screen.blit(text, (x + 15, y + y_offset))
                y_offset += 20

    def draw_minimap(self, screen, w, h, npcs, is_blackout):
        """우측 하단, 감정 패널 바로 위에 미니맵 표시"""
        mm_w, mm_h = 200, 150
        x = w - mm_w - 20
        # Y위치: 전체높이 - 감정패널높이(140) - 여백(20) - 미니맵높이(150) - 간격(10)
        y = h - 140 - 20 - mm_h - 10
        
        mm_rect = pygame.Rect(x, y, mm_w, mm_h)
        
        # [수정] 투명도를 지원하는 임시 서피스 생성 및 그리기
        s = pygame.Surface((mm_rect.width, mm_rect.height), pygame.SRCALPHA)
        s.fill((0, 0, 0, 180))
        screen.blit(s, mm_rect.topleft)
        
        pygame.draw.rect(screen, (100, 100, 120), mm_rect, 2)
        
        if not hasattr(self, 'minimap_surface') or not self.minimap_surface: 
            self.minimap_surface = self.generate_minimap_surface()
            
        if self.minimap_surface:
            # [Optimization] 캐싱된 스케일 이미지가 없으면 생성
            if not hasattr(self, 'cached_minimap') or self.cached_minimap is None:
                 self.cached_minimap = pygame.transform.scale(self.minimap_surface, (mm_w - 4, mm_h - 4))
            
            # 저장된 이미지 그리기
            screen.blit(self.cached_minimap, (mm_rect.x + 2, mm_rect.y + 2))
        
        # 플레이어 점
        map_w_px = self.map_manager.width * TILE_SIZE
        map_h_px = self.map_manager.height * TILE_SIZE
        if map_w_px > 0:
            dot_x = mm_rect.x + 2 + (self.player.rect.centerx / map_w_px) * (mm_w - 4)
            dot_y = mm_rect.y + 2 + (self.player.rect.centery / map_h_px) * (mm_h - 4)
            pygame.draw.circle(screen, (0, 255, 0), (int(dot_x), int(dot_y)), 3)

        # 특수 감지 (마피아 레이더, 경찰 CCTV 등)
        if self.player.role == "MAFIA" and is_blackout:
            current_time = pygame.time.get_ticks()
            if current_time > self.radar_timer:
                self.radar_timer = current_time + 2000
                self.radar_blips = []
                for n in npcs:
                    if not n.alive: continue
                    color = (0, 255, 0)
                    if n.role == "POLICE": color = (0, 100, 255)
                    elif n.role == "MAFIA": color = (255, 0, 0)
                    nx = mm_rect.x + 2 + (n.rect.centerx / map_w_px) * (mm_w - 4)
                    ny = mm_rect.y + 2 + (n.rect.centery / map_h_px) * (mm_h - 4)
                    self.radar_blips.append(((int(nx), int(ny)), color))
            for pos, col in self.radar_blips: pygame.draw.circle(screen, col, pos, 4)
        
        elif self.player.device_on:
            if self.player.role == "POLICE" and getattr(self, 'mafia_detected_by_cctv', False):
                for n in npcs:
                    if n.role == "MAFIA" and n.alive:
                        nx = mm_rect.x + 2 + (n.rect.centerx / map_w_px) * (mm_w - 4)
                        ny = mm_rect.y + 2 + (n.rect.centery / map_h_px) * (mm_h - 4)
                        if (pygame.time.get_ticks() // 200) % 2 == 0: pygame.draw.circle(screen, (255, 0, 0), (int(nx), int(ny)), 5)
            elif self.player.role in ["CITIZEN", "DOCTOR"]:
                 for n in npcs:
                    if not n.alive: continue
                    if math.sqrt((self.player.rect.centerx - n.rect.centerx)**2 + (self.player.rect.centery - n.rect.centery)**2) < 400 and getattr(n, 'is_moving', False):
                         nx = mm_rect.x + 2 + (n.rect.centerx / map_w_px) * (mm_w - 4)
                         ny = mm_rect.y + 2 + (n.rect.centery / map_h_px) * (mm_h - 4)
                         pygame.draw.circle(screen, (0, 255, 0), (int(nx), int(ny)), 3)

    def draw(self, screen):
        w, h = screen.get_size()
        
        self.draw_top_hud(screen, w, h)
        self.draw_controls(screen, w, h)
        
        if self.game.player.device_on:
            if self.game.player.role in ["CITIZEN", "DOCTOR"]:
                self.draw_motion_tracker(screen, w, h)
            elif self.game.player.role == "POLICE":
                self.draw_police_hud(screen, w, h)

        # [수정] 우측 하단 정보 패널 (미니맵이 감정 패널 위로)
        if self.game.player.role != "SPECTATOR":
            self.draw_minimap(screen, w, h, self.game.npcs, getattr(self.game, 'is_blackout', False))
            self.draw_emotion_panel(screen, w, h)

        # [추가] 스테미나 바 및 상호작용 바 그리기
        self.draw_stamina_bar(screen)
        self.draw_interaction(screen)
        
        self.draw_vote_ui(screen, w, h)
        
        if self.show_inventory: self.draw_inventory(screen, w, h)
        if self.show_vending: self.draw_vending_machine(screen, w, h)
        
        # Alert Drawing
        if pygame.time.get_ticks() < self.alert_timer:
            font = self.font_big
            txt_surf = font.render(self.alert_text, True, self.alert_color)
            bg_rect = txt_surf.get_rect(center=(w // 2, 150))
            bg_rect.inflate_ip(40, 20)
            
            s = pygame.Surface((bg_rect.width, bg_rect.height), pygame.SRCALPHA)
            s.fill((0, 0, 0, 150))
            screen.blit(s, bg_rect.topleft)
            screen.blit(txt_surf, txt_surf.get_rect(center=bg_rect.center))

        if self.game.player.role == "SPECTATOR":
            self._draw_spectator_ui(screen, w, h)

        self.draw_daily_news(screen, w, h)

    def draw_top_hud(self, screen, w, h):
        self._draw_player_status(screen)
        self._draw_env_status(screen, w)

    def _draw_player_status(self, screen):
        """좌측 상단: 플레이어 상태 (HP, AP, Coin, Role)"""
        p = self.game.player
        x, y = 20, 20
        # [수정] 너비(w)와 높이(h)를 늘려 여유 공간 확보
        w, h = 360, 110  
        
        # [최적화] 캐시된 배경 사용
        screen.blit(self.panel_bg_status, (x, y))

        role_cols = {'CITIZEN': (100, 200, 100), 'POLICE': (50, 50, 255), 
                     'MAFIA': (200, 50, 50), 'DOCTOR': (200, 200, 255), 'SPECTATOR':(100,100,100)}
        c = role_cols.get(p.role, (200, 200, 200))
        
        # 아바타 영역
        avatar_rect = pygame.Rect(x + 15, y + 15, 60, 60)
        pygame.draw.rect(screen, (40, 40, 40), avatar_rect, border_radius=8)
        pygame.draw.rect(screen, c, avatar_rect, 3, border_radius=8)
        
        # 역할 이니셜
        role_char = p.role[0] 
        txt = self.font_big.render(role_char, True, c)
        screen.blit(txt, (avatar_rect.centerx - txt.get_width()//2, avatar_rect.centery - txt.get_height()//2))
        
        # 역할 이름 (아바타 하단)
        role_name = self.font_small.render(p.role, True, (200, 200, 200))
        screen.blit(role_name, (avatar_rect.centerx - role_name.get_width()//2, avatar_rect.bottom + 8))

        # [수정] 바 위치(bar_x)를 오른쪽으로 더 밀어서 'HP', 'AP' 글씨가 아바타와 겹치지 않게 함
        bar_x = x + 130  
        bar_w = 200      # 바 길이도 이에 맞춰 조정

        hp_ratio = max(0, p.hp / p.max_hp)
        self._draw_bar(screen, bar_x, y + 25, bar_w, 12, hp_ratio, (220, 60, 60), "HP")
        
        ap_ratio = max(0, p.ap / p.max_ap)
        self._draw_bar(screen, bar_x, y + 50, bar_w, 12, ap_ratio, (60, 150, 220), "AP")
        
        # 소지금 표시
        coin_txt = self.font_digit.render(f"{p.coins:03d} $", True, (255, 215, 0))
        screen.blit(coin_txt, (bar_x, y + 75))

    def _draw_env_status(self, screen, screen_w):
        game = self.game
        w, h = 160, 80
        x = screen_w - w - 20
        y = 20
        
        # [최적화] 캐시된 배경 사용
        screen.blit(self.panel_bg_env, (x, y))

        time_str = self.calculate_game_time()
        time_col = (100, 255, 100) if game.current_phase in ["MORNING", "DAY", "NOON", "AFTERNOON"] else (255, 100, 100)
        
        time_surf = self.font_big.render(time_str, True, time_col)
        screen.blit(time_surf, (x + w//2 - time_surf.get_width()//2, y + 10))
        
        weather_str = getattr(game, 'weather', 'CLEAR')
        info_str = f"Day {game.day_count} | {weather_str}"
        info_surf = self.font_small.render(info_str, True, (200, 200, 200))
        screen.blit(info_surf, (x + w//2 - info_surf.get_width()//2, y + 50))

    def _draw_bar(self, screen, x, y, w, h, ratio, color, label):
        pygame.draw.rect(screen, (40, 40, 40), (x, y, w, h), border_radius=4)
        fill_w = int(w * ratio)
        if fill_w > 0:
            pygame.draw.rect(screen, color, (x, y, fill_w, h), border_radius=4)
        for i in range(x, x+w, 10):
            pygame.draw.line(screen, (0,0,0,50), (i, y), (i+5, y+h), 1)
        l_surf = self.font_small.render(label, True, (200, 200, 200))
        screen.blit(l_surf, (x - 25, y - 2))

    def draw_controls(self, screen, w, h):
        icon_size = 50
        gap = 10
        start_x = 20
        start_y = h - (icon_size * 2 + gap) - 20 
        
        def get_pos(col, row):
            return start_x + col * (icon_size + gap), start_y + row * (icon_size + gap)

        self.draw_key_icon(screen, *get_pos(0, 0), "I", "인벤토리")
        self.draw_key_icon(screen, *get_pos(1, 0), "Z", "투표")
        self.draw_key_icon(screen, *get_pos(2, 0), "E", "상호작용")
        
        role = self.game.player.role
        if role in ["CITIZEN", "DOCTOR"]:
            q_label = "동체탐지"
        elif role == "POLICE":
            q_label = "사이렌"
        else:
            q_label = "특수스킬"
        
        self.draw_key_icon(screen, *get_pos(0, 1), "Q", q_label)
        self.draw_key_icon(screen, *get_pos(1, 1), "R", "재장전")
        self.draw_key_icon(screen, *get_pos(2, 1), "V", "행동")

    def draw_key_icon(self, screen, x, y, key, label):
        rect = pygame.Rect(x, y, 50, 50)
        # 버튼 배경
        pygame.draw.rect(screen, (40, 40, 50), rect, border_radius=8)
        pygame.draw.rect(screen, (100, 100, 120), rect, 2, border_radius=8)
        
        # 1. 키 텍스트 (상단 배치, 크기 조정)
        text_surf = self.font_main.render(key, True, (255, 255, 255))
        screen.blit(text_surf, (x + 25 - text_surf.get_width()//2, y + 4))
        
        # 2. 라벨 텍스트 (박스 내부 하단 배치)
        lbl_surf = self.font_small.render(label, True, (200, 200, 200))
        # 폰트가 너무 길면 축소 시도 (한글 4글자 대응 등)
        if lbl_surf.get_width() > 46:
            lbl_surf = pygame.transform.smoothscale(lbl_surf, (44, int(lbl_surf.get_height() * (44/lbl_surf.get_width()))))
        screen.blit(lbl_surf, (x + 25 - lbl_surf.get_width()//2, y + 28))

    def draw_motion_tracker(self, screen, w, h):
        player = self.game.player
        if player.role == "SPECTATOR": return
        cx, cy = 340, h - 150 
        radius = 90
        
        frame_rect = pygame.Rect(cx - 100, cy - 110, 200, 240)
        pygame.draw.rect(screen, (30, 35, 30), frame_rect, border_radius=15)
        pygame.draw.rect(screen, (60, 70, 60), frame_rect, 3, border_radius=15)
        screen_rect = pygame.Rect(cx - 85, cy - 90, 170, 170)
        pygame.draw.rect(screen, (10, 25, 15), screen_rect)
        pygame.draw.rect(screen, (40, 60, 40), screen_rect, 2)

        for r in [30, 60, 90]:
            pygame.draw.circle(screen, (30, 80, 30), (cx, cy + 60), r, 1)

        self.scan_angle += self.scan_dir * self.scan_speed
        if self.scan_angle > 45 or self.scan_angle < -45: self.scan_dir *= -1
            
        scan_rad = math.radians(self.scan_angle - 90)
        ex = cx + math.cos(scan_rad) * radius
        ey = (cy + 60) + math.sin(scan_rad) * radius
        pygame.draw.line(screen, (50, 200, 50), (cx, cy + 60), (ex, ey), 2)

        detect_range = 400
        detect_range_sq = detect_range * detect_range # [최적화] 거리 제곱값 미리 계산
        
        targets = []
        for npc in self.game.npcs:
            if not npc.alive: continue
            
            # [최적화] 제곱 거리 사용으로 math.sqrt 호출 제거
            dist_sq = (player.rect.centerx - npc.rect.centerx)**2 + (player.rect.centery - npc.rect.centery)**2
            if dist_sq > detect_range_sq: continue
            
            dx = (npc.rect.centerx - player.rect.centerx) / detect_range
            dy = (npc.rect.centery - player.rect.centery) / detect_range
            tx = cx + dx * radius
            ty = (cy + 60) + dy * radius
            
            if screen_rect.collidepoint(tx, ty):
                targets.append((tx, ty))

        for tx, ty in targets:
            pygame.draw.circle(screen, (150, 255, 150), (int(tx), int(ty)), 4)
            s = pygame.Surface((20, 20), pygame.SRCALPHA)
            pygame.draw.circle(s, (50, 200, 50, 100), (10, 10), 8)
            screen.blit(s, (tx-10, ty-10))

        for i in range(screen_rect.top, screen_rect.bottom, 4):
            pygame.draw.line(screen, (0, 20, 0), (screen_rect.left, i), (screen_rect.right, i), 1)
            
        dist_val = f"{int(detect_range/32)}m"
        lbl = self.font_digit.render(f"RNG: {dist_val}", True, (50, 180, 50))
        screen.blit(lbl, (cx - 30, cy + 90))
        title = self.font_small.render("MOTION TRACKER", True, (150, 150, 150))
        screen.blit(title, (cx - title.get_width()//2, frame_rect.top + 10))

    def draw_police_hud(self, screen, w, h):
        x, y = 240, h - 200
        
        # [최적화] 캐시된 배경 사용
        screen.blit(self.panel_bg_police, (x, y))
        
        t = self.font_main.render("POLICE TERMINAL", True, (100, 200, 255))
        screen.blit(t, (x + 100 - t.get_width()//2, y + 10))
        bullets = getattr(self.game.player, 'bullets_fired_today', 0)
        t2 = self.font_small.render(f"Shots Fired: {bullets}/1", True, (200, 200, 200))
        screen.blit(t2, (x + 20, y + 50))

    def draw_interaction(self, screen):
        player = self.game.player
        if player.e_key_pressed:
            now = pygame.time.get_ticks()
            hold_time = now - player.interaction_hold_timer
            ratio = min(1.0, hold_time / 1000.0)
            
            # [수정] 카메라 오프셋과 줌을 적용한 화면 좌표 계산
            cam_x, cam_y = self.game.camera.x, self.game.camera.y
            zoom = self.game.zoom_level
            
            screen_x = (player.rect.centerx - cam_x) * zoom
            screen_y = (player.rect.centery - cam_y) * zoom
            
            # 캐릭터 머리 위 (약 50px 위)
            draw_x = screen_x
            draw_y = screen_y - (50 * zoom)
            
            w, h = 40, 6
            # 바 배경
            pygame.draw.rect(screen, (50, 50, 50), (draw_x - w//2, draw_y, w, h))
            # 노란색 게이지
            pygame.draw.rect(screen, (255, 255, 0), (draw_x - w//2, draw_y, w * ratio, h))

    def draw_stamina_bar(self, screen):
        # [신규] 스테미나(기력) 표시 함수
        player = self.game.player
        if player.breath_gauge >= 100: return # 기력이 가득 차 있으면 표시 안 함
        
        cam_x, cam_y = self.game.camera.x, self.game.camera.y
        zoom = self.game.zoom_level
        
        screen_x = (player.rect.centerx - cam_x) * zoom
        screen_y = (player.rect.centery - cam_y) * zoom
        
        # 상호작용 바보다 조금 더 위에 표시 (겹치지 않게 -60px)
        draw_x = screen_x
        draw_y = screen_y - (60 * zoom)
        
        w, h = 40, 5
        ratio = max(0, player.breath_gauge / 100.0)
        
        # 배경
        pygame.draw.rect(screen, (30, 30, 30), (draw_x - w//2, draw_y, w, h))
        # 파란색 게이지 (기력)
        pygame.draw.rect(screen, (100, 200, 255), (draw_x - w//2, draw_y, w * ratio, h))
    
    def draw_vote_ui(self, screen, w, h):
        if self.game.current_phase != "VOTE": return
        center_x = w // 2
        msg = self.font_big.render("VOTING SESSION", True, (255, 50, 50))
        screen.blit(msg, (center_x - msg.get_width()//2, 100))
        desc = self.font_main.render("Press 'Z' to Vote", True, (200, 200, 200))
        screen.blit(desc, (center_x - desc.get_width()//2, 140))

    # [Removed] draw_vote_button deleted

    def draw_vote_popup(self, screen, sw, sh, npcs, player, current_target):
        w, h = 400, 500
        cx, cy = sw // 2, sh // 2
        panel_rect = pygame.Rect(cx - w//2, cy - h//2, w, h)
        
        # [최적화] 기존 self.dim_surface 재사용 (매 프레임 Surface 생성 방지)
        if self.dim_surface.get_size() != (sw, sh):
             self.dim_surface = pygame.Surface((sw, sh), pygame.SRCALPHA)
             self.dim_surface.fill((0, 0, 0, 150))
        screen.blit(self.dim_surface, (0, 0))
        
        pygame.draw.rect(screen, (40, 40, 45), panel_rect, border_radius=12)
        pygame.draw.rect(screen, (100, 100, 120), panel_rect, 2, border_radius=12)
        title = self.font_big.render("VOTE TARGET", True, (255, 255, 255))
        screen.blit(title, (cx - title.get_width()//2, panel_rect.top + 20))
        candidates = [player] + [n for n in npcs if n.alive]
        candidate_rects = []
        start_y = panel_rect.top + 80
        for c in candidates:
            row_rect = pygame.Rect(panel_rect.left + 20, start_y, w - 40, 40)
            is_selected = (current_target == c)
            col = (50, 50, 150) if is_selected else (60, 60, 70)
            if row_rect.collidepoint(pygame.mouse.get_pos()):
                col = (80, 80, 100)
            pygame.draw.rect(screen, col, row_rect, border_radius=4)
            info = f"{c.name} ({c.role})"
            t = self.font_main.render(info, True, (220, 220, 220))
            screen.blit(t, (row_rect.left + 10, row_rect.centery - t.get_height()//2))
            candidate_rects.append((c, row_rect))
            start_y += 50
        return candidate_rects

    def draw_daily_news(self, screen, w, h):
        if not self.show_news: return
        screen.blit(self.dim_surface, (0, 0))
        center_x, center_y = w // 2, h // 2
        paper_w, paper_h = 500, 600
        paper_rect = pygame.Rect(center_x - paper_w//2, center_y - paper_h//2, paper_w, paper_h)
        pygame.draw.rect(screen, (240, 230, 200), paper_rect)
        pygame.draw.rect(screen, (100, 90, 80), paper_rect, 4)
        title = self.font_big.render("DAILY NEWS", True, (50, 40, 30))
        screen.blit(title, (center_x - title.get_width()//2, paper_rect.top + 30))
        line_y = paper_rect.top + 80
        pygame.draw.line(screen, (50, 40, 30), (paper_rect.left + 20, line_y), (paper_rect.right - 20, line_y), 2)
        y_offset = 110
        for line in self.news_text:
            t = self.font_main.render(line, True, (20, 20, 20))
            screen.blit(t, (center_x - t.get_width()//2, paper_rect.top + y_offset))
            y_offset += 35
        close_txt = self.font_small.render("Press SPACE to Close", True, (100, 100, 100))
        screen.blit(close_txt, (center_x - close_txt.get_width()//2, paper_rect.bottom - 40))

    def handle_keyboard(self, key, npcs=None):
        if self.show_news:
            if key in [pygame.K_SPACE, pygame.K_RETURN, pygame.K_ESCAPE]: self.show_news = False
            return True
        items_list = list(ITEMS.keys())
        if self.show_vending:
            if key == pygame.K_UP: self.sel_idx = (self.sel_idx - 1) % len(items_list)
            elif key == pygame.K_DOWN: self.sel_idx = (self.sel_idx + 1) % len(items_list)
            elif key == pygame.K_RETURN: return self.player.buy_item(items_list[self.sel_idx])
            elif key in [pygame.K_ESCAPE, pygame.K_e]: self.show_vending = False
            return True
        if self.show_inventory:
            if key == pygame.K_UP: self.sel_idx = (self.sel_idx - 1) % len(items_list)
            elif key == pygame.K_DOWN: self.sel_idx = (self.sel_idx + 1) % len(items_list)
            elif key == pygame.K_RETURN: return self.player.use_item(items_list[self.sel_idx])
            elif key in [pygame.K_ESCAPE, pygame.K_i]: self.show_inventory = False
            return True
        if self.show_voting:
            targets = [n for n in npcs if n.alive] + ([self.player] if self.player.alive else [])
            if not targets: return False
            if key == pygame.K_UP: self.sel_idx = (self.sel_idx - 1) % len(targets)
            elif key == pygame.K_DOWN: self.sel_idx = (self.sel_idx + 1) % len(targets)
            elif key == pygame.K_RETURN: targets[self.sel_idx].vote_count += 1; self.show_voting = False; return "VOTED"
            return True
        if key == pygame.K_ESCAPE:
            self.show_vending = False
            self.show_inventory = False
            self.show_voting = False
            self.show_news = False
            return True
        return False

    def draw_item_icon(self, screen, key, rect, is_sel):
        col = (60, 60, 80) if not is_sel else (100, 100, 150)
        pygame.draw.rect(screen, col, rect, border_radius=5)
        if is_sel: pygame.draw.rect(screen, (255, 255, 0), rect, 2, border_radius=5)
        c = rect.center
        if key == 'TANGERINE': pygame.draw.circle(screen, (255, 165, 0), c, 10)
        elif key == 'CHOCOBAR': pygame.draw.rect(screen, (139, 69, 19), (c[0]-8, c[1]-12, 16, 24))
        elif key == 'MEDKIT': 
            pygame.draw.rect(screen, (255, 255, 255), (c[0]-10, c[1]-8, 20, 16))
            pygame.draw.line(screen, (255, 0, 0), (c[0], c[1]-5), (c[0], c[1]+5), 2); pygame.draw.line(screen, (255, 0, 0), (c[0]-5, c[1]), (c[0]+5, c[1]), 2)
        elif key == 'KEY': pygame.draw.line(screen, (255, 215, 0), (c[0]-5, c[1]+5), (c[0]+5, c[1]-5), 3)
        elif key == 'BATTERY': pygame.draw.rect(screen, (0, 255, 0), (c[0]-6, c[1]-10, 12, 20))
        elif key == 'TASER': pygame.draw.rect(screen, (50, 50, 200), (c[0]-10, c[1]-5, 20, 10))
        else: pygame.draw.circle(screen, (200, 200, 200), c, 5)

    def draw_vending_machine(self, screen, w, h):
        vw, vh = 600, 500; rect_obj = pygame.Rect(w//2 - vw//2, h//2 - vh//2, vw, vh)
        pygame.draw.rect(screen, (20, 20, 30), rect_obj); pygame.draw.rect(screen, (0, 255, 255), rect_obj, 3)
        screen.blit(self.font_big.render("SHOP", True, (0, 255, 255)), (rect_obj.x + 20, rect_obj.y + 20))
        items_list = list(ITEMS.keys())
        grid_cols, slot_size, gap = 5, 60, 15; start_x, start_y = rect_obj.x + 30, rect_obj.y + 70
        for i, key in enumerate(items_list):
            row, col = i // grid_cols, i % grid_cols; x, y = start_x + col * (slot_size + gap), start_y + row * (slot_size + gap)
            self.draw_item_icon(screen, key, pygame.Rect(x, y, slot_size, slot_size), self.sel_idx == i)
        if 0 <= self.sel_idx < len(items_list):
            key = items_list[self.sel_idx]; data = ITEMS[key]; info_y = rect_obj.bottom - 120
            pygame.draw.line(screen, (100, 100, 100), (rect_obj.x, info_y), (rect_obj.right, info_y))
            screen.blit(self.font_main.render(data['name'], True, (255, 255, 255)), (rect_obj.x + 30, info_y + 15))
            screen.blit(self.font_small.render(f"Price: {data['price']}G", True, (255, 215, 0)), (rect_obj.x + 30, info_y + 45))
            screen.blit(self.font_small.render(data['desc'], True, (200, 200, 200)), (rect_obj.x + 30, info_y + 75))

    def draw_inventory(self, screen, w, h):
        iw, ih = 500, 400; rect_obj = pygame.Rect(w//2 - iw//2, h//2 - ih//2, iw, ih)
        pygame.draw.rect(screen, (30, 30, 40), rect_obj); pygame.draw.rect(screen, (255, 255, 0), rect_obj, 2)
        screen.blit(self.font_big.render("INVENTORY", True, (255, 255, 0)), (rect_obj.x + 20, rect_obj.y + 20))
        items_list = list(ITEMS.keys())
        grid_cols, slot_size, gap = 5, 60, 15; start_x, start_y = rect_obj.x + 30, rect_obj.y + 70
        for i, key in enumerate(items_list):
            row, col = i // grid_cols, i % grid_cols; x, y = start_x + col * (slot_size + gap), start_y + row * (slot_size + gap); r = pygame.Rect(x, y, slot_size, slot_size)
            count = self.player.inventory.get(key, 0); self.draw_item_icon(screen, key, r, self.sel_idx == i)
            if count > 0:
                cnt_txt = self.font_small.render(str(count), True, (255, 255, 255))
                screen.blit(cnt_txt, cnt_txt.get_rect(bottomright=(r.right-2, r.bottom-2)))
            else:
                s = pygame.Surface((slot_size, slot_size), pygame.SRCALPHA); s.fill((0, 0, 0, 150)); screen.blit(s, r)
        if 0 <= self.sel_idx < len(items_list):
            key = items_list[self.sel_idx]; data = ITEMS[key]; info_y = rect_obj.bottom - 100
            pygame.draw.line(screen, (100, 100, 100), (rect_obj.x, info_y), (rect_obj.right, info_y))
            screen.blit(self.font_main.render(data['name'], True, (255, 255, 255)), (rect_obj.x + 30, info_y + 15))
            screen.blit(self.font_small.render(f"Owned: {self.player.inventory.get(key,0)}", True, (200, 200, 200)), (rect_obj.x + 30, info_y + 45))
            screen.blit(self.font_small.render(data['desc'], True, (150, 150, 150)), (rect_obj.x + 30, info_y + 70))

    def _draw_spectator_ui(self, screen, w, h):
        # [수정] 버튼 위치 변경 (w - 120 -> w - 300)
        # 환경 정보창이 약 180px 차지하므로 더 왼쪽으로 이동
        self.skip_btn_rect = pygame.Rect(w - 300, 20, 100, 40)
        pygame.draw.rect(screen, (150, 50, 50), self.skip_btn_rect, border_radius=8)
        txt = self.font_small.render("SKIP PHASE", True, (255, 255, 255))
        screen.blit(txt, (self.skip_btn_rect.centerx - txt.get_width()//2, self.skip_btn_rect.centery - txt.get_height()//2))
        
        self.entity_rects = []
        start_y = 80 - self.spectator_scroll_y
        right_panel_x = w - 180
        
        for npc in self.game.npcs:
            if not npc.alive: continue
            
            r = pygame.Rect(right_panel_x, start_y, 160, 30)
            
            if 0 < start_y < h:
                col = (100, 255, 100) if npc.role == "CITIZEN" else ((255, 100, 100) if npc.role == "MAFIA" else (200, 200, 255))
                pygame.draw.rect(screen, (50, 50, 50), r, border_radius=4)
                pygame.draw.rect(screen, col, (r.left, r.top, 5, r.height), border_top_left_radius=4, border_bottom_left_radius=4)
                
                name_txt = self.font_small.render(f"{npc.name} ({npc.role})", True, (200, 200, 200))
                screen.blit(name_txt, (r.left + 10, r.centery - name_txt.get_height()//2))
                
                self.entity_rects.append((r, npc))
            
            start_y += 35


################################################################################
 FILE: world\__init__.py
################################################################################

--- [Code Analysis & Settings] ---
  (No specific structural elements found)

--- [Full Source Code] ---
from .tiles import *
from .map_manager import MapManager



################################################################################
 FILE: world\map_manager.py
################################################################################

--- [Code Analysis & Settings] ---

  [Class] MapManager
    [Method] __init__(self)
    [Method] get_tile(self, gx, gy, layer)
    [Method] get_tile_full(self, gx, gy, layer)
    [Method] set_tile(self, gx, gy, tid, rotation, layer)
    [Method] _update_collision_at(self, x, y)
    [Method] build_collision_cache(self)
    [Method] get_spawn_points(self, zone_id)
    [Method] check_any_collision(self, gx, gy)
    [Method] update_doors(self, dt, entities)
    [Method] _find_state_tile(self, current_tid, find_str, replace_str)
    [Method] open_door(self, gx, gy, layer)
    [Method] close_door(self, gx, gy, layer)
    [Method] lock_door(self, gx, gy, layer)
    [Method] unlock_door(self, gx, gy, layer)
    [Method] load_map(self, filename)
    [Method] build_tile_cache(self)
    [Method] create_default_map(self)
    [Method] is_tile_on_cooldown(self, gx, gy)
    [Method] set_tile_cooldown(self, gx, gy, duration_ms)

--- [Full Source Code] ---
import json
import os
import pygame
from settings import TILE_SIZE
from world.tiles import check_collision, NEW_ID_MAP, TILE_DATA, BED_TILES, HIDEABLE_TILES

class MapManager:
    def __init__(self):
        self.map_data = {
            'floor': [],
            'wall': [],
            'object': []
        }
        self.zone_map = []
        self.collision_cache = []  # [최적화] 충돌 맵 캐시 추가
        self.width = 0
        self.height = 0
        self.spawn_x = 100
        self.spawn_y = 100
        self.tile_cache = {}
        self.tile_cooldowns = {}
        self.open_doors = {}
        
        self.name_to_tid = {data['name']: tid for tid, data in TILE_DATA.items()}

    def get_tile(self, gx, gy, layer='floor'):
        # [최적화] 범위 검사 후 직접 접근 (isinstance 제거)
        if 0 <= gx < self.width and 0 <= gy < self.height:
            # 모든 타일 데이터는 (tid, rot) 튜플 형태임을 보장
            return self.map_data[layer][gy][gx][0]
        return 0

    def get_tile_full(self, gx, gy, layer='floor'):
        if 0 <= gx < self.width and 0 <= gy < self.height:
            return self.map_data[layer][gy][gx]
        return (0, 0)

    def set_tile(self, gx, gy, tid, rotation=0, layer=None):
        if not (0 <= gx < self.width and 0 <= gy < self.height): return
        
        if layer is None:
            # 간단한 ID 범위 체크 (tiles.py의 get_tile_type 로직 인라인화 가능하면 더 좋음)
            if 1000000 <= tid < 3000000: layer = 'floor'
            elif 3000000 <= tid < 5000000: layer = 'wall'
            else: layer = 'object'
            
        # [최적화] 항상 튜플로 저장
        self.map_data[layer][gy][gx] = (tid, rotation)
        
        # [최적화] 타일 변경 시 해당 위치의 충돌 캐시만 즉시 갱신
        self._update_collision_at(gx, gy)

    # [최적화] 단일 타일 충돌 갱신 헬퍼
    def _update_collision_at(self, x, y):
        if not (0 <= x < self.width and 0 <= y < self.height): return
        
        is_blocked = False
        
        # 각 레이어별 충돌 체크
        for layer in ['floor', 'wall', 'object']:
            tid = self.map_data[layer][y][x][0]
            if tid != 0 and check_collision(tid):
                # 예외 타일(이동 가능) 체크
                if tid not in BED_TILES and tid not in HIDEABLE_TILES and tid != 5310005:
                    is_blocked = True
                    break
            
        self.collision_cache[y][x] = is_blocked

    # [최적화] 전체 맵 로드 시 충돌 맵 전체 빌드
    def build_collision_cache(self):
        self.collision_cache = [[False for _ in range(self.width)] for _ in range(self.height)]
        for y in range(self.height):
            for x in range(self.width):
                self._update_collision_at(x, y)

    def get_spawn_points(self, zone_id=1):
        points = []
        for y in range(self.height):
            for x in range(self.width):
                if self.zone_map[y][x] == zone_id:
                    if not self.check_any_collision(x, y):
                        points.append((x * TILE_SIZE, y * TILE_SIZE))
        return points

    def check_any_collision(self, gx, gy):
        # [최적화] 캐시된 2차원 배열 조회로 대체 (O(1))
        # [수정] 맵 밖은 이동 불가(True)로 처리해야 함
        if not (0 <= gx < self.width and 0 <= gy < self.height):
            return True 
        
        return self.collision_cache[gy][gx]

    def update_doors(self, dt, entities):
        now = pygame.time.get_ticks()
        to_close = []
        
        # [최적화] 살아있는 엔티티의 Rect만 미리 계산 (배치 처리)
        # collidelist 사용을 위해 Rect 리스트 생성
        active_rects = [ent.rect.inflate(-15, -15) for ent in entities if ent.alive]
        
        for (gx, gy), open_time in list(self.open_doors.items()):
            if now < open_time + 5000: continue 

            door_rect = pygame.Rect(gx * TILE_SIZE, gy * TILE_SIZE, TILE_SIZE, TILE_SIZE)
            
            # [최적화] 파이썬 루프 대신 C로 구현된 collidelist 사용
            # 충돌하는 엔티티가 하나라도 있으면 닫지 않음
            if door_rect.collidelist(active_rects) != -1:
                continue
            
            to_close.append((gx, gy))
        
        for (gx, gy) in to_close:
            self.close_door(gx, gy)

    def _find_state_tile(self, current_tid, find_str, replace_str):
        if current_tid not in TILE_DATA: return None
        current_name = TILE_DATA[current_tid]['name']
        
        target_name = current_name.replace(find_str, replace_str)
        
        if target_name in self.name_to_tid:
            return self.name_to_tid[target_name]

        korean_map = {"Closed": "닫힘", "Open": "열림", "Locked": "잠김"}
        
        if find_str in korean_map and replace_str in korean_map:
            k_find = korean_map[find_str]
            k_replace = korean_map[replace_str]
            target_name_fixed = target_name.replace(k_find, k_replace)
            if target_name_fixed in self.name_to_tid:
                return self.name_to_tid[target_name_fixed]
                
        return None

    def open_door(self, gx, gy, layer='object'):
        tid, rot = self.get_tile_full(gx, gy, layer)
        target_tid = self._find_state_tile(tid, "Closed", "Open")
        if not target_tid:
            target_tid = self._find_state_tile(tid, "Locked", "Open")
            
        if target_tid:
            self.set_tile(gx, gy, target_tid, rotation=rot, layer=layer)
            self.open_doors[(gx, gy)] = pygame.time.get_ticks()

    def close_door(self, gx, gy, layer='object'):
        tid, rot = self.get_tile_full(gx, gy, layer)
        target_tid = self._find_state_tile(tid, "Open", "Closed")
        
        if target_tid:
            self.set_tile(gx, gy, target_tid, rotation=rot, layer=layer)
            if (gx, gy) in self.open_doors: del self.open_doors[(gx, gy)]

    def lock_door(self, gx, gy, layer='object'):
        tid, rot = self.get_tile_full(gx, gy, layer)
        target_tid = self._find_state_tile(tid, "Closed", "Locked")
        
        if target_tid:
            self.set_tile(gx, gy, target_tid, rotation=rot, layer=layer)
            return True
        return False

    def unlock_door(self, gx, gy, layer='object'):
        tid, rot = self.get_tile_full(gx, gy, layer)
        target_tid = self._find_state_tile(tid, "Locked", "Closed")
        
        if target_tid:
            self.set_tile(gx, gy, target_tid, rotation=rot, layer=layer)
            return True
        return False

    def load_map(self, filename="map.json"):
        if not os.path.exists(filename): self.create_default_map(); return True
        try:
            with open(filename, 'r', encoding='utf-8') as f: data = json.load(f)
            self.width, self.height = data.get('width', 50), data.get('height', 50)
            
            # 맵 데이터 초기화
            for k in self.map_data:
                self.map_data[k] = [[(0, 0) for _ in range(self.width)] for _ in range(self.height)]
            
            if 'layers' in data:
                loaded_layers = data['layers']
                for ln in ['floor', 'wall', 'object']:
                    if ln in loaded_layers:
                        grid = loaded_layers[ln]
                        for y in range(min(len(grid), self.height)):
                            for x in range(min(len(grid[y]), self.width)):
                                val = grid[y][x]
                                # [최적화] 로드 시점에 항상 튜플로 변환하여 저장
                                self.map_data[ln][y][x] = (val, 0) if isinstance(val, int) else tuple(val)
            elif 'tiles' in data:
                old_tiles = data['tiles']
                for y in range(min(len(old_tiles), self.height)):
                    for x in range(min(len(old_tiles[y]), self.width)):
                        new_id = NEW_ID_MAP.get(old_tiles[y][x], old_tiles[y][x])
                        self.set_tile(x, y, new_id)
                        
            self.zone_map = data.get('zones', [[0 for _ in range(self.width)] for _ in range(self.height)])
            # [최적화] 맵 로드 후 캐시 생성
            self.build_collision_cache()
            self.build_tile_cache()
            
            for y in range(self.height):
                for x in range(self.width):
                    if self.zone_map[y][x] == 1: 
                        self.spawn_x, self.spawn_y = x * TILE_SIZE, y * TILE_SIZE
                        break
            return True
        except Exception as e:
            import traceback; traceback.print_exc(); self.create_default_map(); return True

    def build_tile_cache(self):
        self.tile_cache = {}
        for ln in ['floor', 'wall', 'object']:
            grid = self.map_data[ln]
            for y in range(len(grid)):
                for x in range(len(grid[y])):
                    tid = grid[y][x][0]
                    if tid == 0: continue
                    if tid not in self.tile_cache: self.tile_cache[tid] = []
                    self.tile_cache[tid].append((x * TILE_SIZE, y * TILE_SIZE))
        return self.tile_cache

    def create_default_map(self):
        self.width, self.height = 40, 30
        for k in self.map_data: self.map_data[k] = [[(0,0) for _ in range(self.width)] for _ in range(self.height)]
        for y in range(self.height):
            for x in range(self.width): self.set_tile(x, y, 1110000)
        for x in range(self.width):
            self.set_tile(x, 0, 3220000); self.set_tile(x, self.height-1, 3220000)
        for y in range(self.height):
            self.set_tile(0, y, 3220000); self.set_tile(self.width-1, y, 3220000)
            
        self.zone_map = [[0 for _ in range(self.width)] for _ in range(self.height)]
        for y in range(2, 5):
            for x in range(2, 5): self.zone_map[y][x] = 1
        self.open_doors = {}
        self.build_tile_cache()
        self.build_collision_cache() # [최적화]

    def is_tile_on_cooldown(self, gx, gy):
        now = pygame.time.get_ticks()
        if (gx, gy) in self.tile_cooldowns:
            if now < self.tile_cooldowns[(gx, gy)]: return True
            else: del self.tile_cooldowns[(gx, gy)]
        return False

    def set_tile_cooldown(self, gx, gy, duration_ms=3000):
        self.tile_cooldowns[(gx, gy)] = pygame.time.get_ticks() + duration_ms


################################################################################
 FILE: world\tiles.py
################################################################################

--- [Code Analysis & Settings] ---
  [Global Variable] P = {Dict with 37 keys}
  [Global Variable] TEXTURE_CACHE = {Dict with 0 keys}
  [Global Variable] CACHE_DIR = cache_tiles
  [Global Variable] MAX_CACHE_SIZE_MB = 50
  [Global Variable] TILE_DATA = {Dict with 110 keys}
  [Global Variable] NEW_ID_MAP = {Dict with 103 keys}
  [Global Variable] BED_TILES = [List with 2 elements]
  [Global Variable] HIDEABLE_TILES = [List with 6 elements]

  [Function] cleanup_disk_cache()
    - Doc: 디스크 캐시 용량이 한계를 초과하면 오래된 파일부터 삭제

  [Function] clear_memory_cache()
    - Doc: 메모리(RAM) 캐시 비우기 - 맵 변경 시 호출 권장

  [Function] get_texture(tid, rotation)
    - Doc: 캐시된 텍스처를 반환하거나 생성하여 저장 (Disk Cache 적용)

  [Function] get_tile_category(tid)

  [Function] get_tile_type(tid)

  [Function] check_collision(tid)

  [Function] get_tile_interaction(tid)

  [Function] get_tile_hiding(tid)

  [Function] get_tile_name(tid)

  [Function] get_tile_function(tid)

  [Function] fill(s, c)

  [Function] rect(s, c, r, w)

  [Function] line(s, c, p1, p2, w)

  [Function] circle(s, c, p, r, w)

  [Function] pixel(s, c, p)

  [Function] poly(s, c, pts, w)

  [Function] blend(c1, c2, r)

  [Function] noise_color(color, intensity)

  [Function] draw_pro_noise(surf, color, intensity)

  [Function] draw_pixel_bevel(surf, rect_obj, base_col, light_col, dark_col, thickness)

  [Function] draw_wood_base(surf, color, vertical)

  [Function] draw_brick_base(surf, color)

  [Function] draw_grass_detailed(surf, base_col)

  [Function] draw_10001(s)

  [Function] draw_10002(s)

  [Function] draw_10003(s)

  [Function] draw_10004(s)

  [Function] draw_10005(s)

  [Function] draw_10006(s)

  [Function] draw_10007(s)

  [Function] draw_10008(s)

  [Function] draw_10009(s)

  [Function] draw_10010(s)

  [Function] draw_10011(s)

  [Function] draw_10012(s)

  [Function] draw_10013(s)

  [Function] draw_10014(s)

  [Function] draw_10015(s)

  [Function] draw_10016(s)

  [Function] draw_10017(s)

  [Function] draw_10018(s)

  [Function] draw_10019(s)

  [Function] draw_10020(s)

  [Function] draw_11001(s)

  [Function] draw_11002(s)

  [Function] draw_11003(s)

  [Function] draw_21001(s)

  [Function] draw_21002(s)

  [Function] draw_21003(s)

  [Function] draw_21004(s)

  [Function] draw_21005(s)

  [Function] draw_21006(s)

  [Function] draw_21007(s)

  [Function] draw_21008(s)

  [Function] draw_21009(s)

  [Function] draw_21010(s)

  [Function] draw_21011(s)

  [Function] draw_21012(s)

  [Function] draw_21013(s)

  [Function] draw_21014(s)

  [Function] draw_21015(s)

  [Function] draw_21016(s)

  [Function] draw_21017(s)

  [Function] draw_door(s, tid, name, col)

  [Function] draw_chest(s, tid, name)

  [Function] draw_40101(s)

  [Function] draw_40102(s)

  [Function] draw_40103(s)

  [Function] draw_40104(s)

  [Function] draw_40105(s)

  [Function] draw_flower(s, col)

  [Function] draw_40001(s)

  [Function] draw_40002(s)

  [Function] draw_40003(s)

  [Function] draw_40004(s)

  [Function] draw_40005(s)

  [Function] draw_41001(s)

  [Function] draw_41002(s)

  [Function] draw_41003(s)

  [Function] draw_41004(s)

  [Function] draw_41005(s)

  [Function] draw_41006(s)

  [Function] draw_51201(s)

  [Function] draw_51202(s)

  [Function] draw_51203(s)

  [Function] draw_51204(s)

  [Function] draw_51205(s)

  [Function] draw_51206(s)

  [Function] draw_51207(s)

  [Function] draw_51208(s)

  [Function] draw_51001(s)

  [Function] draw_51002(s)

  [Function] draw_51003(s)

  [Function] draw_51004(s)

  [Function] draw_51005(s)

  [Function] draw_51006(s)

  [Function] draw_51007(s)

  [Function] draw_51008(s)

  [Function] draw_51301(s)

  [Function] draw_51302(s)

  [Function] draw_51303(s)

  [Function] draw_51305(s)

  [Function] draw_51309(s)

  [Function] draw_51310(s)

  [Function] draw_51311(s)

  [Function] draw_51312(s)

  [Function] draw_farm(s, tid, name)

  [Function] draw_61001(s)

  [Function] draw_61002(s)

  [Function] draw_61003(s)

  [Function] draw_61004(s)

  [Function] draw_61005(s)

  [Function] draw_60001(s)

  [Function] draw_60002(s)

  [Function] draw_60003(s)

  [Function] create_texture(tid)

--- [Full Source Code] ---
import pygame
import random
import math
import os
import glob
import time

P = {
    'VOID': (5, 5, 8),
    'WHITE': (200, 200, 205), 'BLACK': (25, 25, 30),
    'GREY_L': (150, 150, 160), 'GREY_M': (100, 100, 110), 'GREY_D': (50, 50, 60),
    'RED': (150, 50, 50), 'GREEN': (50, 90, 50), 'BLUE': (50, 70, 130),
    'YELLOW': (170, 150, 40), 'ORANGE': (150, 80, 30),
    'BROWN_L': (130, 100, 60), 'BROWN_M': (90, 60, 40), 'BROWN_D': (50, 35, 20),
    'WOOD_BASE': (90, 50, 30), 'WOOD_LIGHT': (120, 80, 50), 'WOOD_SHADOW': (50, 25, 15),
    'STONE_BASE': (70, 75, 85), 'STONE_LIGHT': (100, 105, 115), 'STONE_SHADOW': (40, 40, 50),
    'CONCRETE': (110, 110, 115), 'ASPHALT': (50, 50, 55), 'MARBLE': (200, 200, 210),
    'WATER_BASE': (40, 60, 100), 'WATER_LIGHT': (80, 120, 200), 'ICE_BASE': (180, 210, 230),
    'DIRT_BASE': (80, 65, 45), 'SAND_BASE': (170, 160, 110),
    'GRASS_BASE': (40, 70, 50), 'GRASS_LIGHT': (70, 110, 70), 'GRASS_SHADOW': (20, 35, 20),
    'BRICK_RED': (120, 50, 40), 'GOLD': (180, 140, 40), 'LAMP_ON': (255, 240, 180),
    'METAL_BASE': (90, 90, 95), 'METAL_LIGHT': (140, 140, 150), 'METAL_RUST': (110, 60, 50),
}

# --- 캐시 설정 ---
TEXTURE_CACHE = {}
CACHE_DIR = "cache_tiles"
MAX_CACHE_SIZE_MB = 50  # 최대 디스크 캐시 용량 (MB)

if not os.path.exists(CACHE_DIR):
    os.makedirs(CACHE_DIR)

def cleanup_disk_cache():
    """디스크 캐시 용량이 한계를 초과하면 오래된 파일부터 삭제"""
    try:
        files = glob.glob(os.path.join(CACHE_DIR, "*.png"))
        total_size = sum(os.path.getsize(f) for f in files)
        limit_size = MAX_CACHE_SIZE_MB * 1024 * 1024

        if total_size > limit_size:
            # 수정 시간(mtime) 기준 오름차순 정렬 (오래된 순)
            files.sort(key=os.path.getmtime)
            
            deleted_size = 0
            for f in files:
                sz = os.path.getsize(f)
                try:
                    os.remove(f)
                    deleted_size += sz
                    # 용량이 충분히 확보되면 중단 (여유분 10% 확보)
                    if total_size - deleted_size < limit_size * 0.9:
                        break
                except OSError:
                    pass
            print(f"[System] Cache Cleanup: Freed {deleted_size / (1024*1024):.2f} MB")
    except Exception as e:
        print(f"[System] Cache Cleanup Error: {e}")

def clear_memory_cache():
    """메모리(RAM) 캐시 비우기 - 맵 변경 시 호출 권장"""
    TEXTURE_CACHE.clear()

# 모듈 로드 시 한 번 실행하여 디스크 용량 관리
cleanup_disk_cache()

def get_texture(tid, rotation=0):
    """캐시된 텍스처를 반환하거나 생성하여 저장 (Disk Cache 적용)"""
    key = (tid, rotation)

    # 1. 메모리 캐시 확인
    if key in TEXTURE_CACHE:
        return TEXTURE_CACHE[key]

    # 2. 디스크 캐시 확인
    filename = os.path.join(CACHE_DIR, f"tile_{tid}_{rotation}.png")
    if os.path.exists(filename):
        try:
            surf = pygame.image.load(filename).convert_alpha()
            TEXTURE_CACHE[key] = surf
            return surf
        except Exception as e:
            # 파일 손상 시 삭제 후 재생성
            try: os.remove(filename)
            except: pass

    # 3. 텍스처 신규 생성
    surf = create_texture(tid)

    if rotation != 0:
        surf = pygame.transform.rotate(surf, rotation)

    # 생성된 텍스처를 디스크에 저장
    try:
        pygame.image.save(surf, filename)
    except Exception as e:
        print(f"Error saving cache for {tid}: {e}")

    TEXTURE_CACHE[key] = surf
    return surf

def get_tile_category(tid): return tid // 1000000
def get_tile_type(tid): return (tid // 100000) % 10
def check_collision(tid): return ((tid // 10000) % 10) == 2
def get_tile_interaction(tid): return (tid // 1000) % 10
def get_tile_hiding(tid): return (tid // 100) % 10
def get_tile_name(tid): return TILE_DATA.get(tid, {}).get('name', 'Unknown')
def get_tile_function(tid): return get_tile_hiding(tid)

def fill(s, c): s.fill(c)
def rect(s, c, r, w=0, **kwargs): pygame.draw.rect(s, c, r, w, **kwargs)
def line(s, c, p1, p2, w=1, **kwargs): pygame.draw.line(s, c, p1, p2, w, **kwargs)
def circle(s, c, p, r, w=0, **kwargs): pygame.draw.circle(s, c, p, r, w, **kwargs)
def pixel(s, c, p): s.set_at(p, c)
def poly(s, c, pts, w=0, **kwargs): pygame.draw.polygon(s, c, pts, w, **kwargs)

def blend(c1, c2, r):
    return (int(c1[0]*(1-r)+c2[0]*r), int(c1[1]*(1-r)+c2[1]*r), int(c1[2]*(1-r)+c2[2]*r))

def noise_color(color, intensity=15):
    var = random.randint(-intensity, intensity)
    return (max(0, min(255, color[0]+var)), max(0, min(255, color[1]+var)), max(0, min(255, color[2]+var)))

def draw_pro_noise(surf, color, intensity=20):
    surf.fill(color)
    for _ in range(150):
        x, y = random.randint(0, 31), random.randint(0, 31)
        pixel(surf, noise_color(color, intensity), (x, y))

def draw_pixel_bevel(surf, rect_obj, base_col, light_col, dark_col, thickness=1):
    pygame.draw.rect(surf, base_col, rect_obj)
    pygame.draw.line(surf, dark_col, rect_obj.bottomleft, (rect_obj.right, rect_obj.bottom), thickness)
    pygame.draw.line(surf, dark_col, (rect_obj.right-1, rect_obj.top), (rect_obj.right-1, rect_obj.bottom), thickness)
    pygame.draw.line(surf, light_col, rect_obj.topleft, (rect_obj.right, rect_obj.top), thickness)
    pygame.draw.line(surf, light_col, rect_obj.topleft, (rect_obj.left, rect_obj.bottom), thickness)

def draw_wood_base(surf, color, vertical=False):
    dark = blend(color, P['BLACK'], 0.3)
    draw_pro_noise(surf, color, 15)
    if vertical:
        for x in range(0, 32, 8):
            line(surf, dark, (x, 0), (x, 31))
    else:
        for y in range(0, 32, 8):
            line(surf, dark, (0, y), (31, y))

def draw_brick_base(surf, color):
    fill(surf, P['GREY_D'])
    for y in range(0, 32, 8):
        off = 8 if (y // 8) % 2 else 0
        for x in range(off - 16, 32, 16):
            r_obj = pygame.Rect(x + 1, y + 1, 14, 6)
            draw_pixel_bevel(surf, r_obj, color, blend(color, P['WHITE'], 0.15), blend(color, P['BLACK'], 0.3))

def draw_grass_detailed(surf, base_col):
    fill(surf, base_col)
    light, shadow = P['GRASS_LIGHT'], P['GRASS_SHADOW']
    for _ in range(15):
        cx, cy = random.randint(2, 28), random.randint(2, 28)
        line(surf, shadow, (cx, cy), (cx, cy+3), 1)
        pixel(surf, light, (cx-1, cy-1))
        pixel(surf, light, (cx+1, cy-1))
        pixel(surf, light, (cx, cy))

def draw_10001(s):
    draw_pro_noise(s, P['DIRT_BASE'], 25)

def draw_10002(s):
    fill(s, P['GRASS_BASE'])
    for _ in range(15):
        cx, cy = random.randint(2, 28), random.randint(2, 28)
        line(s, P['GRASS_SHADOW'], (cx, cy), (cx, cy+3))
        pixel(s, P['GRASS_LIGHT'], (cx-1, cy-1))

def draw_10003(s):
    draw_pro_noise(s, P['GREY_M'], 10)
    for _ in range(15):
        circle(s, P['GREY_D'], (random.randint(4,27), random.randint(4,27)), 2)

def draw_10004(s):
    draw_pro_noise(s, P['SAND_BASE'], 10)
    for y in [10, 22]:
        for x in range(0, 32, 4):
            pixel(s, P['BROWN_L'], (x, y + int(math.sin(x)*2)))

def draw_10005(s):
    fill(s, P['WATER_BASE'])
    for y in range(4, 32, 8):
        line(s, P['WHITE'], (4, y), (12, y), 1)

def draw_10006(s):
    draw_pro_noise(s, P['STONE_SHADOW'], 40)
    for _ in range(3):
        circle(s, P['BLACK'], (random.randint(5,25), random.randint(5,25)), 4)

def draw_10007(s):
    draw_pro_noise(s, P['STONE_BASE'], 20)
    for _ in range(6):
        circle(s, P['GREEN'], (random.randint(4,27), random.randint(4,27)), random.randint(3,6))

def draw_10008(s):
    draw_pro_noise(s, P['WOOD_LIGHT'], 15)
    for y in range(0, 32, 8):
        line(s, P['BROWN_D'], (0, y), (31, y))

def draw_10009(s):
    draw_pro_noise(s, P['WOOD_BASE'], 15)
    for x in range(0, 32, 8):
        line(s, P['BROWN_D'], (x, 0), (x, 31))

def draw_10010(s):
    draw_pro_noise(s, P['WHITE'], 5)
    for _ in range(3):
        line(s, P['GREY_L'], (random.randint(0,31), 0), (random.randint(0,31), 31))

def draw_10011(s):
    for y in range(0, 32, 16):
        for x in range(0, 32, 16):
            c = P['WHITE'] if (x+y)%32==0 else P['GREY_M']
            rect(s, c, (x, y, 16, 16))
            rect(s, P['BLACK'], (x, y, 16, 16), 1)

def draw_10012(s):
    draw_pro_noise(s, P['RED'], 5)
    rect(s, P['GOLD'], (2, 2, 28, 28), 1)
    circle(s, P['GOLD'], (16, 16), 4, 1)

def draw_10013(s):
    draw_pro_noise(s, P['BLUE'], 5)
    for i in range(4, 32, 8):
        line(s, P['WHITE'], (i, 4), (i, 28))

def draw_10014(s):
    draw_pro_noise(s, P['CONCRETE'], 10)
    rect(s, P['GREY_D'], (4, 4, 2, 2))
    rect(s, P['GREY_D'], (24, 24, 2, 2))

def draw_10015(s):
    draw_pro_noise(s, P['ASPHALT'], 30)
    for _ in range(20):
        pixel(s, P['GREY_L'], (random.randint(0,31), random.randint(0,31)))

def draw_10016(s):
    draw_pro_noise(s, P['ASPHALT'], 20)
    rect(s, P['WHITE'], (12, 2, 8, 28))

def draw_10017(s):
    draw_pro_noise(s, P['CONCRETE'], 15)
    line(s, P['BLACK'], (16, 16), (4, 4))
    line(s, P['BLACK'], (16, 16), (28, 10))

def draw_10018(s):
    draw_pro_noise(s, P['WHITE'], 5)
    rect(s, P['GREY_L'], (0, 0, 32, 32), 1)
    line(s, P['GREY_L'], (16, 0), (16, 31))
    line(s, P['GREY_L'], (0, 16), (31, 16))

def draw_10019(s):
    fill(s, P['BLACK'])
    for i in range(4, 32, 8):
        line(s, P['METAL_BASE'], (i, 0), (i, 31), 2)
        line(s, P['METAL_BASE'], (0, i), (31, i), 2)

def draw_10020(s):
    draw_pro_noise(s, P['ICE_BASE'], 5)
    line(s, (255, 255, 255, 150), (5, 5), (20, 25), 2)

def draw_11001(s):
    fill(s, (20, 30, 60))
    for y in range(0, 32, 4):
        line(s, (10, 20, 40), (0, y), (31, y))

def draw_11002(s):
    fill(s, P['RED'])
    for _ in range(5):
        circle(s, P['ORANGE'], (random.randint(4, 27), random.randint(4, 27)), 5)
    for _ in range(3):
        pixel(s, P['BLACK'], (random.randint(0, 31), random.randint(0, 31)))

def draw_11003(s):
    fill(s, P['BROWN_D'])
    poly(s, P['BLACK'], [(0, 0), (15, 0), (0, 31)])

def draw_21001(s):
    fill(s, P['GREY_D'])
    for y in range(0, 32, 8):
        off = 8 if (y//8)%2 else 0
        for x in range(off-16, 32, 16):
            rect(s, P['BRICK_RED'], (x+1, y+1, 14, 6))

def draw_21002(s):
    fill(s, P['BLACK'])
    for y in range(0, 32, 8):
        for x in range(0, 32, 8):
            rect(s, P['STONE_BASE'], (x+1, y+1, 6, 6))

def draw_21003(s):
    fill(s, P['STONE_BASE'])
    for y in range(0, 32, 8):
        off = 8 if (y // 8) % 2 else 0
        for x in range(off - 16, 32, 16):
            r_obj = pygame.Rect(x + 1, y + 1, 14, 6)
            draw_pixel_bevel(s, r_obj, P['STONE_BASE'], P['STONE_LIGHT'], P['STONE_SHADOW'])
    for _ in range(4):
        circle(s, blend(P['GREEN'], P['BLACK'], 0.2), (random.randint(5, 25), random.randint(5, 25)), random.randint(4, 7))

def draw_21004(s):
    dark = blend(P['WOOD_BASE'], P['BLACK'], 0.3)
    draw_pro_noise(s, P['WOOD_BASE'], 15)
    for x in range(0, 32, 8):
        line(s, dark, (x, 0), (x, 31))

def draw_21005(s):
    dark = blend(P['WOOD_SHADOW'], P['BLACK'], 0.3)
    draw_pro_noise(s, P['WOOD_SHADOW'], 15)
    for y in range(0, 32, 8):
        line(s, dark, (0, y), (31, y))

def draw_21006(s):
    draw_pro_noise(s, P['WHITE'], 8)
    rect(s, P['GREY_M'], (0, 30, 32, 2))

def draw_21007(s):
    draw_pro_noise(s, (200, 160, 160), 5)
    for y in range(4, 32, 12):
        for x in range(4, 32, 12):
            poly(s, P['RED'], [(x, y-3), (x+3, y), (x, y+3), (x-3, y)])

def draw_21008(s):
    fill(s, (220, 230, 255))
    for i in range(0, 32, 8):
        line(s, (180, 190, 220), (i, 0), (i, 31))
        line(s, (180, 190, 220), (0, i), (31, i))

def draw_21009(s):
    draw_pixel_bevel(s, pygame.Rect(0, 0, 32, 32), P['METAL_LIGHT'], P['WHITE'], P['BLACK'])
    circle(s, P['GREY_D'], (4, 4), 1)
    circle(s, P['GREY_D'], (28, 28), 1)

def draw_21010(s):
    draw_pro_noise(s, P['METAL_BASE'], 10)
    for _ in range(12):
        circle(s, P['METAL_RUST'], (random.randint(0, 31), random.randint(0, 31)), random.randint(2, 4))

def draw_21011(s):
    fill(s, (150, 200, 255, 100))
    line(s, P['WHITE'], (5, 31), (31, 5), 2)

def draw_21012(s):
    fill(s, (150, 200, 255, 120))
    for i in range(0, 32, 8):
        line(s, P['BLACK'], (i, 0), (i, 31))
        line(s, P['BLACK'], (0, i), (31, i))

def draw_21013(s):
    draw_pro_noise(s, P['BROWN_M'], 15)
    for x in range(0, 32, 8):
        line(s, P['BLACK'], (x, 0), (x, 31))
    for y in [6, 16, 26]:
        rect(s, P['BLACK'], (2, y, 28, 2))
        for x in range(4, 28, 4):
            if random.random() > 0.3:
                rect(s, random.choice([P['RED'], P['BLUE'], P['WHITE']]), (x, y-4, 3, 4))

def draw_21014(s):
    draw_pro_noise(s, P['STONE_SHADOW'], 40)
    line(s, P['BLACK'], (0, 10), (12, 15), 2)
    line(s, P['BLACK'], (12, 15), (31, 12), 2)

def draw_21015(s):
    fill(s, (0, 0, 0, 0))
    rect(s, P['BROWN_M'], (4, 0, 6, 32))
    rect(s, P['BROWN_M'], (22, 0, 6, 32))
    rect(s, P['BROWN_D'], (0, 6, 32, 4))
    rect(s, P['BROWN_D'], (0, 22, 32, 4))

def draw_21016(s):
    fill(s, (0, 0, 0, 0))
    for x in [4, 12, 20, 28]:
        rect(s, P['METAL_BASE'], (x, 0, 2, 32))
    rect(s, P['GREY_D'], (0, 4, 32, 2))

def draw_21017(s):
    fill(s, (0, 0, 0, 0))
    for x in range(4, 32, 8):
        rect(s, P['GREY_D'], (x, 0, 3, 32))

def draw_door(s, tid, name, col):
    draw_brick_base(s, P['STONE_SHADOW'])
    if "Open" in name:
        rect(s, P['BLACK'], (4, 4, 24, 24))
        rect(s, col, (24, 4, 4, 24))
    elif tid == 5310005:
        rect(s, P['BLACK'], (4, 4, 24, 24))
        line(s, col, (4, 4), (20, 20), 3)
    else:

        draw_pixel_bevel(s, pygame.Rect(4,4,24,24), col, blend(col, P['WHITE'], 0.2), blend(col, P['BLACK'], 0.3))
        if "Locked" in name:
            rect(s, P['GOLD'], (13, 14, 6, 5))
            circle(s, P['GOLD'], (16, 14), 2, 1)
        else:
            circle(s, P['YELLOW'], (22, 16), 2)

def draw_chest(s, tid, name):
    rect(s, P['WOOD_BASE'], (4, 8, 24, 16))
    rect(s, P['BLACK'], (4, 8, 24, 16), 1)
    if "Closed" in name:
        rect(s, P['WOOD_LIGHT'], (2, 6, 28, 6))
        rect(s, P['GOLD'], (14, 10, 4, 6))
        rect(s, P['GOLD'], (2, 6, 28, 2))
    else:
        rect(s, P['BLACK'], (6, 10, 20, 12))
        rect(s, P['WOOD_SHADOW'], (2, 2, 28, 6))

def draw_40101(s):
    fill(s, (0, 0, 0, 0))
    for ox, oy in [(10, 14), (22, 14), (16, 8), (16, 22)]:
        circle(s, P['GRASS_BASE'], (ox, oy), 8)

def draw_40102(s):
    fill(s, (0, 0, 0, 0))
    rect(s, P['GREEN'], (14, 10, 4, 22))
    circle(s, P['YELLOW'], (16, 8), 5)

def draw_40103(s):
    fill(s, (200, 200, 200, 80))
    for _ in range(3):
        circle(s, (255, 255, 255, 40), (random.randint(8, 24), random.randint(8, 24)), 8)

def draw_40104(s):
    fill(s, (0, 0, 0, 0))
    circle(s, (0, 0, 0, 120), (16, 16), 12)

def draw_40105(s):
    fill(s, (0, 0, 0, 0))
    rect(s, P['WHITE'], (6, 6, 20, 24))
    circle(s, P['BLUE'], (16, 16), 6, 2)

def draw_flower(s, col):
    fill(s, (0, 0, 0, 0))
    line(s, P['GREEN'], (16, 31), (16, 16), 2)
    circle(s, col, (16, 12), 6)
    circle(s, P['YELLOW'], (16, 12), 2)

def draw_40001(s): draw_flower(s, P['RED'])
def draw_40002(s): draw_flower(s, P['YELLOW'])

def draw_40003(s):
    fill(s, (0, 0, 0, 0))
    for _ in range(3):
        line(s, P['GREEN'], (16, 31), (random.randint(10, 22), 10), 2)

def draw_40004(s):
    fill(s, (0, 0, 0, 0))
    circle(s, P['GREY_M'], (12, 20), 4)
    circle(s, P['GREY_L'], (20, 24), 3)

def draw_40005(s):
    fill(s, (0, 0, 0, 0))
    circle(s, P['GREEN'], (16, 16), 12)
    poly(s, (0, 0, 0, 0), [(16, 16), (28, 8), (28, 24)])

def draw_41001(s):
    fill(s, (0, 0, 0, 0))
    rect(s, P['WOOD_SHADOW'], (12, 0, 8, 32))
    line(s, P['BLACK'], (12, 10), (20, 10))

def draw_41002(s):
    fill(s, (0, 0, 0, 0))
    line(s, P['WOOD_SHADOW'], (16, 31), (16, 10), 3)
    line(s, P['WOOD_SHADOW'], (16, 20), (6, 10), 2)

def draw_41003(s):
    fill(s, (0, 0, 0, 0))
    poly(s, P['STONE_BASE'], [(8, 28), (4, 16), (16, 4), (28, 16), (24, 28)])

def draw_41004(s):
    fill(s, (0, 0, 0, 0))
    rect(s, P['GREEN'], (13, 8, 6, 24))
    rect(s, P['GREEN'], (6, 14, 8, 4))

def draw_41005(s):
    fill(s, (0, 0, 0, 0))
    rect(s, P['GREY_M'], (4, 24, 24, 6))
    rect(s, P['BLUE'], (14, 10, 4, 14))

def draw_41006(s):
    fill(s, (0, 0, 0, 0))
    circle(s, P['GREY_D'], (16, 16), 14, 3)
    circle(s, P['BLACK'], (16, 16), 10)

def draw_51201(s):
    fill(s, (0, 0, 0, 0))
    rect(s, P['BROWN_L'], (4, 8, 24, 20))
    line(s, P['BLACK'], (4, 8), (28, 28))

def draw_51202(s):
    fill(s, (0, 0, 0, 0))
    rect(s, P['BROWN_M'], (4, 2, 24, 28))
    line(s, P['BLACK'], (16, 2), (16, 30))

def draw_51203(s):
    fill(s, (0, 0, 0, 0))
    rect(s, P['BROWN_M'], (2, 10, 28, 12))
    rect(s, P['BROWN_D'], (4, 22, 4, 8))

def draw_51204(s):
    fill(s, (0, 0, 0, 0))
    rect(s, P['BROWN_D'], (2, 4, 28, 24))
    rect(s, P['WHITE'], (4, 6, 24, 8))
    rect(s, P['BLUE'], (4, 14, 24, 14))

def draw_51205(s):
    fill(s, (0, 0, 0, 0))
    rect(s, P['GREY_M'], (10, 10, 12, 18))

def draw_51206(s):
    fill(s, P['GREY_M'])
    for i in range(6, 30, 6):
        line(s, P['BLACK'], (4, i), (28, i), 2)

def draw_51207(s):
    fill(s, (0, 0, 0, 0))
    rect(s, P['RED'], (8, 4, 16, 24), border_radius=3)

def draw_51208(s):
    fill(s, (0, 0, 0, 0))
    circle(s, P['WHITE'], (16, 22), 8)
    rect(s, P['WHITE'], (8, 4, 16, 10))

def draw_51001(s):
    fill(s, (0, 0, 0, 0))
    rect(s, P['BROWN_M'], (2, 8, 28, 16))
    rect(s, P['BROWN_D'], (4, 24, 4, 6))

def draw_51002(s):
    fill(s, (0, 0, 0, 0))
    rect(s, P['BROWN_L'], (8, 4, 16, 16))
    rect(s, P['BROWN_M'], (8, 20, 3, 8))

def draw_51003(s):
    fill(s, (0, 0, 0, 0))
    rect(s, P['BROWN_D'], (4, 8, 24, 16), border_radius=4)

def draw_51004(s):
    draw_wood_base(s, P['BROWN_M'], True)
    for y in [10, 22]:
        line(s, P['BLACK'], (2, y), (30, y), 2)

def draw_51005(s):
    fill(s, (0, 0, 0, 0))
    rect(s, P['BLACK'], (2, 6, 28, 20))
    rect(s, P['GREY_D'], (4, 8, 24, 16))

def draw_51006(s):
    fill(s, (0, 0, 0, 0))
    rect(s, P['WHITE'], (4, 2, 24, 28))
    line(s, P['GREY_M'], (4, 12), (28, 12))

def draw_51007(s):
    fill(s, (0, 0, 0, 0))
    rect(s, P['RED'], (4, 2, 24, 28))
    rect(s, P['BLACK'], (8, 6, 16, 12))

def draw_51008(s):
    fill(s, P['BLACK'])
    rect(s, P['WHITE'], (4, 20, 24, 8))
    for x in range(6, 28, 4):
        rect(s, P['BLACK'], (x, 20, 2, 5))

def draw_51301(s):
    draw_pro_noise(s, P['STONE_SHADOW'], 20)
    for _ in range(4):
        circle(s, P['METAL_LIGHT'], (random.randint(8, 24), random.randint(8, 24)), 4)

def draw_51302(s):
    fill(s, (0, 0, 0, 0))
    for _ in range(6):
        pts_list = [(random.randint(0, 31), random.randint(0, 31)) for _ in range(3)]
        poly(s, P['GREY_M'], pts_list)

def draw_51303(s):
    fill(s, P['GREY_D'])
    rect(s, P['BLACK'], (8, 12, 16, 16), border_top_left_radius=8)
    circle(s, P['ORANGE'], (16, 22), 5)

def draw_51305(s):
    fill(s, (0, 0, 0, 0))
    rect(s, P['BROWN_L'], (4, 12, 24, 14))
    rect(s, P['WHITE'], (10, 14, 12, 8))

def draw_51309(s):
    fill(s, (0, 0, 0, 0))
    rect(s, P['BLACK'], (10, 24, 12, 4))
    line(s, P['BLACK'], (16, 24), (16, 10), 4)

def draw_51310(s):
    fill(s, P['METAL_LIGHT'])
    rect(s, P['RED'], (14, 2, 4, 4))

def draw_51311(s):
    draw_pro_noise(s, P['METAL_RUST'], 10)
    circle(s, P['YELLOW'], (16, 16), 2)

def draw_51312(s):
    fill(s, P['METAL_BASE'])
    rect(s, P['BLACK'], (6, 6, 20, 14))

def draw_farm(s, tid, name):
    fill(s, P['DIRT_BASE'])
    for i in range(4, 32, 8):
        line(s, P['BROWN_D'], (0, i), (31, i), 1)
    if "Sprout" in name:
        line(s, P['GREEN'], (16, 20), (16, 12), 2)
    elif "Grown" in name:
        circle(s, P['ORANGE'], (16, 15), 4)

def draw_61001(s):
    fill(s, (0, 0, 0, 0))
    rect(s, P['METAL_BASE'], (15, 10, 2, 22))
    circle(s, P['LAMP_ON'], (16, 10), 6)

def draw_61002(s):
    fill(s, (0, 0, 0, 0))
    rect(s, P['BROWN_D'], (14, 20, 4, 12))
    poly(s, P['YELLOW'], [(8, 20), (24, 20), (16, 8)])

def draw_61003(s):
    fill(s, P['BRICK_RED'])
    rect(s, P['BLACK'], (8, 12, 16, 20), border_top_left_radius=8)

def draw_61004(s):
    fill(s, P['GREEN'])
    rect(s, P['WHITE'], (6, 10, 20, 12), 1)

def draw_61005(s):
    fill(s, (0, 0, 0, 0))
    poly(s, P['GREY_M'], [(4, 4), (16, 10), (4, 16)])
    circle(s, P['RED'], (16, 10), 2)

def draw_60001(s):
    fill(s, (0, 0, 0, 0))
    for _ in range(5):
        circle(s, (100, 50, 200, 100), (16, 16), random.randint(5, 15))

def draw_60002(s):
    fill(s, (0, 0, 0, 0))
    poly(s, P['YELLOW'], [(4, 16), (16, 4), (16, 12), (28, 12), (28, 20), (16, 20), (16, 28)])

def draw_60003(s):
    fill(s, P['METAL_BASE'])
    for x in [8, 24]:
        poly(s, P['GREY_L'], [(x, 31), (x-4, 16), (x+4, 16)])

def create_texture(tid):
    s = pygame.Surface((32, 32), pygame.SRCALPHA)
    if tid not in TILE_DATA:
        fill(s, (255, 0, 255)); return s
    d = TILE_DATA[tid]
    name, col = d['name'], d.get('color', P['GREY_M'])

    if tid == 1110000: draw_10001(s)
    elif tid == 1110001: draw_10002(s)
    elif tid == 1110002: draw_10003(s)
    elif tid == 1110003: draw_10004(s)
    elif tid == 1110004: draw_10005(s)
    elif tid == 1110005: draw_10006(s)
    elif tid == 1110006: draw_10007(s)
    elif tid == 1110007: draw_10008(s)
    elif tid == 1110008: draw_10009(s)
    elif tid == 1110009: draw_10010(s)
    elif tid == 1110010: draw_10014(s)
    elif tid == 1110011: draw_10015(s)
    elif tid == 1110012: draw_10016(s)
    elif tid == 1110013: draw_10017(s)
    elif tid == 1110014: draw_10019(s)
    elif tid == 1110015: draw_10020(s)
    elif tid == 1120016: draw_11001(s)
    elif tid == 1120017: draw_11002(s)
    elif tid == 1120018: draw_11003(s)
    elif tid == 2110000: draw_10011(s)
    elif tid == 2110001: draw_10012(s)
    elif tid == 2110002: draw_10013(s)
    elif tid == 2110003: draw_10018(s)
    elif tid == 3220000: draw_21001(s)
    elif tid == 3220001: draw_21002(s)
    elif tid == 3220002: draw_21003(s)
    elif tid == 3220003: draw_21004(s)
    elif tid == 3220004: draw_21005(s)
    elif tid == 3220005: draw_21006(s)
    elif tid == 3220006: draw_21007(s)
    elif tid == 3220007: draw_21008(s)
    elif tid == 3220008: draw_21009(s)
    elif tid == 3220009: draw_21010(s)
    elif tid == 3220010: draw_21011(s)
    elif tid == 3220011: draw_21012(s)
    elif tid == 3220012: draw_21013(s)
    elif tid == 3220013: draw_21014(s)
    elif tid == 4220000: draw_21015(s)
    elif tid == 4220001: draw_21016(s)
    elif tid == 4220002: draw_21017(s)
    elif tid // 1000000 == 5:
        if tid in [5321025, 5310025]: draw_chest(s, tid, name)
        else: draw_door(s, tid, name, col)
    elif tid == 6310000: draw_40001(s)
    elif tid == 6310001: draw_40002(s)
    elif tid == 6310002: draw_40003(s)
    elif tid == 6310003: draw_40005(s)
    elif tid == 6310008: draw_41004(s)
    elif tid == 6310104: draw_40101(s)
    elif tid == 6310105: draw_40102(s)
    elif tid == 6310106: draw_41001(s)
    elif tid == 6310107: draw_41002(s)
    elif tid == 7310000: draw_40004(s)
    elif tid == 7310007: draw_60001(s)
    elif tid == 7310008: draw_60002(s)
    elif tid == 7310009: draw_60003(s)
    elif tid == 7310010: draw_61001(s)
    elif tid == 7310011: draw_61005(s)
    elif tid == 7310101: draw_40103(s)
    elif tid == 7310102: draw_40104(s)
    elif tid == 7310103: draw_40105(s)
    elif tid == 7320005: draw_41005(s)
    elif tid == 7320006: draw_41006(s)
    elif tid == 7320204: draw_41003(s)
    elif tid == 8310016: draw_61002(s)
    elif tid == 8310208: draw_51201(s)
    elif tid == 8320001: draw_51002(s)
    elif tid == 8320004: draw_51005(s)
    elif tid == 8320007: draw_51008(s)
    elif tid == 8320017: draw_61003(s)
    elif tid == 8320018: draw_61004(s)
    elif tid == 8320200: draw_51001(s)
    elif tid == 8320202: draw_51003(s)
    elif tid == 8320203: draw_51004(s)
    elif tid == 8320205: draw_51006(s)
    elif tid == 8320209: draw_51202(s)
    elif tid == 8320210: draw_51203(s)
    elif tid == 8320212: draw_51205(s)
    elif tid == 8320213: draw_51206(s)
    elif tid == 8320214: draw_51207(s)
    elif tid == 8320215: draw_51208(s)
    elif tid == 8321006: draw_51007(s)
    elif tid == 8321211: draw_51204(s)
    elif tid == 9312000: draw_farm(s, tid, name)
    elif tid == 9312001: draw_farm(s, tid, name)
    elif tid == 9312002: draw_farm(s, tid, name)
    elif tid == 9312003: draw_10005(s)
    elif tid == 9322004: draw_51301(s)
    elif tid == 9322005: draw_51302(s)
    elif tid == 9322006: draw_51303(s)
    elif tid == 9322007: draw_51305(s)
    elif tid == 9322008: draw_51309(s)
    elif tid == 9322009: draw_51310(s)
    elif tid == 9322010: draw_51311(s)
    elif tid == 9322011: draw_51312(s)
    else:
        draw_pro_noise(s, col, 20)
    return s

TILE_DATA = {
    1110000: {'name': 'Dirt Floor (흙 바닥)', 'color': P['DIRT_BASE']},
    1110001: {'name': 'Grass Floor (풀 바닥)', 'color': P['GRASS_BASE']},
    1110002: {'name': 'Gravel Floor (자갈 바닥)', 'color': P['STONE_BASE']},
    1110003: {'name': 'Sand Floor (모래 바닥)', 'color': P['SAND_BASE']},
    1110004: {'name': 'Shallow Water (얕은 물)', 'color': P['WATER_BASE']},
    1110005: {'name': 'Cave Floor (동굴 바닥)', 'color': P['STONE_SHADOW']},
    1110006: {'name': 'Mossy Stone (이끼 낀 돌)', 'color': P['STONE_BASE']},
    1110007: {'name': 'Wood Floor L (밝은 나무)', 'color': P['WOOD_LIGHT']},
    1110008: {'name': 'Wood Floor D (어두운 나무)', 'color': P['WOOD_BASE']},
    1110009: {'name': 'Marble Floor (대리석)', 'color': P['MARBLE']},
    1110010: {'name': 'Concrete Floor (콘크리트)', 'color': P['CONCRETE']},
    1110011: {'name': 'Asphalt Road (아스팔트)', 'color': P['BLACK']},
    1110012: {'name': 'Road Line (차선)', 'color': P['ASPHALT']},
    1110013: {'name': 'Broken Concrete (깨진 바닥)', 'color': P['CONCRETE']},
    1110014: {'name': 'Iron Grate (철창 바닥)', 'color': P['METAL_BASE']},
    1110015: {'name': 'Ice (얼음)', 'color': P['ICE_BASE']},
    1120016: {'name': 'Deep Water (깊은 물)', 'color': (20, 30, 60)},
    1120017: {'name': 'Lava (용암)', 'color': P['RED']},
    1120018: {'name': 'Cliff (절벽)', 'color': P['BROWN_D']},
    2110000: {'name': 'Checkered Tile (체크무늬)', 'color': P['WHITE']},
    2110001: {'name': 'Red Carpet (레드 카펫)', 'color': P['RED']},
    2110002: {'name': 'Blue Carpet (블루 카펫)', 'color': P['BLUE']},
    2110003: {'name': 'Lab Tile (실험실 바닥)', 'color': P['WHITE']},
    3220000: {'name': 'Red Brick Wall (붉은 벽돌)', 'color': P['BRICK_RED']},
    3220001: {'name': 'Grey Brick Wall (회색 벽돌)', 'color': P['STONE_BASE']},
    3220002: {'name': 'Mossy Wall (이끼 벽)', 'color': P['STONE_BASE']},
    3220003: {'name': 'Wood Wall (나무 벽)', 'color': P['WOOD_BASE']},
    3220004: {'name': 'Log Wall (통나무 벽)', 'color': P['WOOD_SHADOW']},
    3220005: {'name': 'White Wall (흰 벽)', 'color': P['WHITE']},
    3220006: {'name': 'Wallpaper (벽지)', 'color': (200, 160, 160)},
    3220007: {'name': 'Toilet Tile Wall (타일 벽)', 'color': (200, 220, 255)},
    3220008: {'name': 'Lab Metal Wall (금속 벽)', 'color': P['METAL_LIGHT']},
    3220009: {'name': 'Rusty Wall (녹슨 벽)', 'color': P['ORANGE']},
    3220010: {'name': 'Glass Wall (유리 벽)', 'color': (200, 220, 255)},
    3220011: {'name': 'Reinforced Glass (강화 유리)', 'color': (150, 180, 200)},
    3220012: {'name': 'Bookshelf Wall (책장 벽)', 'color': P['BROWN_M']},
    3220013: {'name': 'Cave Wall (동굴 벽)', 'color': P['STONE_SHADOW']},
    4220000: {'name': 'Wood Fence (나무 울타리)', 'color': P['WOOD_LIGHT']},
    4220001: {'name': 'Iron Fence (철 울타리)', 'color': P['METAL_BASE']},
    4220002: {'name': 'Prison Bars (창살)', 'color': P['STONE_SHADOW']},
    5310000: {'name': 'Wood Door Open (나무문 열림)', 'color': P['WOOD_BASE']},
    5310001: {'name': 'Iron Door Open (철문 열림)', 'color': P['METAL_BASE']},
    5310002: {'name': 'Glass Door Open (유리문 열림)', 'color': (200, 220, 255)},
    5310003: {'name': 'Prison Door Open (철창문 열림)', 'color': P['STONE_SHADOW']},
    5310004: {'name': 'Lab Door Open (연구소문 열림)', 'color': P['WHITE']},
    5310005: {'name': 'Broken Door (부서진 문)', 'color': P['WOOD_SHADOW']},
    5321008: {'name': 'Glass Door Closed (유리문 닫힘)', 'color': (200, 220, 255)},
    5321009: {'name': 'Prison Door Closed (철창문 닫힘)', 'color': P['STONE_SHADOW']},
    5321010: {'name': 'Lab Door Closed (연구소문 닫힘)', 'color': P['WHITE']},
    5321206: {'name': 'Wood Door Closed (나무문 닫힘)', 'color': P['WOOD_BASE']},
    5321207: {'name': 'Iron Door Closed (철문 닫힘)', 'color': P['METAL_BASE']},
    5323220: {'name': 'Wood Door Locked (나무문 잠김)', 'color': P['WOOD_BASE']},
    5323221: {'name': 'Iron Door Locked (철문 잠김)', 'color': P['METAL_BASE']},
    5323022: {'name': 'Glass Door Locked (유리문 잠김)', 'color': (200, 220, 255)},
    5323023: {'name': 'Prison Door Locked (철창문 잠김)', 'color': P['STONE_SHADOW']},
    5323024: {'name': 'Lab Door Locked (연구소문 잠김)', 'color': P['WHITE']},


    5321025: {'name': 'Treasure Chest Closed (보물상자)', 'color': P['WOOD_LIGHT']},
    5310025: {'name': 'Treasure Chest Open (빈 상자)', 'color': P['WOOD_SHADOW']},

    6310000: {'name': 'Red Flower (빨간 꽃)', 'color': P['RED']},
    6310001: {'name': 'Yellow Flower (노란 꽃)', 'color': P['YELLOW']},
    6310002: {'name': 'Weed (잡초)', 'color': P['GREEN']},
    6310003: {'name': 'Lotus (연잎)', 'color': P['GRASS_BASE']},
    6310008: {'name': 'Cactus (선인장)', 'color': P['GREEN']},
    6310104: {'name': 'Tall Bush (덤불)', 'color': P['GRASS_BASE']},
    6310105: {'name': 'Corn Field (옥수수)', 'color': P['YELLOW']},
    6310106: {'name': 'Tree Trunk (나무)', 'color': P['WOOD_SHADOW']},
    6310107: {'name': 'Dead Tree (죽은 나무)', 'color': P['WOOD_SHADOW']},
    7310000: {'name': 'Pebble (자갈)', 'color': P['STONE_LIGHT']},
    7310007: {'name': 'Portal (포털)', 'color': (100, 50, 200)},
    7310008: {'name': 'Exit Mark (출구)', 'color': P['YELLOW']},
    7310009: {'name': 'Spike Trap (함정)', 'color': P['METAL_BASE']},
    7310010: {'name': 'Street Light (가로등)', 'color': P['METAL_BASE']},
    7310011: {'name': 'CCTV Camera (CCTV)', 'color': P['METAL_LIGHT']},
    7310101: {'name': 'Dense Fog (안개)', 'color': P['GREY_L']},
    7310102: {'name': 'Shadow (그림자)', 'color': P['BLACK']},
    7310103: {'name': 'Laundry (빨래)', 'color': P['WHITE']},
    7320005: {'name': 'Fountain (분수)', 'color': P['STONE_LIGHT']},
    7320006: {'name': 'Well (우물)', 'color': P['STONE_SHADOW']},
    7320204: {'name': 'Rock (바위)', 'color': P['STONE_BASE']},
    8310016: {'name': 'Lamp (램프)', 'color': P['YELLOW']},
    8310208: {'name': 'Box (상자)', 'color': P['WOOD_LIGHT']},
    8320001: {'name': 'Wood Chair (의자)', 'color': P['WOOD_LIGHT']},
    8320004: {'name': 'TV (텔레비전)', 'color': P['BLACK']},
    8320007: {'name': 'Piano (피아노)', 'color': P['BLACK']},
    8320017: {'name': 'Fireplace (벽난로)', 'color': P['BRICK_RED']},
    8320018: {'name': 'Exit Sign (비상구)', 'color': P['GREEN']},
    8320200: {'name': 'Dining Table (식탁)', 'color': P['WOOD_BASE']},
    8320202: {'name': 'Sofa (소파)', 'color': P['WOOD_SHADOW']},
    8320203: {'name': 'Bookshelf (책장)', 'color': P['WOOD_BASE']},
    8320205: {'name': 'Refrigerator (냉장고)', 'color': P['WHITE']},
    8320209: {'name': 'Closet (옷장)', 'color': P['WOOD_BASE']},
    8320210: {'name': 'Desk (책상)', 'color': P['WOOD_BASE']},
    8320212: {'name': 'Trash Can (쓰레기통)', 'color': P['METAL_BASE']},
    8320213: {'name': 'Vent (환풍구)', 'color': P['METAL_BASE']},
    8320214: {'name': 'Drum Barrel (드럼통)', 'color': P['RED']},
    8320215: {'name': 'Toilet (변기)', 'color': P['WHITE']},
    8321006: {'name': 'Vending Machine (자판기)', 'color': P['RED']},
    8321211: {'name': 'Bed (침대)', 'color': P['BLUE']},
    9312000: {'name': 'Empty Field (빈 밭)', 'color': P['DIRT_BASE']},
    9312001: {'name': 'Sprout Field (새싹)', 'color': P['DIRT_BASE']},
    9312002: {'name': 'Grown Field (수확)', 'color': P['DIRT_BASE']},
    9312003: {'name': 'Fishing Spot (낚시터)', 'color': P['BLUE']},
    9322004: {'name': 'Iron Ore (철광석)', 'color': P['STONE_SHADOW']},
    9322005: {'name': 'Rubble (잔해)', 'color': P['STONE_BASE']},
    9322006: {'name': 'Furnace (용광로)', 'color': P['STONE_SHADOW']},
    9322007: {'name': 'Cutting Board (도마)', 'color': P['WOOD_LIGHT']},
    9322008: {'name': 'Microscope (현미경)', 'color': P['WHITE']},
    9322009: {'name': 'Surgery Table (수술대)', 'color': P['METAL_LIGHT']},
    9322010: {'name': 'Broken Panel (고장난 패널)', 'color': P['METAL_RUST']},
    9322011: {'name': 'Computer (컴퓨터)', 'color': P['METAL_BASE']},
}

NEW_ID_MAP = {
    10001: 1110000, 10002: 1110001, 10003: 1110002, 10004: 1110003, 10005: 1110004, 10006: 1110005,
    10007: 1110006, 10008: 1110007, 10009: 1110008, 10010: 1110009, 10014: 1110010, 10015: 1110011,
    10016: 1110012, 10017: 1110013, 10019: 1110014, 10020: 1110015, 11001: 1120016, 11002: 1120017,
    11003: 1120018, 10011: 2110000, 10012: 2110001, 10013: 2110002, 10018: 2110003, 21001: 3220000,
    21002: 3220001, 21003: 3220002, 21004: 3220003, 21005: 3220004, 21006: 3220005, 21007: 3220006,
    21008: 3220007, 21009: 3220008, 21010: 3220009, 21011: 3220010, 21012: 3220011, 21013: 3220012,
    21014: 3220013, 21015: 4220000, 21016: 4220001, 21017: 4220002, 30001: 5310000, 30002: 5310001,
    30003: 5310002, 30004: 5310003, 30005: 5310004, 30099: 5310005, 31303: 5321008, 31304: 5321009,
    31305: 5321010, 31301: 5321206, 31302: 5321207, 40001: 6310000, 40002: 6310001, 40003: 6310002,
    40005: 6310003, 41004: 6310008, 40101: 6310104, 40102: 6310105, 41001: 6310106, 41002: 6310107,
    40004: 7310000, 60001: 7310007, 60002: 7310008, 60003: 7310009, 61001: 7310010, 61005: 7310011,
    40103: 7310101, 40104: 7310102, 40105: 7310103, 41005: 7320005, 41006: 7320006, 41003: 7320204,
    61002: 8310016, 51201: 8310208, 51002: 8320001, 51005: 8320004, 51008: 8320007, 61003: 8320017,
    61004: 8320018, 51001: 8320200, 51003: 8320202, 51004: 8320203, 51006: 8320205, 51202: 8320209,
    51203: 8320210, 51205: 8320212, 51206: 8320213, 51207: 8320214, 51208: 8320215, 51007: 8321006,
    51204: 8321211, 10306: 9312000, 10307: 9312001, 10308: 9312002, 50304: 9312003, 51301: 9322004,
    51302: 9322005, 51303: 9322006, 51305: 9322007, 51309: 9322008, 51310: 9322009, 51311: 9322010,
    51312: 9322011
}

BED_TILES = [8321211, 9322009]
HIDEABLE_TILES = [6310104, 8310208, 8320209, 8320210, 8321211, 8320212]
